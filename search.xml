<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Confusing 'for' in C++]]></title>
    <url>%2F2019%2F07%2F09%2FConfusing-for-in-C%2F</url>
    <content type="text"><![CDATA[当我按下那个F5之前，一切都是那么的美好 Question如何复制一个数组？ 123456789101112131415161718/** B为被复制数组* B._size= count* A._size= count*/// 普通版本for(int i =0; i &lt; count ; i++)&#123; A[i] = B[i];&#125;// 我偏不这么干// 我选择for(int i =0; i&lt; count; A[i]=B[i++]);// 赋值从A[1]开始....在_CAPACITY==_size的情况下，数组越界// 鬼畜的版本for(int i =0; i&lt; count; A[i++]=B[i]);//这次不会越界，但是B[0]压根没进来啊 我认为关键在于for语句三段式中，表达式3到底是个什么鬼东西 至于到底为什么 emmmm, I have no idea. Answer 2019年7月14日18点08分更新 自增运算符优先级大于[]，问题结束 思考题1234int i = 1;int j = (++i)+(++i); j 等于？]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ operator 'new']]></title>
    <url>%2F2019%2F07%2F08%2FC-operator-new%2F</url>
    <content type="text"><![CDATA[如题，我们来谈一下 new 这个操作符 Question C++ 中如何释放类的实例化对象？ 当然你可以选择不释放 下面是一个Test 类的实现，包括了两种实例化的方法 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;class Test&#123;private: int num;public: Test(int num); ~Test();&#125;; Test::Test (int num)&#123; this-&gt; num = num;&#125; Test::~Test()&#123; std::cout&lt;&lt;"NO: "&lt;&lt;this-&gt; num&lt;&lt;" 执行析构函数"&lt;&lt;std::endl; getchar();&#125;int main()&#123; Test test(1);//不适用new Test *pTest = new Test (2);//使用new delete pTest; return 0;&#125; 如果你尝试（对照修改并）运行一下的话, 会发现程序是正确的 会发现： delete相当于手动调用析构函数 test(1) 的析构函数是自动完成的 两种方法实例化对象的析构函数调用方式并不相同 这似乎是废话，但我们还是再保持一点耐心吧＜（＾－＾）＞ Answer答案在于实例化对象分为栈对象和堆对象两种，他们存储的地址不同，对应的析构策略也不一样 具体参考C++ 内存地址 栈区（stack） 由编译器自动分配释放 存放函数的参数值，局部变量的值等，形式上类似于数据结构中的栈 Windows下，栈数据结构向低地址扩展，大小受限。Stack overflow 堆区（heap） 由程序员分配释放 若程序员不释放，程序结束时可能由OS回收，更有可能出现内存泄漏。 形式上和数据结构的堆一点也不一样，倒是像链表。 Windows下，堆向高地址扩展，内存不受限制，但受到寻访空闲内存地址的影响，会稍慢且容易造成内存碎片 全局区/静态区（static） 程序结束后由系统释放 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 值得注意的是，堆区对象的指针仍然在栈中 总结 我们创建的类对象分为堆对象和栈对象 栈对象则由系统在函数体结束时自动释放，但可能会栈溢出；栈对象的析构遵从栈结构的特点，最后构造的对象最先被析构 堆对象需要手动delete，不然会内存泄漏；堆对象的析构顺序决定于delete 的调用顺序 思考单个对象的构造函数和析构函数的调用顺序如何？ 考虑继承哦 依照一定顺序实例化的多个对象呢？]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰式相关]]></title>
    <url>%2F2019%2F05%2F27%2F%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。 wikipedia 逆波兰式运算 从左向右读取表达式 遇到数字压入栈中 遇到运算符则两数字出栈进行运算，运算结果压栈 代码实现#include&lt;iostream&gt; // to do // 没想到吧，哈哈哈哈哈 // 以后再填坑，老子现在要复习]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>dataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pipenv]]></title>
    <url>%2F2019%2F05%2F16%2FPipenv%2F</url>
    <content type="text"><![CDATA[Pipenv 一个独立且完整的 python 虚拟环境管理 提供基于独立环境的独立 python 项目管理方法 可以帮助我们摆脱多个项目的依赖库相互排斥的问题 为什么选择Pipenv python 社区主流推荐 自动记录第三方库依赖 采用哈希校验，包管理操作更加安全 可以根据 pipfile 和 pipfile.lock 快速创建配置虚拟环境 Let`s go ahead请注意，本篇文章全程默认操作系统为 Windows，python 版本默认为 python 3.7 安装pipenv确保你的电脑正确安装了 python3 和 pip3 12345# python3 下安装方式pip install pipenv# 同时存在 py2 和 py3pip3 install pipenv 创建并激活env假设我们当前的资源管理器路径是 D:\\project ， 我们需要在project文件夹下创建一个 Django 文件夹， 然后在其中创建项目的虚拟环境 123456789101112# 创建虚拟环境mkdir djangocd djangopipenv --python 3.7# 查看相关信息pipenv --wherepipenv --venvpipenv --py# 激活pipenv shell 激活状态操作激活状态下操作主要是包管理和 .py 文件执行 1234567891011121314151617181920212223242526python xx.py# 安装与卸载pipenv install [第三方包]pipenv uninstall [第三方包] # 如果不输入第三方包名，会发生什么呢？# 显示依赖库结构pipenv graph# 调出帮助*pipenv --help# 退出环境exit# 删除当前虚拟环境pipenv -rm 建议多使用 pipenv --help 命令 项目同步必需文件： Pipfle 和 Pipfile.lock 已完成的逻辑代码 1234567# 拉取项目到本地cd [project]pipenv install# 大功告成 pipenv install无参数命令会首先检查当前目录中的 pipfile 若有，则立刻安装符合 pipfile 和 pipfile.lock 的虚拟环境和依赖库 若无，什么也不会发生 pipenv 环境变量pipenv内置了很多环境变量，可以通过设置这些环境变量来配置pipenv 1234567891011121314151617181920212223242526$ pipenv --envsThe following environment variables can be set, to do various things: - PIPENV_MAX_DEPTH - PIPENV_SHELL - PIPENV_DOTENV_LOCATION - PIPENV_HIDE_EMOJIS - PIPENV_CACHE_DIR - PIPENV_VIRTUALENV - PIPENV_MAX_SUBPROCESS - PIPENV_COLORBLIND - PIPENV_VENV_IN_PROJECT # 在项目根路径下创建虚拟环境 - PIPENV_MAX_ROUNDS - PIPENV_USE_SYSTEM - PIPENV_SHELL_COMPAT - PIPENV_USE_HASHES - PIPENV_NOSPIN - PIPENV_PIPFILE - PIPENV_INSTALL_TIMEOUT - PIPENV_YES - PIPENV_SHELL_FANCY - PIPENV_DONT_USE_PYENV - PIPENV_DONT_LOAD_ENV - PIPENV_DEFAULT_PYTHON_VERSION # 设置创建虚拟环境时默认的python版本信息，如: 3.6 - PIPENV_SKIP_VALIDATION - PIPENV_TIMEOUT 例如我会选择设置 PIPENV_VENV_IN_PROJECT = 1 ，使pipenv 的虚拟环境默认放在项目根目录下 修改pipenv 下载源pipfile中修改下载源为阿里源，如下 1234[[source]]name = &quot;pypi&quot;url = &quot;https://mirrors.aliyun.com/pypi/simple&quot;verify_ssl = true 总结所以为什么不用 pycharm 呢，JB快点给我五毛广告费]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Turtorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nothing Matters]]></title>
    <url>%2F2019%2F01%2F26%2FNothing-Matters%2F</url>
    <content type="text"><![CDATA[Weather the God knows how to padding the void of human`s heart ? It`s nature of human beings to be irritable, jealous, weak and greedy. I hold the belief that life is the never ending battle to confront with them. So that, to be a beast, a man or sth else, mostly would rely on your own . Merely I would get offended with no obvious reason, making my friend/family feel confused, even be hurt. However, I trust it that you would be with me once you in such a moment which every one is consuming your patience by repeating something inessential again and again. If I were irritable at one time, the reason is nothing but the surrounding stupid people.]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
      <tags>
        <tag>艾穆-安格瑞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Destination of 2018]]></title>
    <url>%2F2018%2F12%2F31%2F%E4%BA%8C%E3%80%87%E4%B8%80%E5%85%AB%2F</url>
    <content type="text"><![CDATA[二〇一八年的最后一天 今天是二〇一八年最后一天。 我想与自己聊一聊，可能是尚未消逝于脑海的过往，已经做好打算的未来，亦或只是单纯聊聊现在坐在图书馆的自己。 最近有什么值得回忆的事情呢….. 啊…..好像不怎么能记起来了，难道是因为黑历史太多了吗（笑），感觉要归功于自己今年努力保持不引人注意的成果。 ——其实还是有的。例如暑假和一群大一的小朋友完成了自己的暑期实践+毛概论文。总的来说，作为团队的一份子，我没怎么摸到鱼，顺便了解到创业的客观政策情况与创业者的个人观念。 结论嘛……..对于大多数的大学生创业者来说，大创活动就是面向PPT创业ORZ…… 再者就是一些对我影响非常大的事件了。 大概10月吧，就是学习了一点python，学了一点数据结构，学了一点奇奇怪怪的知识，想要分享自己的每一阶段的学习经历和成果 菜到不行的鶸总是会有一个幼稚的幻想。 CSDN算是一个选择，但我最初想的是利用利用阿里云ECS搭建一个博客网站，也成功的利用word press搭建了自己的第一个网站——虽然她连域名都没有就到期了QAQ。 总之我选择了Hexo，它可以很简洁，可以很好看。最重要的是，HEXO完全属于自己，而我恰好需要一个这样的能够体现自己的平台。 每一个鶸都会在一些花里胡哨的地方误入歧途。 我也一样 ，此处并没有表情包！ 经过一点折腾，HEXO搭建完成，我真的蛮高兴的，于是我想着要把她变得好看一点，更好看一点。于是去查阅别人利用Hexo搭建的博客，一点一点的尝试，认为自己在做很有意义的事。 之后是另一个关键的时间点。 我遇到了……emmmmm，用AZ来代指吧！ 很庆幸遇到了AZ，人类永远无法真正理解旁人的感受，正如只有我自己才能明白AZ之于我是什么意义，言语无法传达，或者说把它锁在自己心里就足够了。 如果说，之前的得过且过学好老师指定的课程，然后空闲时间打打游戏追追番剧就OK的话，我现在只觉得那是一种对自己的侮辱。 更加令我痛苦的是，我正在做的事情，是别人在很久以前就接触的事物。而他们，也只是利用了自己的业余时间而已…… 以前我总喜欢用咸鱼来自嘲：”咸鱼咸鱼咸~“。有个道理大家都懂，只有有钱人才能哭喊自己好穷，智商高的家伙才能说自己智商一般，全靠努力。 都只是调侃，谁当真谁傻X。 AZ和他的朋友们有时候也会觉得自己很丧，觉得自己什么都做不好。所以当我与AZ，与AZ的朋友们对比时。我觉得自己真的不配用咸鱼来自嘲——我在NJU所做的一切，都没有跳出所谓的COMFORT ZONE，在某种意义上，我只是一个在原地踏步的The Blind。而他们，才是真正的在春风料峭中鲜衣怒马红刀的风流少年。 记忆会随着时光的侵蚀而逐渐淡化，我突然想要写一篇水水的博文也只是想留下一抹来自二〇一八的过往。 就这样吧。]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
      <tags>
        <tag>memoria</tag>
        <tag>unknown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simple Tutorial for C++ Programming]]></title>
    <url>%2F2018%2F12%2F29%2FC%2B%2B%20Programing%2F</url>
    <content type="text"><![CDATA[Better Than Nothing 前言这只是心血来潮的产物, 他的内容基础到我都不好意思称呼他为一篇正经的C++指南….. 最致命的一点, 估计就是大量的默认了解过C语言的相关概念了…… 总之算是我的一个尝试吧, 使我知道了写这样的博文会很蛋疼 计算机与C++简介 选择性了解 计算机组成 输入单元 (input unit) 输出单元 (output unit) 内存单元 (memory unit) 算术逻辑单元 (arithmetic and logic unit, ALU) 中央处理器 (central processing unit, CPU) 辅助存储单元 (secondary storage unit) 数据的层次结构 位 (Bit)位, 计算机最小的数据项, 数值为0或1. (Binary digit) 字符 (Charater)Unicode字符集包含了世界上很多中语言, 每个字符是由两个字节(Byte)组成, 每个字节是8位. 流行的ASCII(美国信息交换标准代码) 是Unicode的子集. 字段 (Field) 记录 (Record) 文件 (File) 数据库 (Database)层次结构中, 除去数据库之外, 其余相邻层次均为组成与被组成关系 语言 机器语言一般由0/1组成, 令人费解. 计算机能直接执行. 汇编语言采用类似英语缩写的指令表示基本操作. 汇编器(assembler) 负责将汇编语言转换成机器语言, 然后才能被计算机理解. 高级语言抽象程度更高, 一种方式是采用编译器(compiler)转换为机器语言. 例如: C++, Java, C#等.另一种方式是采用解释器(interpreter), 可以直接执行高级语言程序 (没有编译的延迟), 但是执行过程会慢得多. 脚本语言采用解释器来处理, 例如: JavaScript, PHP 面向对象编程(OOP) 对象 成员函数和类 实例化 重用 消息和成员函数调用 属性和数据成员 封装 (encapsulate) 继承 (inheritance) UML (统一建模语言)Unified Modeling Language C++ 编程入门 没什么好说的, 简单提几点 输入/输出流 输出流对象std::cout用于输出数据, 串联的流插入运算符&lt;&lt;可以输出多个数据 输入流对象std::cin用于输入数据, 串联的流提取运算符&lt;&lt;可以输入多个数据请记住, cout和cin是对象, 这一点在运算符重载中会有体现 变量和内存 每个变量都具有: 名字, 值, 类型, 内存大小,存储类别, 作用域和链接 . 对内存的读取过程是非破坏性的, 写入则相反 其余 求模运算符 (%) 只能得到整数除法的余数 using 声明using std::cout;表示告知编译器, 在命名空间 std 中找到cout 类, 对象和字符串 类、对象、数据成员、成员函数、UML图、构造函数 ### 类的定义 通常来说, 类应当包括数据成员和成员函数, 两者对应着类的属性和行为 成员访问说明符: public`privateprotected` 类的数据成员应当设计成私有（private）、成员函数设计成公有（public） 按照惯例, 类名每个单词首字母大写, 函数名则采用驼峰式写法这样优雅 成员函数 成员函数一般声明为public 定义同C语言的函数语法 数据成员 数据成员可以被声明为 public/private/protected 尽可能复用get/set函数，以便于建立更为强壮（易维护）的类get/set函数是类提供的对私有成员(private) 的访问接口 应当将数据成员私有化通过公有函数控制访问数据成员的权利，保证数据的完整性. 数据完整性还包括对有效性的检查和报告错误 构造函数（constructor） 构造函数初始化对象； 构造函数可能为非显式；例如类string默认字符串的构造函数为空串 explicit构造函数必须显式调用。原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。QUATE 构造函数不能返回值 通常构造函数声明为public（成员访问说明符) Account类构造函数定义如下123Account::Account(int number):number(number)&#123;&#125; 此例中，构造函数通过成员初始化列表用构造函数形参number初始化数据成员number 析构函数形式通常为~+构造函数 接口与实现的分离所谓接口是指函数原型(函数声明), 实现是指函数定义. 好的实践是将二者分离, 即头文件定义类并对函数声明, 外部cpp定义类的成员函数. ::二元作用域分辨运算符 (scope resolution operator), 成员函数定义在类定义外部时启用 using指令和声明不应放在头文件中 函数原型告知编译器函数的名字、返回类型、形参类型；函数定义则是包含函数的实现 字符串(string) string是C++标准库类型 读取字符串时，流提取运算符读取字符在遇到第一个空白字符时停止，所以使用getline(cin，xxx)替代cin&lt;&lt;xxx substr函数中，第一个参数表示起始位置，第二个表示复制字符的个数 UML图 UML图分为三层, 每一层用横线隔开, 采用+`-`对应公有和私有 上层为类名 1GradeBook 中层为数据成员 1- course Name:String 下层为成员函数 1234&lt;&lt;constructor&gt;&gt; + GradeBook(name:String)+ setName(name:String)+ getCourse Name():String+ displayMessage() 本章小结：建立类、接口与实现分离、构造函数初始化对象、UML图 对于new的对象应使用destroctor（析构函数，防止内存泄漏）； 结构体声明也会初始化对象 控制语句(Ⅰ)赋值、自增自减运算符 主要内容和C语言类似, 不必展开. 其余内容无法展开 控制结构 (control structure) 顺序 (sequence), 选择 (selection)和循环 (repetition) 循环控制结构分为: 计数器控制和标记控制 控制结构可以嵌套 One Trick of Selection Structure123i = i==1?i=0:i=1;cout&lt;&lt;(grade&gt;=60?&quot;passed&quot;:&quot;failed&quot;; ### 赋值 Int A = 1.3 ; 警告但仍能编译；Int A = { 1.3 };出现错误，无法编译。这是一种‘缩小转换，我们应该尽量避免 可以使用 static_cast()来强制转换类型 ​ 自增自减运算符 --a和a--的区别: a--中，变量表达式先使用a值，再对a进行更新--a中，a先更新，然后在变量表达式中使用123int i= 1;cout&lt;&lt;i++&lt;&lt;endl;// i=2 ;输出 1; 自增自减运算符不可用于表达式：如(x+1)++为错 本章小结： 算法：根据索要执行的动作及这些动作执行的顺序描述的解决问题的过程； 伪代码: 没啥用 控制结构（顺序、选择、循环）: 顺序结构； 选择结构：选择语句（单路选择if，双路选择if else）、循环语句while 循环结构； 控制语句(Ⅱ)和逻辑运算符switch这不是游戏机!!12345678switch (grade)&#123; case &apos;A&apos;; case &apos;a&apos;: &#123;cout&lt;&lt;&quot;guna!!!&quot;; break;&#125; default: cout&lt;&lt;&quot;rua!!!&quot;&lt;&lt;endl; break;&#125; break &amp; continue结束和跳过的区别 本章小结： for语句；do..while语句；switch多路选择语句；break&amp;continue语句；逻辑运算符||、&amp;&amp;、！；==、=运算符；结构化编程：任何形式的控制都可以用顺序、选择、循环语句来表达，并且这些语句的组合方式只有堆叠和嵌套； 函数与递归摘要 函数参数: 形参实参, 引用和值,调用堆栈, 标识符作用域, 重载, 模板变量: 存储类别, 作用域, 链接递归与迭代 C++程序组件 C++程序是由预先打包的函数和类及自己编写的函数和类组合而成； C++库有自己的头文件，同时也包含了各种类类型、函数和常量的定义 函数原型 函数原型包括返回值类型, 函数名和参数类型. 函数名和参数类型合并称为函数签名 C++ 的函数参数类型存在基本类型间的隐式转换 可以简单理解为函数声明中除去返回值的部分 随机数与枚举类型Rand()该函数原型包含于&lt;cstdlib&gt;头文件下，如果没有利用srand()更新种子，那么每次的随机数生成结果将完全相同。 Rand()可预测，不具有良好的统计特性. 安全性较弱 C++11提供了&lt;random&gt;随机数库，用配置控制引擎产生的值、值的类型、及统计特性；用引擎实现一套生成伪随机数的算法；1234567#include&lt;random&gt;Int main()//默认的随机数生成引擎和默认的配置&#123; Default_random_engine engine(static_cast&lt;unsigned int&gt;(time(0))); Uniform_int_distribution&lt;unsigned int&gt; randomInt(1,6)//Uniform_int_distribution是一个类模板&#125; Srand()该函数原型包含于&lt;cstdlib&gt;头文件下，通常为srand(static_cast&lt;unsigned int(time(0)))，意为将time()返回的值（从格林尼治时间到当前的秒数）从time_t转换为int类型，并用作随机数种子。实例12srand(static_cast&lt;unsigned int(time(0)))；Number=C+rand()%A;//生成值域为[C,C+A-1]的随机数 枚举类型：关键字enum+枚举类型名+一组由标识符表示的整型常量1enum Status&#123;CONTINUE, WON, LOST&#125;; 默认情况下，枚举类型值从零开始并递增1，整型类型为int；类型名首字母最好大写；枚举常量必须大写；枚举类型名+:+整型类型，制定整型类型； 进阶情况：1enum class Status: unsigned int &#123;CONTINUE=1, WON, LOST&#125;; 作用域限定，可以避免潜在的命名冲突和逻辑错误；设定整型类型，应足够保证保存指定的常量值；引用枚举常量：result==Status:: WON; 存储类别和存储期(入门)存储期 五个类别的标识符： auto extern static register mutable 四种类型: 自动存储期, 静态, 动态, 线程 自动存储期变量(register &amp; auto) 定义在函数内的局部变量 函数形参 register声明的局部变量或函数形参 静态存储期变量(static &amp; extern) 具有静态存储期的变量从程序开始执行到结束, 一直存在于内存中.对于这样的变量, 声明时便对它进行一系列初始化.当然, 存储期和作用域是两回事, 他不意味着在整个程序都能使用标识为static 的局部变量在函数结束后也不会消失, 它会以最后一次的返回值保留 Trick code1234567891011static a= 1;void foo()&#123; static b=1; b++;&#125;;int main()&#123; int a=0; cout&lt;&lt;::a&lt;&lt;a&lt;&lt;endl;//10, 此时的:: 是一元作用域分辨符 foo(); foo();&#125; 寄存器变量(register) register建议将变量放置在计算机的高速硬件寄存器而不是内存中, 对于频繁使用的变量采用register可以有效消除变量-&gt;内存-&gt;寄存器-&gt;内存的开销. 只能与局部变量和函数形参一起使用 理论上不需手动优化, 编译器可以智能识别 作用域标识符在程序中可以被引用的范围 函数作用域仅限于case:一类 1234switch()&#123; case a:&#123;&#125;;break; .....&#125; 语句块作用域最广泛, 作用域为从声明到语句块右大括号. 全局命名空间作用域(global namesapce scope )声明于任何函数和类之外, 对于从声明到文件结束的任何函数都是已知的. 函数原型作用域实际上函数原型的参数不需要标志符, 只需要类型, 所以函数原型作用域的标识符可以在任意处复用. 链接标识符是否只是在声明它的源文件被识别, 或者可以在编译后链接的多文件被识别 函数调用堆栈和活动记录函数调用是一种 LIFO机制, 每层次包含了函数的返回地址和其他信息, 递归调用最能直观体现. 引用和引用形参 Int &amp;count 表示count是对一个int类型对象的引用 按引用传递的形参等价于原有实参的别名，修改按引用传递的形参等于修改对应实参 如果一个函数的形参是按引用传递的：即int &amp; count，很可能会因为引用形参导致对应实参被修改而发生错误！ 函数重载和函数模板(入门) 函数重载：相同函数名，但具有不同的形参集合；通过函数签名区分； 函数模板：12345T maximum(T value1, T value2, Tvalue3)&#123; T maximumValue= value1; //省略中间 return maximumValue; T为参数类型（int、double等） 递归 递归函数是直接或者间接调用自身的函数； 一般分解为两个步骤: 基本情况终结递归, 和简化情况调用递归 内存开销很大 指针这里描述的指针沿袭了C语言风格, 实际运用时需要注意最小特权原则. 默认有一定的C语言基础，基本知识略去 指针变量的声明与初始化 指针变量与间接引用指针变量把内存地址作为它的值. 如果说一个变量名直接引用一个值, 那么一个存有一个变量名内存地址的指针变量就是间接引用这个值. 指针的声明 1234int *ptr, count;// ptr是一个是一个指向int类型数据的指针// count是一个int类型的变量// (*)在这里并不是运算符, 他只是用于表示ptr是一个指针 指针初始化将指针初始化为nullptr是有必要的, 这可以防止它指向一个未知的或者未被初始化的内存空间 指针运算符 地址运算符&amp;地址运算符是一个一元运算符, 它获得操作数的内存地址.1234//取址与赋值int y = 5;int *yptr = nullptr;yptr = &amp;y; 值得一提的是, 这里的&amp;与我们之前在函数中提到的引用变量声明&amp;不同, 简言之:​ 1. 后者的前面必然有一个数据类型名​ 2. 在声明一个引用的时候,&amp;只是类型的一部分 间接运算符*一元运算符*通常被称为简介运算符或者间接引用( dereference)运算符. 它返回一个左值, 表示其指针操作数所指向的对象12345*yptr = 8;cin&gt;&gt; *yptr;cout&lt;&lt; *yptr&lt;&lt;endl;cout&lt;&lt; y &lt;&lt; endl; //两者等价 ### 使用指针的按引用传递方式 真実はいつもひとつ 所有的引用都是传值引用, 无非你传入的是指针的内存地址值, 又或者是变量值. 内置数组 C语言风格, 主要特点是内存连续, 通过下标访问, 大小固定.不建议使用, 可以改用标准库中的 vector 或者array 对于Linux 或者 OS X系统来说, 内置数组有时是必要的.例如使用命令行执行程序时, 需要给程序提供命令行参数, 此时的命令行参数将作为一个具有基于指针的字符串元素的内置数组传递给main函数. 123456//Windows 下常见的main函数声明方式int main(int argc, int *argv[])&#123; /* your code */ return 0;&#125; 使用const修饰指针 指向非const 数据的非const 指针具有最大的访问权限, 指针和数据均可修改 指向const 数据的非const 指针可以修改指针指向, 不可以修改数据.可以在只读函数中大胆使用, 获取数据的高速引用. 指向非const 数据的const 指针 指向const 数据的const 指针 指针表达式和指针算数运算和内置数组 指针赋值只有在已知指针类型的情况下, 编译器才能进行指针赋值. 例如 void*类型指针无法直接被赋值到其他类型指针. 因为编译器需要知道一个指针所指向的字节数和数据类型, 确定该指针间接引用的字节数. 指针比较非同一数组指针的比较毫无意义 指针/偏移量表示法 12345678int b[5];int* bPtr;//b[3]的几种写法*(bPtr + 3)*(b +3)* &amp;b[3]* &amp;(bPtr +3) 请注意, b+= 3 这种写法是错误的, 内置数组名不可修改. 类的深入剖析：抛出异常 头文件的包含防护(include guard) : #pragma once继承和组成概念 类的作用域和类成员的访问成员选择运算符.和-&gt;. 适用于对象或对象引用, -&gt; 适用于对象的指针 const 对象和const 成员函数对于const 对象, C++编译器不允许被除声明为const的成员函数之外的成员函数调用. 很明显我们的构造函数和析构函数无法被声明为const, 况且构造函数和析构函数必然会修改对象. 这里, const的有效性是指对于构造函数和析构函数之间的部分而言 友元函数和友元类友元声明(friend)友元关系是授予的而不是索取的. 如果说B是A的友元, 那么B可以访问A的成员. 对于A来说, A不是B的友元, A无法对B中的成员进行访问. 例如1234567891011class classTwo;class classOne&#123; friend class classTwo; friend void setX();public: classOne(); ~classOne()&#125; static 类数据成员 static 表示”整个类范围”上的信息(即类所有实例共享的性质, 而不是某个特定实例具有的特性) static 数据成员具有类作用域并且可以声明为public, private, protected. static 关键字不能用于类定义之外的成员定义 对于不访问非static数据成员或非static成员函数的成员函数, 应当声明为static. static成员函数没有this指针, 它独立于类的任何对象 没有类对象, 类的static类成员依旧存在, 并且可以用类名+:: 作为前缀直接访问public static类成员 当没有类的对象存在而要访问private的static类成员时，应该提供public static 成员函数；并通过在函数名前加类名和二元作用域分辨运算符的方式来调用此函数]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>dataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Next]]></title>
    <url>%2F2018%2F12%2F16%2FThe%20NexT%2F</url>
    <content type="text"><![CDATA[谨以此文, 纪念一个误入NexT坑的年轻人 一点提示 Tips:hexo s后可以直接本地调试，也就是更改文件保存后，Hexo 后台会自动重新渲染文件，所以只要稍等片刻，浏览器刷新一下就能看到效果。 无序列表圆点不喜欢默认空心圆无序列表，我们换成实心的列表： 主题目录： source/css/_common/components/post/post-expand.styl:1ul li &#123; list-style: disc; &#125; 页面列表：next/source/css/_custom/custom.styl:123ul &#123; list-style-type: disc; // 空心圆，实心圆为 disc&#125; 参考：https://github.com/iissnan/hexo-theme-next/issues/559 主页文章阴影打开\themes/next/source/css/_custom/下的custom.styl, 添加12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 添加顶部加载条打开主题配置文件1234567891011121314151617181920# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: false #点击上述链接, 下载pace. 然后把这个修改为true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 修改网页底部图标还是打开themes/next/layout/_partials/footer.swig，找到：1234&lt;span itemprop=&quot;copyrightYear&quot;&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class=&quot;with-love&quot; id=&quot;animate&quot;&gt; &lt;i class=&quot;fas fa-igloo&quot;&gt;&lt;/i&gt; &lt;/span&gt; 前往FontAwesome获取相应图标并替换 1&lt;i class=&quot;fas fa-igloo&quot;&gt;&lt;/i&gt; 文章加密访问打开themes-&gt;next-&gt;layout-&gt;\_partials-&gt;head-&gt;head.swig文件,在以下位置插入这样一段代码： 1234567891011121314&lt;script&gt; (function () &#123; if (&apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; alert(&apos;密码错误！&apos;); if (history.length === 1) &#123; location.replace(&quot;http://zlee.xyz&quot;); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 萌え萌えlive2d首先安装live2d模块1npm install --save hexo-helper-live2d 然后选择要安装的live2d模型1npm install live2d-widget-model-[填入代号] 在站点/主题配置文件_config.yml中追加1234567891011121314151617181920212223242526272829# Live2D## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-koharu scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 display: superSample: 1 width: 150 height: 300 position: left hOffset: 20 vOffset: 0 mobile: show: true scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 大小方向自行调参, 重新生成即可. 如果生成出现YAML 解析错误, 请检查是否正确采用tab缩进. 设置代码块这是一个很长的故事…….]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Theme</tag>
        <tag>Beautify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure and Algorithm Analysis]]></title>
    <url>%2F2018%2F12%2F13%2FData-Structure-and-Algorithm-Analysis%2F</url>
    <content type="text"><![CDATA[谨以此文, 纪念我没怎么听过的数据结构 线性表线性表是数据元素的非空有限集合 唯一一个“ 开始节点” 唯一一个” 终端节点“ 除开始结点外，集合中的每个数据元素均只有一个直接前驱 除终端结点外，集合中的每个数据元素均只有一个直接后继 顺序表线性表的结点按逻辑次序存放在一组地址连续的存储单元里, 例如数组 loc(ai)=loc(a1)+(i-1)*c 代码实现分析插入算法和删除算法都是O(n) ### 树 定义要点 n个结点组成的有限集合 根结点(root) 其余结点分为m个子树(subtree) x&lt;y, 则Tx在Ty右侧, 称为有序树 基本术语 结点(node)——表示树元素，包括数据项及指向其子树的分支 结点的度(degree)——结点拥有的子树个数 叶子(leaf)——度为0的结点，又称终端结点 孩子(child)——结点子树的根称为该结点的孩子 双亲(parents)——孩子结点的上层结点叫该结点的双亲 兄弟(sibling)——同一双亲的孩子 祖先(ancestor) ——树的根结点 子孙(descendant) ——子树上的所有结点 树的度(degree) ——一棵树中最大的结点度数 结点的层次(level)——根为第一层，它的孩子为第二层…… 树的深度(depth)——树中结点的最大层次数 森林(forest)——m(m&gt;=0)棵互不相交的树的集合 二叉树二叉树的性质 若二叉树的层次从1开始, 则在二叉树的第 i 层最多有2^i+1^ 个结点(i &gt;=1) 深度为k的二叉树最多有 2k-1个结点(k &gt;=1) 任意一颗二叉树, 如果其叶节点数为n~0~, 度为2的节点数为n~2~, 则有 n~0~=n~2~+1 具有 n 个结点的完全二叉树的深度为log~2~(n+1) 向上取整。 定义1 满二叉树(Full Binary Tree)一棵深度为k且有2k –1结点的二叉树称为满二叉树。特点：每一层上的结点数都是最大结点数。 定义2 完全二叉树(Complete Binary Tree)若一棵二叉树只有最下两层上的结点的度数可以小于2，并且最下一层上的结点集中分布在该层左侧连续的若干位置上，则该二叉树称为完全二叉树。 二叉树的存储结构顺序存储和链表式存储 二叉树的先序、中序和后序遍历采用递归确定遍历顺序：对于二叉树任意一个父节点和及其子节点，先序遍历永远是父节点，左子，右子.中序和后序同理 代码实现下面展示了相应的两种方法 递归法 迭代法( 利用栈 ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//操作函数void InitStack(BTreeNode *&amp;T);void PushStack(BTreeNode *&amp;T, BTreeNode *&amp;child);BTreeNode *PopStack(BTreeNode *&amp;T);bool isEmpty(BTreeNode *T);//二叉树节点定义struct BTreeNode&#123; ElemType data; BTreeNode *leftChild; BTreeNode *parent; BTreeNode *rightChild;&#125;;//前序遍历的非递归算法void preOrderTraverse(BTreeNode *T)&#123; BTreeNode *s; //设置预留右子树指针 BTreeNode *p = T; //当前结点指向根结点 InitStack(s); //初始化空栈 PushStack(s, NULL); //压一空指针进栈 while (p != NULL) &#123; cout &lt;&lt; p-&gt;data; //访问当前结点 if (p-&gt;rightChild != NULL) PushStack(s, p-&gt;rightChild); //进入左子树前预留右子树指针在栈中 if (p-&gt;leftChild != NULL) p = p-&gt;leftChild; //进入左子树 else p = PopStack(s); //从栈中弹出相应的右子树 &#125;&#125;//中序遍历void inOrder(BTreeNode *T)&#123; if (T != NULL) &#123; inOrder(T-&gt;leftChild); //中序遍历T的左子树 cout &lt;&lt; T-&gt;data; //访问根结点 inOrder(T-&gt;rightChild); //中序遍历T的右子树 &#125;&#125;//中序遍历的非递归算法void inOrderTraverse(BTreeNode *head)&#123; BTreeNode *s; BTreeNode *p = head; InitStack(s); PushStack(s, NULL); while (p||(!isEmpty(s)) &#123; while (p) &#123; PushStack(s, p); p = p-&gt;leftChild; &#125; if (!isEmpty(s)) &#123; p = PopStack(s); cout &lt;&lt; p-&gt;data; p = p-&gt;rightChild; &#125; &#125; &#125;//后序遍历void postOrder(BTreeNode *T)&#123; if (T != NULL) &#123; postOrder(T-&gt;leftChild); //后序遍历T的左子树 postOrder(T-&gt;rightChild); //后序遍历T的右子树 cout &lt;&lt; T-&gt;data; //访问根结点 &#125;&#125;//post Order Traverse void postOrderTraverse(BTreeNode *head)&#123; BTreeNode *s; BTreeNode *visit; InitStack(s); PushStack(s, NULL); while (head || (!isEmpty(s))) &#123; while (head) &#123; PushStack(s, head); head = head-&gt;leftChild; &#125; head = PopStack(s); //右节点已经访问或者右节点为空的情况下,访问根结点 if (head-&gt;rightChild == NULL || head-&gt;rightChild == visit) &#123; cout &lt;&lt; head-&gt;data; visit = head; head == NULL; &#125;else &#123; //右节点尚未访问时,重新压入栈 PushStack(s,head); //访问右节点 head = head-&gt;rightChild; &#125; &#125;&#125; 参考文章: 二叉树的遍历方法 线索二叉树 由于具有n个结点二叉树中， 共有n+1个指针域空置不用。为此，A.j.Parlis和C.Thornton 提出利用二叉数中这些空的链域来存储结点前驱或后继的地址信息的方法：若某个结点的left指针为空， 则使该left指针指向该结点的前驱结点；若某个结点的right指针为空，则使该right指针指向该结点的后继结点。为了区别两个指针域的含义， 每个结点的存储结构中增加两个布尔型的线索标志字段Lthread 和Rthread。指向前驱结点和后继结点的指针为线索(thread)， 带有线索的二叉树称为线索二叉树(Threaded Binary Tree) 。 中序线索化二叉树的递归算法分析思路 由于线索二叉树首先是二叉树，所以对它的任何算法可以是递归的。 按照中序遍历次序对二叉树进行线索化，对遍历到的每一个结点，先线索化其左子树，再线索化当前结点，最后线索化其右子树。 设置两个结点指针，分别指向遍历过程中的当前结点和它的前驱结点。 当前结点的左线索化和其前驱结点的右线索化同时进行. 若当前结点无左子树，构造其左线索(Lthread= true)及标志，若其前驱无右子树，则构造其前驱的右线索(Rthread= true)及标志。 算法实现123456789101112131415161718192021222324252627282930struct TBTreeNode //线索二叉树类型定义&#123; bool Lthread, Rthread; ElemType data; TBTreeNode *leftChild; TBTreeNode *rightChild;&#125;;void Threaded(TBTreeNode *t, int flag = 0)&#123; static TBTreeNode *prenode; //当前结点t的前驱指针 if (flag == 0) prenode = NULL; // prenode初值为空 if (t != NULL) //t树存在 &#123; Threaded(t-&gt;leftChild, 1); //对左子树线索化 t-&gt;Lthread=t-&gt;leftChild==NULL?true:false;//置左线索标志值 t-&gt;Rthread=t-&gt;rightChild==NULL?true:false;//置右线索标志值 if (prenode != NULL) //当前结点的前驱存在 &#123; if (prenode-&gt;Rthread) prenode-&gt;rightChild = t; //互指 if (t-&gt;Lthread) t-&gt;leftChild = prenode; &#125; prenode = t; //t作为中序遍历后继结点的前驱 Threaded(t-&gt;rightChild, 1); //对右子树线索化 &#125;&#125; 中序线索二叉树的节点插入在p所指结点与它的右子树之间插入q所指新结点，可以分两种情形考虑。 P结点存在右子树：此时将q结点作为p结点的右孩子点，p结点原来的右子树作为q结点的右子树，使q结点作为p结点的后继结点，p结点的原后继结点作为q结点的后继结点（将p结点右线索标志及右孩子指针拷贝到q结点），需对有关结点的线索进行赋值或修正。 P结点不存在右子树：此时无论p结点是其父结点的左孩子或右孩子，将q结点作为p结点的右孩子结点前，将p结点右线索及标志拷贝到q结点即可。 算法实现1234567891011121314void InsertRight(TBTreeNode *p, TBTreeNode *q)&#123; TBTreeNode *s; s = InOrderSuc(p); //s指向结点p的后继 q-&gt;Lthread = true; //置插入结点左线索标志 q-&gt;leftChild = p; //插入点的左线索指向p结点 q-&gt;Rthread = p-&gt;Rthread; //复制p结点的右线索标志 q-&gt;rightChild = p-&gt;rightChild; //复制p结点的右孩子指针 p-&gt;Rthread = false; //置p结点的右线索标志为假 p-&gt;rightChild = q; //p结点的右指针指向新插入q结点 if (s != NULL &amp;&amp; s-&gt;Lthread) //结点p的后继存在且有左线索 s-&gt;leftChild = q; //修正使其指向q&#125; 二叉排序树二叉排序树(Binary Sort Tree)具有以下性质： 二叉排序树可以是棵空树； 若它的左子树非空，则左子树的所有结点的关键字均小于根结点的关键字； 若它的右子树非空，则右子树的所有结点的关键字均大于等于根结点的关键字； 左子树、右子树本身也是二叉排序树。 平衡二叉树(AV树)一棵平衡二叉排序树或者是空树，或者是具有下列性质的二叉排序树： 左子树与右子树的高度之差的绝对值小于等于1 左子树和右子树也是平衡二叉排序树 平衡二叉排序树的平均查找长度为O(log~2~n)平衡因子：结点的左子树深度与右子树深度之差(-1，0，1) 平衡二叉树的调整 L和R的自由排列组合: LR, LL, RL, RR 四种组合没有什么特殊性, 只要注意超出的深度在那个子树上即可. 调整原则: 所有左子树节点关键字均小于其相应的根节点关键字, 右子树的所有结点的关键字均大于等于根结点的关键字. 例如根节点左子树的右子树失去平衡, 就是LR型 偏序树优先队列(Priority queue)中每个元素都有一个优先数，删除时，总是删除优先数最大的元素。实现优先队列的一种有效方法是将优先队列的元素组成完全二叉树，二叉树中任何结点的优先数(关键码)不小于它的子女结点的优先数(关键码)，具有这一性质的完全二叉树称为偏序树(Partially order tree)，又称最大堆。如果完全二叉树中任何结点的优先数(关键码)不大于它的子女结点的优先数(关键码)，则定义为最小堆。 偏序树插入和删除算法流程最大堆调整示例 插入操作 元素放置到队尾( 队尾插入 ) 与父节点比较. 如果大于父节点, 则两者交换, 否则插入完成 重复第2步, 父节点为空时, 插入完成 删除操作 交换根节点和尾节点后, 删除尾节点 调整偏序树: 从根节点作为父节点开始. 如果父节点小于子节点, 将父节点与子节点中最大的一个交换. 父节点设为交换后的子节点, 重复第2步. 如果子节点为空, 或者子节点均小于父节点, 调整完成. 代码实现略 哈夫曼树最小权值 构造哈夫曼树的哈夫曼算法 根据给定的n个权值{w1，w2，…,wn}, 构成n棵二叉树的集合(森林）F={T1,T2,….,Tn },其中每棵二叉树Ti中只有带权为wi的根结点,其左右子树均空。 在F中选取两棵根结点的权值最小的树作为左右子树(左小右大)构造一棵新的二叉树,且置新的二叉树的根结点的权值为其左、右子树根结点的权值之和。 在F中删除这两棵树,同时将新的二叉树加入F中。 重复 2 和 3 , 直到F只含一棵树为止.这棵树便是哈夫曼树。 代码实现略 图 图的定义图是由顶点集合(vertex)及顶点间的关系集合组成的一种数据结构：$$G＝( V, E )$$其中 V = { x | x ∈ 某个数据对象}是顶点的有穷非空集合}；无向图: $$E = {(x, y) | x, y ∈ V }$$或有向图: $$E = {&lt;x, y&gt; | x, y ∈ V, Path (x, y)}$$顶点之间关系的有穷集合(可以为空)，也叫做边(edge)集合。$$Path (x, y)$$表示从 x 到 y 的一条单向通路, 它是有方向的。 有向图(directed graph) 有向图(Directed graph)G是由两个集合 V(G)和E(G)组成。 其中：V(G)是顶点的非空有限集，E(G)是有向边(也称弧)的有限集合，弧是顶点的有序对，记为&lt;v,w&gt;， v为弧的起点，w为弧头的终点, 注意&lt;v,w&gt;≠&lt;w,v&gt;。 无向图(undirected graph) 无向图(Undirected graph)G是由两个集合V(G)和E(G)组成 完全图 n个顶点的无向图拥有n(n-1)/2个节点, 即为完全图 排序 对由n个记录组成的表(或文件)L=(r1,r2,…….,rn)，依据记录中某个数据项的值重新进行排列的过程称之为排序（sorting），该数据项称为排序码，一般情况下， 总是选择记录的关键码(字)作为排序码。 如果待排序的表中含有多个排序码值相等的记录，用某种排序方法排序后，这些记录的相对次序不变，则说这种排序方法为稳定的（stable），否则是不稳定的。 按照待排序数据驻留的介质不同排序问题可分为内部排序(Internal sorting)和外部排序(External sorting)两类： 内排序: 待排序的表中记录可存放内存，整个排序过程都在内存进行，只涉及对内存的访问。 外排序: 待排序的表中含有巨量记录，无法存放到内存，整个排序过程都在外存进行，涉及对外存的访问。 按照排序的依据原则内部排序可分为：插入排序、交换排序、选择排序、归并排序和分配排序等五类。 插入排序顾名思义最好的情况是已经排好序:O(n), 最坏的情况是:O(n*n)该排序是稳定排序 请注意, 插入排序有大量的插入操作, 使用链表较为适宜 算法思路循环将数插入到已经排序的序列中, 知道未排序数组为空 算法实现123456789101112131415161718192021222324252627const long LMAX = 10; //顺序表最大长度struct rectype //记录类型定义&#123; keytype key;&#125;;struct SqList //顺序表类型定义&#123; unsigned long length; rectype r[LMAX];&#125;;void InsertSort(SqList &amp;L) //直接插入排序&#123; for (int i = 2; i &lt;= L.length; i++) &#123; L.r[0] = L.r[i]; //将第i个记录复制到L.r[0]中 int j = i - 1; //依次后移 while (L.r[0].key &lt; L.r[j].key) &#123; L.r[j + 1] = L.r[j]; j = j - 1; &#125; //插入待排序数 L.r[j + 1] = L.r[0]; &#125;&#125; 冒泡排序复杂度为O(n*n), 如果已经有序, 则 复杂度为O(0)该排序是稳定排序 算法思路对于具有n个元素的数组, 进行n-1 次遍历第 k 次遍历过程, 如果发现某元素小于元素[k-1], 交换两者.最终实现: 最小的数放在队头, 第二小的数放在第二个…….. 排序完成 希尔排序又叫递减增量排序 希尔排序听起来总让我想起崩坏学园所以我钦点了希尔 · 爱乐芙 作为本篇博文置顶图23333 希尔排序的性能大约为:O(n^3/2^), 这主要是因为他的递减增量希尔排序是不稳定的 算法思路 取某一增量d; 将数列按照增量d 分成若干组; 对若干组进行插入排序 降低增量d, 重复1, 2步骤直到d为1; 算法实现12345678910111213141516171819202122void shellSort(SqList &amp;L)&#123; int increment = L.length; do &#123; increment /= 2 //执行插入排序 for (int i = increment; i &lt; L.length; i++) &#123; rectype extra = L.r[i]; int j = i - increment; while (j &gt;= 0 &amp;&amp; (extra.key &lt; L.r[j].key)) &#123; L.r[j + increment] = L.r[j]; j = j - increment; &#125; L.r[j + increment] = extra; &#125; &#125; while (increment &gt; 1);&#125; 快速排序快速排序(Quick sort) 的基本思想是选取被排序表中某个关键码作为基准(pivot)，将表划分成左右两个子表： 左子表中各记录的关键码均小于或等于基准值，而右子表中各记录的关键码均大于或等于基准值。然后以同样的方法递归地处理这两个子表，直到完成全部记录的排序。该排序是不稳定排序 复杂度分析对含有n个记录的表，若算法总是以子表中间记录的关键码作为基准划分,最坏的情况(基准为最小或最大)是每次将将表分为含1个记录的子表和含n-1个记录的子表。需划分n次，比较次数为：n*(n-1)/2=O(n^2^) 若总是以子表的第一个记录的关键码作为基准划分, 当被排序的表是按关键码有序或逆序，将出现最坏的情况。设c(n)为用QuickSort算法对含有n个记录的表进行排序所作的比较次数, s(n)为交换次数，显然c(1)=0和s(1)=0。 算法将n个记录的表划分为r记录和n-r记录两个子表需比较n次。所以​ c(n)=n+c(r)+c(n-r)对于最坏情形:每次划分时r=1, n-r=n-1, 则有:​ c(n)=n+c(1)+c(n-1)=n+c(n-1)于是下列诸式成立:​ c(1)=0​ c(2)=2+c(1)=2​ c(3)=3+c(2)=3+2=5​ c(4)=4+c(3)=4+3+2=9​ ……..​ c(n)=n+c(n-1)=n+(n-1)+(n-2)+….+3+2=(n+2)(n-1)/2​ =(n2+n-2)/2=O(n2) 若 QuickSort 算法总是以表中关键码的中值作为基准划分,将出现最好的情况：每次将表分为两个长度大致相等的子表。​ c(n)≤n+2c(n/2)​ ≤n+2[n/2+2c(n/22)]=2n+4c(n/22)​ ≤2n+4[n/4+2c(n/23)]=3n+8c(n/23)​ ≤……..​ ≤kn+2kc(n/2k)=nlog2n+nc(1)=O(nlog2n)​ (这里：k=log2n )对于交换次数, 有$$ s(n)&lt;=O(nlog_2n) $$ 快速排序是不稳定的 算法实现12345678910111213141516171819202122232425262728293031void Qsort(int a[], int low, int high)&#123; if(low &gt;= high) &#123; return; &#125; int first = low; int last = high; int key = a[first];/*用字表的第一个记录作为枢轴*/ while(first &lt; last) &#123; while(first &lt; last &amp;&amp; a[last] &gt;= key) &#123; --last; &#125; a[first] = a[last];/*将比第一个小的移到低端*/ while(first &lt; last &amp;&amp; a[first] &lt;= key) &#123; ++first; &#125; a[last] = a[first]; /*将比第一个大的移到高端*/ &#125; a[first] = key;/*枢轴记录到位*/ Qsort(a, low, first-1); Qsort(a, first+1, high);&#125; 归并排序归并排序（merge sort）是归并操作上的一种有效的排序算法归并排序每次都是在相邻的数据中进行操作，在O(N*logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。 设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。 算法思路对于整体无序的数列 递归(recursion)分割数列为左右两部分, 直至数列不可再分 对当前不可再分的左右数列进行归并 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;//归并排序void merge(int arr[], int front, int mid, int rear, int temp[]) &#123; int i = front, j = mid + 1, k = 0; while (i &lt;= mid &amp;&amp; j &lt;= rear) &#123; if (arr[i] &lt; arr[j]) &#123; temp[k++] = arr[j++]; &#125; else &#123; temp[k++] = arr[i++]; &#125; &#125; while (i &lt;= mid) &#123; temp[k++] = arr[i++]; &#125; while (j &lt;= rear) &#123; temp[k++] = arr[j++]; &#125; for (int i = 0; i &lt; k; i++) &#123; arr[front + i] = temp[i]; &#125;&#125;void recursive(int arr[],int front, int rear, int temp[]) &#123; if (front&lt;rear) &#123; int mid = (front + rear) / 2; recursive(arr, front, mid, temp); recursive(arr, mid + 1, rear, temp); merge(arr, front, mid, rear, temp); &#125;&#125;bool mergeSort(int arr[], int n) &#123; //辅助表空间, 避免数列数组被覆写, 省去临时声明空间的时间开销 int* temp = new int [n]; if (temp == NULL) &#123; return false; &#125; recursive(arr, 0, n - 1, temp); delete[] temp; return true;&#125;int main() &#123; int arr[8] = &#123; 12,12,123,45,654,78,96,2 &#125;; mergeSort(arr, 8); for (size_t i = 0; i &lt; 8; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot;\t&quot;; &#125; system(&quot;pause&quot;);&#125; 堆排序堆排序是利用堆这种数据结构而设计的一种排序算法，它是一种选择排序.它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序. 算法思路 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;void swap(int arr[], int front, int rear) &#123; int tmp = arr[front]; arr[front] = arr[rear]; arr[rear] = tmp;&#125;void adjustHeap(int arr[], int i, int len) &#123; int temp = arr[i]; for (int k = i * 2 + 1; k &lt; len; k = k * 2 + 1) &#123; if ((k + 1) &lt; len&amp;&amp;arr[k] &lt; arr[k + 1]) &#123; k++; &#125; if (arr[k] &gt; temp) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; arr[i] = temp;&#125;void sort(int arr[], int len) &#123; //1. 构建大顶堆 for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(arr, i, len); &#125; //2. 交换堆顶元素和末尾元素, 调整堆 for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); adjustHeap(arr, 0, i); &#125;&#125;int main() &#123; int arr[8] = &#123; 1,2,45,65,78,98,45,32 &#125;; sort(arr, 8); for (int i = 0; i &lt; 8; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot;\t&quot;; &#125; system(&quot;pause&quot;);&#125; 基数排序基数排序 (radix sort) 属于”分配式排序” (distribution sort) , 重点在于对关键字进行 “分配” 和 “收集” , 而不是对关键字的比较.基数排序算法是稳定的, 时间复杂度是O(d*(n＋r)) 将表中n个记录分配到r个队列中去的时间为O(n), 收集时将r个队列连成一个表的时间O(r), 一次分配和收集的时间为O(n＋r), 由于算法对n个记录共进行了d遍分配和收集,所以共花费的时间为O(d*(n＋r)). 算法思路 将关键码按照位数最小/最大值分配入箱 按照箱子的顺序收集关键码 重复1，2步骤直到位数到达最大/最小值 代码实现最高位优先(Most Significant Digit first)，简称MSD最低位优先(Least Significant Digit first)，简称LSD下面采用LSD法，值得一提的是，这种实现比较耗费内存, 从理论上来说, 申请的数组空间利用率只有10%.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;/*顺序数组实现*/using namespace std;const int RADIX = 10;//桶数const int Max = 10;//桶容量int getDigit(int src, int pos) &#123; int temp = 1; for (int i = 0; i &lt; pos - 1; ++i) &#123; temp *= 10; &#125; return (src / temp) % 10;&#125;void radixSort_Array(int *src, int digits) &#123; int* tempArray[RADIX];//定义桶数 RADIX for (int i = 0; i &lt; RADIX; ++i)//定义桶容量 &#123; tempArray[i] = new int [Max + 1]; tempArray[i][0] = 0;//初始化为0 &#125; for (int pos = 1; pos &lt;= digits; ++pos) &#123; int tmp; for (int i = 0; i &lt; Max; ++i)//分配进桶 &#123; tmp = getDigit(src[i], pos);//获取指定位的数字 ++tempArray[tmp][0]; tempArray[tmp][tempArray[tmp][0]] = src[i]; &#125; int index = 0; for (int i = 0;i&lt;RADIX; ++i)//收集 &#123; for (int j = 1; j &lt;=tempArray[i][0]; ++j ) &#123; src[index++] = tempArray[i][j]; &#125; tempArray[i][0] = 0;//重置 &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; Max; i++) &#123; cout &lt;&lt; src[i] &lt;&lt; &quot;\t&quot;; &#125; &#125;&#125;int main() &#123; int src[Max] = &#123; 12,123,123,14,56,78,56,12,456,789 &#125;; /*std::cout &lt;&lt; &quot;最大三位数&quot; &lt;&lt; std::endl; for (RADIX_t i = 0; i &lt; Max; i++) &#123; std::cin &gt;&gt; src[i]; cout &lt;&lt; endl; &#125;*/ for (int i = 0; i &lt; Max; i++) &#123; cout &lt;&lt; src[i] &lt;&lt; &quot;\t&quot;; &#125; radixSort_Array(src, 3); cout &lt;&lt; endl; for (int i = 0; i &lt; Max; i++) &#123; cout &lt;&lt; src[i]&lt;&lt;&quot;\t&quot;; &#125; system(&quot;pause&quot;);&#125; 查找算法查找操作的性能主要考虑时间复杂度, 整个查找过程主要是在关键字和查找表的数据上. 即平均查找长度.平均查找长度ASL(Average Search Length)：为确定记录在表中的位置，需和给定值进行比较的记录个数的期望值叫查找算法的平均查找长度。 $$ ASL=\sum_{n}^{i=1}p_{i}c_{i} ​$$ 顺序查找 对于每次查找均成功的情况下$$ ASL=\frac{n+1}{2}$$ 二分查找性能分析通过建立一个二叉查找树, 我们能很清晰的看到$$ ASL=log~2~(n+1)-1 分块查找分块查找，也叫索引顺序查找，算法实现除了需要查找表本身之外，还需要根据查找表建立一个索引表建立的索引表要求按照关键字进行升序排序，查找表要么整体有序，要么分块有序 分块有序指的是第二个子表中所有关键字都要大于第一个子表中的最大关键字，第三个子表的所有关键字都要大于第二个子表中的最大关键字，依次类推。 性能分析分块查找分为两个过程: 查找快可以采用顺序查找, 也可以采用折半查找 块内查找采用顺序查找 总体而言, 分块查找效率介于顺序查找和折半查找之间]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>ADT</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tutorial For Hexo]]></title>
    <url>%2F2018%2F12%2F12%2FSimple-Tutorial-For-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。Hexo同时也是GitHub上的开源项目，如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，你可以查阅到优质的中文文档. Hexo基础基于Github pages 的静态博客所必须的步骤 GitHubGitHub提供了一个免费账户, 这对于我们来说可以很方便的搭建静态博客, 当然, 这也是本篇的目标. 登录到GitHub, 如果没有GitHub帐号，使用你的邮箱注册GitHub帐号. 点击GitHub中的New repository创建新仓库，仓库名应该为： 1用户名.github.io 用户名请使用你的GitHub帐号名称代替. 这是固定写法，比如我的仓库名为:1magnesium12.github.io 安装Git&amp;Node.js在安装前，你必须检查电脑中是否已安装下列应用程序： Node.js Git Windows 用户 如果你的电脑中尚未安装所需要的程序，请到官网下载Node.js &amp; Git的安装程序进行安装.注意安装Node.js时注意勾选Add to PATH选项, 这将使得Node.js添加到你的计算机环境变量中.Git安装完成后，右键菜单会出现git bash, 我们所有的命令都需要在git bash中执行,. 下载Git可能会有些慢, 请耐心等待或者自行寻找过其他源. 配置SSH免密访问 本地安装 Git 我本地是Windows，采用 git-bash. 如果你是新手的话, 在安装过程中只要一路next就OK 配置本地免密ssh远程登陆 在本地写作的机器上，搜索Git Bash，设置user.name和user.email配置信息：12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 一路回车，~/.ssh/目录下会生成 id_rsa 和 id_rsa.pub 两个文件。 打开GitHub_Settings_keys 页面，新建new SSH Key Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key.在Git Bash中检测GitHub公钥设置是否成功，输入1​ssh git@github.com 如果是第一次链接的话, 可能会询问是否创建known_hosts文件, 这当然是yes 建站如果你的电脑中已经安装上述必备程序，那么恭喜你！接下来只需使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli Hexo安装完成后, 输入以下命令并执行 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 请注意, &lt;folder&gt;是你指定的文件夹路径, 并且该文件夹必须为空. &lt;`&gt;`是特殊字符, 命令端输入时应当去除, 例如 123hexo init /d/Project/Hexocd /d/Project/Hexonpm install 或者直接打开Hexo文件夹, 右键git bash, 输入1hexo init 如果你看到1INFO Start blogging with Hexo!` 这意味着本地建站已完成, congratulations!你已经到达新手村. 站点结构新建完成后, 本地hexo站点结构如下 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的配置信息, 你可以在这里选择配置大部分参数, 我们称为站点配置文件. 可以设定主题, 网站标题, 副标题, author etc. 详情请阅读.md文档 package.json应用程序的信息. scaffolds模板文件夹, Hexo会根据scaffolds来建立文件. Hexo的模板是指在新建的markdown文件中默认填充的内容. 例如, 如果您修改scaffold/post.md中的Front-matter内容, 那么每次新建一篇文章时都会包含这个修改. source资源文件夹是存放用户资源的地方. 除_posts 文件夹之外, 开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略. Markdown 和 HTML 文件会被解析并放到 public 文件夹, 而其他文件会被拷贝过去. 发布的博文存储在/public/ theme主题 文件夹。Hexo 会根据主题来生成静态页面 存在默认主题, 但还是请选择一个你喜欢的主题, it does matter. 主题文件夹内会有_config.yml配置文件, 我们称为主题配置文件 Hexo常用指令**请注意, 这些操作必须在../hexo/目录下进行 init1$ hexo init [folder] 新建一个网站。如果没有设置 folder , Hexo 默认在目前的文件夹建立网站. new12$ hexo new [layout] &lt;title&gt;$ hexo n &quot;article&quot; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate12$ hexo generate$ hexo g 生成静态文件 deploy12$ hexo deploy $ hexo d 文件生成后立即部署网站 generate12$ hexo gengerate$ hexo g server12$ hexo server$ hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/ . 如果需要修改, 1$ hexo sever -p 5000 #更改端口至5000 clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后）, 如果发现您对站点的更改无论如何也不生效, 您可能需要运行该命令. 发布网站如果你已经迫不及待地打开在hexo 目录下打开Git bash 12hexo ghexo s 在http://localhost:4000 你将预览到自己的博客, 但是别人是看不到的, 毕竟一般情况下别人不能看到你的计算机的本地内容. Github pages可以帮助我们解决这个问题. 下一步把GitHub和我们的Hexo关联起来, 打开站点的_config.yml, 找到 1234deploy: type: repo: branch: 修改如下: 12345deploy: type: git #创建仓库的完整路径, 末尾记得加.git repo: https://github.com/Magnesium12/magnesium12.github.io.git branch: master 其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件, 输入命令: 1npm install hexo-deployer-git --save 现在我们输入: 123hexo cleanhexo ghexo d 在浏览器中输入: xxxx. github.io 你会发现这时你的博客已经上线, Congratulations! Now. Sharing the fantasy of your own to the world. Hexo进阶NexT相关注意到6.x版本next仓库的变动, 需要下载最新版本的同学请选择 12cd hexogit clone https://github.com/theme-next/hexo-theme-next themes/next 之后跟进更新 12cd theme/nextgit pull 如果是从v5.x升级到v6.x, 请另行参阅这篇文档 主题配置 打开_config.yml 文件 阅读 README.md 依照字面意思来配置 常见问题眼睛不需要的话, 可以捐给其他人. by 鲁迅 .swig1Unhandled rejection Error: ENOENT: no such file or directory, open &apos;D:\Project\Hexo\themes\next\layout\_scripts\schemes\.swig&apos; NexT使用版本: 5.1.4原因：social加入链接时, #social: 这一行没有把注释打开….. 怎么写博客 请bing一下markdown. 此外, 推荐VS Code作为你的博客项目管理工具. 推荐Typora作为你写markdown的书写工具. 语言设定请修改站点文件, zh-CN意味着站点语言默认为中文1language: zh-CN 标签&amp;分类进入hexo文件夹1hexo new page &quot;tags&quot; 注意已生成source/tags/index.md, index.md中修改如下12345---title: categoriesdate: 2016-11-15 19:11:13type: &quot;tags&quot;--- 当你试图为你的文章添加标签时, 请在文章头部添加12345---title: 基于Hexo和Github搭建博客date: 2018-12-14tags: [npm, hexo, github]--- categories 分类 如上 hexo d 出错12$ hexo d ERROR Deployer not found: git 解决方案: 最新的hexo版本，必须执行1npm install --save hexo-deployer-git]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫（三）：从JSON解决Ajax]]></title>
    <url>%2F2018%2F12%2F07%2FPython%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%88%AC%E5%8F%96js%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[上一篇博文中, 笔者采用了selenium驱动chrome来抓取网页, 总结来看及其低效….. 想了一下, 不能这样搞, 他要刷新局部界面肯定是要利用JavaScript调用已经写好的json的. 通常来说不会有前端选择瞎搞地址. 如果能观察出那个json的地址特点, 就到了ButifulSoup为所欲为的时间辣(●’◡’●) 对于json参数偏移量不规律的网页,那当然是 直接打死 ,哦不, 仔细观察. 对于一个正常的前端同学来说, 不规律的json只可能是有限的, 我不做人啦,jojo!. 我们只要把有限的偏移量写成一个字典(dic)就大功告成 前期准备 Chrome浏览器 Python3.7 requests, BeautifulSoup4模块 一点点耐心以及正常的视力 流程分析 chrome浏览器打开目标网页, 检查元素 F12, CTRL+ shift+i, CTRL+shift+c爱用那个用哪个 继续加载内容，注意观察network栏下的xhr文件 很明显，那个since=就是我们要找的*点击展开，根据 Query string 构造parameter参数字典 requests 负责请求，bs4 为所欲为 代码实现12345678910111213141516171819202122json_url = 'https://富强民主文明和谐'#无规则偏移量，自行逆向分析得到偏移量字典since_list = [26961.554, 26961.474, 26961.419, 26961.346]#实现提取json，加载动态内容，但是封装性不好，不能重复利用def getMorePages(list,count=1): params_list = [] for i in range(count): keyword=str(list[i]) params_list.append(&#123; 'since': keyword, 'grid_type': 'flow', 'sort': 'hot', 'tag_id': '399', &#125;) url = json_url for i in params_list: req=requests.get(url, params=i).content soup=BeautifulSoup(req,'lxml') getURL(soup) 尾声很显然，这样做效率会高很多 发现json规律成为了木桶的最短板，为了避免那个网站被薅羊毛，我就手动屏蔽惹OTZ……另外，代码只放入了相关的一部分，有兴趣的同学可以尝试结合上一篇，整合功能鸭~Good night！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A LETTER]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%AD%8C%E6%9B%B2%E6%8E%A8%E8%8D%90The-Song-For-You%2F</url>
    <content type="text"><![CDATA[You don’t have to throw your life away 本来也不想写文字，但是不写一点文字,又怎么知道当时所思所想是什么，自己又是为什么要去写这篇博文呢? …… A LETTER 是由泽野弘之创作的插曲——也许提及高达UC会让他更容易被想起. 歌姬Cyua确实很适合去唱这首歌, 她的声线与舒缓空旷的乐音彼此交融, 编织出这首弥漫着伤感, 空灵以及希望的歌曲. 倘若你愿意闭上双眸, 浮现出的场景大概会是独角兽在孤独地进行着只属于自己的宇宙漫途, 但或许你需要知道的是, 这首歌曲更多在表达的是对自己的鼓励和对未来的希冀. 每个人都是宇宙中的独角兽, 命运指定的航线终将我们彼此分离, 忙碌追赶又有什么意义呢？命运的轨迹充满了错误, 等待我们的会是痛苦, 遗憾, 还是……希望? 指向正确的道路或许很艰辛, 可是总有一天能够到达尽头. Now you see light in pain.]]></content>
      <categories>
        <category>Thought</category>
      </categories>
      <tags>
        <tag>unknown</tag>
        <tag>recommend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫（二）：Selenium + ChromeDriver 解决异步加载]]></title>
    <url>%2F2018%2F12%2F01%2FPython%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASelenium%20%2B%20ChromeDriver%20%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在上一篇博文中, python代码趋向于平铺直叙——或者说代码习惯十分不好, 稍微复杂点的功能都会举步维艰 对于选择使用js控制加载网页结构的网站, 以urllib为基础的python库来说无法直接解决这个问题，例如爬取下拉刷新的网页：”https://bcy.net/coser&quot; 但是事在人为, 对于笔者这个小白来说还是有傻瓜式替代解决思路的, 虽然很慢== 前期准备 默认看过Python爬虫（一）：Requests&amp;BS4 爬虫实例 预装模块: requests, selenium, bs4, os 下载chromedriver 流程分析 bs4+selenium+chromedriver 强行爆破 模拟点击行为获取完全加载的html 然后用beautifulsoup为所欲为代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# coding=utf-8# **************************Declaration**************************# @File name: Crawler# @Function: requests+selenium+chromedriver# @Author: Ogiso Kazusa# @Date: 2018/11/15# @Version Number: 2.0# ******************************end******************************import requestsimport osfrom bs4 import BeautifulSoupfrom selenium import webdriver#常量URL = 'https://bcy.net'index_url = 'https://bcy.net/coser'CachePath = "D:\\CrawlerCache\\"#储存CN的键值对, 用于isInDic()dic=&#123;'test':0&#125;#检查字典, 判断是否下载过def isInDic(src): if src in dic: dic[src] = dic[src] + 1 else: dic[src] = 0 dst = src + "_" + str(dic[src]) return dstdef mkdir(path): # 去除首位空格 path = path.strip() # 去除尾部 \ 符号 path = path.rstrip("\\") # 判断路径是否存在 # 存在 True # 不存在 False isExists = os.path.exists(path) # 判断结果 if not isExists: # 如果不存在则创建目录 # 创建目录操作函数 os.makedirs(path) print(path + ' 创建成功') return True else: # 如果目录存在则不创建，并提示目录已存在 print(path + ' 目录已存在') return False# 实现图片下载功能def downloadImg(url, name): # 请求url页面内容,此时页面为图床页面,只有图片内容 url = requests.get(url) # 格式和下载位置 path = CachePath + name + ".jpg" # 迭代器和生成器,实现下载 with open(path, 'wb') as f: f.write(url.content) f.close()#驱动chrome,获取加载完全的html#木桶效应的最短板, 也是本次解决方案的致命点def getJsHtml(URL, cosImg): driver = webdriver.Chrome() driver.get(URL) html = driver.page_source driver.close() soup = BeautifulSoup(html, 'lxml') content = soup.find_all('div', &#123;"class": "img-wrap-inner"&#125;) i = 1 for element in content: src = element.find('img')['src'] name=cosImg + '_' + str(i) downloadImg(src, name) print("下载进度：",i) i = i + 1# 确定存储目录CachePath,没有则生成mkdir(CachePath)# 请求页面内容session = requests.get(index_url) # 获取requests 对象的内容，建议使用content，requests会尝试提供字节数soup = BeautifulSoup(session.content, "lxml") # find 直接返回值, findall 返回列表(list)index = soup.find_all('a', &#123;'class': "db posr ovf"&#125;)for element in index: # print(element)可以看到 # 利用标签的父子关系，能够选择标签或者子标签中的属性值 # 我们获取cos发布地址 img_url = element['href'] url = URL + img_url # CN = element.get('title')貌似两种写法均可 CN = element['title'] print('准备下载：' + CN) CN = isInDic(CN) getJsHtml(url, CN)#大功告成#可以考虑指定需要获取的json？ 尾声 吐槽一下, 这玩意儿奇慢无比, 调用浏览器中出现了大量不必要的步骤== 另一种意义上的模拟人类点击机制, 慢也有点用?,效率实在太低 令人头皮发麻，]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>crawler</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫（一）:Requests&BS4 爬虫实例]]></title>
    <url>%2F2018%2F12%2F01%2FPython%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARequests%26BS4%20%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[这篇文章主要是方便入门爬虫的同学获得入门的正反馈，配合代码注释可能轻松愉悦的对爬虫有个大概了解~ 我们选择对于使用静态网页的小说网站, 小说的文本内容往往分配在一个&lt;div里, 逻辑比较简单. 那就开始吧＜（＾－＾）＞ 前期准备 安装python3.7 安装requests, BeautifulSoup4(或者说bs4) 安装chrome浏览器 掌握Python基础语法 可以尝试 菜鸟教程-Python 3 教程 流程分析 请求URL指向的页面-&gt;获取网页内容 设定筛选条件-&gt;获取指定内容 写入本地文件 检查网站代码 ctrl +shift +c, 检查网页源代码[^3], 得知章节地址F12, ctrl+shift+i , 右键-检查, 等等均可 [^3]:本教程仅供参考, 保护创作者版权, 提倡付费阅读 根据章节地址跳转页面 检查章节页面, 得知章节文本内容 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# coding=utf-8# *********************Declaration*********************# @File name: WebCrawler# @Function: Download Single Novel# @Author: Ogiso Kazusa # @Date: 2018/11/14 # @Version Number: 1.0 # *************************end*************************#导入模块import requestsfrom bs4 import BeautifulSoup#小说网页目录地址, 准备遍历全部章节地址index_url='https://www.88dush.com/xiaoshuo/27/27584/'#获取页面内容index_req=requests.get(index_url)index_html=index_req.contentpage_main=BeautifulSoup(index_html,"lxml")#创建D盘根目录文件“单本下载.txt”，#格式为ab+:向二进制文件末添加数据，且允许读；fo=open("D:\\单本下载.txt","ab+")#获取div , class="mulu" 包含的内容chap_BS=page_main.find("div",&#123;"class":"mulu"&#125;)#生成器对象for child in chap_BS.ul.children: if child!="\n": #href：目标url的属性名 chap_url=index_url+child.a.get("href") #素质三联，获取lxml文档 chap_req=requests.get(chap_url) chap_html=chap_req.content.decode("gbk") soup_text=BeautifulSoup(chap_html,"lxml") #寻找div段落，class=yd_text2的属性块内容 chap_text=soup_text.find("div"，&#123;"class":"yd_text2"&#125;) #.text指获取文字内容，\r\n是指写入文件中的换行符, == fo.write((child.string+ "\r\n"+chap_text.text+"\r\n").encode('utf-8')) print(child.string+'\t已下载') fo.close() 最后Enjoy it !]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Whisper To The World]]></title>
    <url>%2F2018%2F12%2F01%2FA-Whisper-To-The-World%2F</url>
    <content type="text"><![CDATA[NieR:Automata Everything that lives is designed to end.一切活着的事物，都注定要终结。We are perpetually trapped …我们被永远地囚禁……… in a never-ending spiral of life and death.……于永无止境的生死轮回之中。Is this a curse?这是一种诅咒？Or some kind of punishment?还是某种惩罚？I often think about the god who blessed us with this cryptic puzzle …我时常想起那用模糊的谜团祝福我们的神……… and wonder if we’ll ever have the chance to kill him.……并猜想我们是否终有弑神的机会。]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
      <tags>
        <tag>Nier:Automata</tag>
        <tag>sigh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
  </entry>
</search>
