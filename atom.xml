<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>12TH`s Cabin</title>
  
  <subtitle>Who will fall in love with ordinary?</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zlee.xyz/"/>
  <updated>2019-05-16T11:36:30.725Z</updated>
  <id>https://zlee.xyz/</id>
  
  <author>
    <name>Kevin Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pipenv</title>
    <link href="https://zlee.xyz/2019/05/16/Pipenv/"/>
    <id>https://zlee.xyz/2019/05/16/Pipenv/</id>
    <published>2019-05-16T08:52:15.000Z</published>
    <updated>2019-05-16T11:36:30.725Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/05/15/5cdc36069cce451865.jpg" alt="pipenv.jpg"></p><a id="more"></a><h2 id="Pipenv"><a href="#Pipenv" class="headerlink" title="Pipenv"></a>Pipenv</h2><ul><li>一个独立且完整的 python 虚拟环境管理</li><li>提供基于独立环境的独立 python 项目管理方法</li><li>可以帮助我们摆脱多个项目的依赖库相互排斥的问题</li></ul><h3 id="为什么选择Pipenv"><a href="#为什么选择Pipenv" class="headerlink" title="为什么选择Pipenv"></a>为什么选择Pipenv</h3><ol><li>python 社区主流推荐</li><li>自动记录第三方库依赖</li><li>采用哈希校验，包管理操作更加安全</li><li>可以根据 pipfile 和 pipfile.lock 快速创建配置虚拟环境</li></ol><h2 id="Let-s-go-ahead"><a href="#Let-s-go-ahead" class="headerlink" title="Let`s go ahead"></a>Let`s go ahead</h2><p>请注意，本篇文章默认操作系统为 <strong>Windows</strong>，python 版本为 <strong>python 3.7</strong></p><h3 id="安装pipenv"><a href="#安装pipenv" class="headerlink" title="安装pipenv"></a>安装pipenv</h3><p>确保你的电脑正确安装了 python3 和 pip3</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 下安装方式</span></span><br><span class="line">pip install pipenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时存在 py2 和 py3</span></span><br><span class="line">pip3 install pipenv</span><br></pre></td></tr></table></figure></div><h3 id="创建并激活env"><a href="#创建并激活env" class="headerlink" title="创建并激活env"></a>创建并激活env</h3><p>假设我们当前的资源管理器路径是 <code>D:\\project</code> ，</p><p>我们需要在project文件夹下创建一个 Django 文件夹，</p><p>然后在其中创建项目的虚拟环境</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line">mkdir django</span><br><span class="line">cd django</span><br><span class="line">pipenv --python <span class="number">3.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看相关信息</span></span><br><span class="line">pipenv --where</span><br><span class="line">pipenv --venv</span><br><span class="line">pipenv --py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活</span></span><br><span class="line">pipenv shell</span><br></pre></td></tr></table></figure></div><h3 id="激活状态操作"><a href="#激活状态操作" class="headerlink" title="激活状态操作"></a>激活状态操作</h3><p>激活状态下操作主要是包管理和 .py 文件执行</p><p>建议多使用 <code>pipenv --help</code> 命令</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以为什么不用 pycharm 呢，<del>JB快点给我五毛广告费</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/15/5cdc36069cce451865.jpg&quot; alt=&quot;pipenv.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://zlee.xyz/categories/Python/"/>
    
    
      <category term="Python" scheme="https://zlee.xyz/tags/Python/"/>
    
      <category term="Turtorial" scheme="https://zlee.xyz/tags/Turtorial/"/>
    
  </entry>
  
  <entry>
    <title>Nothing Matters</title>
    <link href="https://zlee.xyz/2019/01/26/Nothing-Matters/"/>
    <id>https://zlee.xyz/2019/01/26/Nothing-Matters/</id>
    <published>2019-01-26T10:26:01.000Z</published>
    <updated>2019-05-16T09:00:14.181Z</updated>
    
    <content type="html"><![CDATA[<p></p><p blockquote="" class="centerquote"><i>Weather the God knows how to padding the void of human`s heart ?</i></p><a id="more"></a><p>It`s nature of human beings to be irritable, jealous, weak and greedy. </p><p>I hold the belief that life is the never ending battle to confront with them.</p><p>So that, to be a beast, a man or sth else,  mostly would rely on your own . </p><p>Merely I would get offended with no obvious reason, making my friend/family feel  confused,  even be hurt.</p><p>However, I trust it that you would be with me once you in such a moment which every one is consuming your patience by repeating something inessential again and again. </p><p>If I were irritable at one time, the reason is nothing but</p><p><strong>the surrounding stupid people.</strong></p><p>$Kevin Lee​$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p blockquote=&quot;&quot; class=&quot;centerquote&quot;&gt;&lt;i&gt;Weather the God knows how to padding the void of human`s heart ?&lt;/i&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Thoughts" scheme="https://zlee.xyz/categories/Thoughts/"/>
    
    
      <category term="艾穆-安格瑞" scheme="https://zlee.xyz/tags/%E8%89%BE%E7%A9%86-%E5%AE%89%E6%A0%BC%E7%91%9E/"/>
    
  </entry>
  
  <entry>
    <title>The Destination of 2018</title>
    <link href="https://zlee.xyz/2018/12/31/%E4%BA%8C%E3%80%87%E4%B8%80%E5%85%AB/"/>
    <id>https://zlee.xyz/2018/12/31/二〇一八/</id>
    <published>2018-12-31T14:20:01.000Z</published>
    <updated>2019-05-16T09:03:52.780Z</updated>
    
    <content type="html"><![CDATA[<p></p><p blockquote="" class="centerquote"><i>二〇一八年的最后一天 </i></p><a id="more"></a><p>今天是二〇一八年最后一天。</p><p>我想与自己聊一聊，可能是尚未消逝于脑海的过往，已经做好打算的未来，亦或只是单纯聊聊现在坐在图书馆的自己。</p><p>最近有什么值得回忆的事情呢…..</p><p>啊…..好像不怎么能记起来了，难道是因为黑历史太多了吗（笑），感觉要归功于自己今年努力保持不引人注意的成果。</p><p>——其实还是有的。例如暑假和一群大一的小朋友完成了自己的暑期实践+毛概论文。总的来说，作为团队的一份子，我没怎么摸到鱼，顺便了解到创业的客观政策情况与创业者的个人观念。</p><p>结论嘛……..对于大多数的大学生创业者来说，大创活动就是面向PPT创业ORZ……</p><p>再者就是一些对我影响非常大的事件了。</p><p>大概10月吧，就是学习了一点python，学了一点数据结构，学了一点奇奇怪怪的知识，想要分享自己的每一阶段的学习经历和成果 <del>菜到不行的鶸总是会有一个幼稚的幻想</del>。</p><p>CSDN算是一个选择，但我最初想的是利用利用阿里云ECS搭建一个博客网站，也成功的利用word press搭建了自己的第一个网站——虽然她连域名都没有就到期了QAQ。</p><p>总之我选择了Hexo，它可以很简洁，可以很好看。最重要的是，<strong>HEXO完全属于自己</strong>，而我恰好需要一个这样的能够体现自己的平台。</p><p>每一个鶸都会在一些花里胡哨的地方误入歧途。</p><p>我也一样 ，<del>此处并没有表情包！</del>  经过一点折腾，HEXO搭建完成，我真的蛮高兴的，于是我想着要把她变得好看一点，更好看一点。于是去查阅别人利用Hexo搭建的博客，一点一点的尝试，认为自己在做很有意义的事。</p><p>之后是另一个关键的时间点。</p><p>我遇到了……emmmmm，用AZ来代指吧！</p><p>很庆幸遇到了AZ，人类永远无法真正理解旁人的感受，正如只有我自己才能明白AZ之于我是什么意义，言语无法传达，或者说把它锁在自己心里就足够了。</p><p>如果说，之前的得过且过学好老师指定的课程，然后空闲时间打打游戏追追番剧就OK的话，我现在只觉得那是一种对自己的侮辱。</p><p>更加令我痛苦的是，我正在做的事情，是别人在很久以前就接触的事物。而他们，也只是利用了自己的业余时间而已……</p><p>以前我总喜欢用咸鱼来自嘲：”咸鱼咸鱼咸~“。有个道理大家都懂，只有有钱人才能哭喊自己好穷，智商高的家伙才能说自己智商一般，全靠努力。</p><p>都只是调侃，谁当真谁傻X。</p><p>AZ和他的朋友们有时候也会觉得自己很丧，觉得自己什么都做不好。所以当我与AZ，与AZ的朋友们对比时。我觉得自己真的不配用咸鱼来自嘲——<strong>我在NJU所做的一切，都没有跳出所谓的COMFORT ZONE</strong>，在某种意义上，我只是一个在原地踏步的<em>The Blind</em>。而他们，才是真正的在春风料峭中鲜衣怒马红刀的风流少年。</p><p>记忆会随着时光的侵蚀而逐渐淡化，我突然想要写一篇水水的博文也只是想留下一抹来自二〇一八的过往。</p><p>就这样吧。</p><p>$Kevin Lee .$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p blockquote=&quot;&quot; class=&quot;centerquote&quot;&gt;&lt;i&gt;二〇一八年的最后一天 &lt;/i&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Thoughts" scheme="https://zlee.xyz/categories/Thoughts/"/>
    
    
      <category term="Thought" scheme="https://zlee.xyz/tags/Thought/"/>
    
      <category term="Unknown" scheme="https://zlee.xyz/tags/Unknown/"/>
    
  </entry>
  
  <entry>
    <title>Simple Tutorial for C++ Programming</title>
    <link href="https://zlee.xyz/2018/12/29/C++%20Programing/"/>
    <id>https://zlee.xyz/2018/12/29/C++ Programing/</id>
    <published>2018-12-28T16:00:01.000Z</published>
    <updated>2019-05-16T08:56:51.448Z</updated>
    
    <content type="html"><![CDATA[<p></p><p blockquote="" class="centerquote"><i>  Better Than Nothing </i></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这只是心血来潮的产物, 他的内容基础到我都不好意思称呼他为一篇正经的C++指南…..</p><p>最致命的一点, 估计就是大量的默认了解过C语言的相关概念了……</p><p>总之算是我的一个尝试吧, <del>使我知道了写这样的博文会很蛋疼</del><br><a id="more"></a></p><h2 id="计算机与C-简介"><a href="#计算机与C-简介" class="headerlink" title="计算机与C++简介"></a>计算机与C++简介</h2><blockquote><p>选择性了解</p></blockquote><h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><ul><li>输入单元 (input unit)</li><li>输出单元 (output unit)</li><li>内存单元 (memory unit)</li><li>算术逻辑单元 (arithmetic and logic unit, ALU)</li><li>中央处理器 (central processing unit, CPU)</li><li>辅助存储单元 (secondary storage unit)</li></ul><h3 id="数据的层次结构"><a href="#数据的层次结构" class="headerlink" title="数据的层次结构"></a>数据的层次结构</h3><ul><li><p>位 (Bit)<br>位, 计算机最小的数据项, 数值为0或1. (Binary digit)</p></li><li><p>字符 (Charater)<br>Unicode字符集包含了世界上很多中语言, 每个字符是由两个字节(Byte)组成, 每个字节是8位. 流行的ASCII(美国信息交换标准代码) 是Unicode的子集.</p></li><li><p>字段 (Field)</p></li><li>记录 (Record)</li><li>文件 (File)</li><li>数据库 (Database)<br>层次结构中, 除去数据库之外, 其余相邻层次均为组成与被组成关系</li></ul><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul><li><p>机器语言<br>一般由0/1组成, 令人费解. 计算机能直接执行.</p></li><li><p>汇编语言<br>采用类似英语缩写的指令表示基本操作. 汇编器(assembler) 负责将汇编语言转换成机器语言, 然后才能被计算机理解.</p></li><li><p>高级语言<br>抽象程度更高, 一种方式是采用编译器(compiler)转换为机器语言. 例如: C++, Java, C#等.<br>另一种方式是采用解释器(interpreter), 可以直接执行高级语言程序 (没有编译的延迟), 但是执行过程会慢得多. 脚本语言采用解释器来处理, 例如: JavaScript, PHP</p></li></ul><h3 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h3><ul><li>对象</li><li>成员函数和类</li><li>实例化</li><li>重用</li><li>消息和成员函数调用</li><li>属性和数据成员</li><li>封装 (encapsulate)</li><li>继承 (inheritance)</li><li><strong>UML (统一建模语言)</strong><br>Unified Modeling Language</li></ul><h2 id="C-编程入门"><a href="#C-编程入门" class="headerlink" title="C++ 编程入门"></a>C++ 编程入门</h2><blockquote><p>没什么好说的, 简单提几点</p></blockquote><h3 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入/输出流"></a>输入/输出流</h3><ul><li>输出流对象<code>std::cout</code>用于输出数据, 串联的流插入运算符<code>&lt;&lt;</code>可以输出多个数据</li><li>输入流对象<code>std::cin</code>用于输入数据, 串联的流提取运算符<code>&lt;&lt;</code>可以输入多个数据<br>请记住, <code>cout</code>和<code>cin</code>是对象, 这一点在运算符重载中会有体现 </li></ul><h3 id="变量和内存"><a href="#变量和内存" class="headerlink" title="变量和内存"></a>变量和内存</h3><ul><li>每个变量都具有: 名字, 值, 类型, 内存大小,<strong>存储类别, 作用域和链接</strong> .</li><li>对内存的读取过程是非破坏性的, 写入则相反</li></ul><h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><ul><li>求模运算符 (%) 只能得到整数除法的余数</li><li>using 声明<br>using std::cout;<br>表示告知编译器, 在命名空间 <code>std</code> 中找到<code>cout</code></li></ul><h2 id="类-对象和字符串"><a href="#类-对象和字符串" class="headerlink" title="类, 对象和字符串"></a>类, 对象和字符串</h2><blockquote><p>类、对象、数据成员、成员函数、UML图、构造函数</p></blockquote><p>###　类的定义</p><ul><li>通常来说, 类应当包括数据成员和成员函数, 两者对应着类的属性和行为</li><li>成员访问说明符: <code>public`</code>private<code></code>protected`</li><li>类的数据成员应当设计成私有（private）、成员函数设计成公有（public）</li></ul><ul><li>按照惯例, 类名每个单词首字母大写, 函数名则采用驼峰式写法<br><del>这样优雅</del></li></ul><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><ul><li>成员函数一般声明为public</li><li>定义同<strong>C语言</strong>的函数语法</li></ul><h3 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h3><ul><li>数据成员可以被声明为 public/private/protected</li><li><p>尽可能复用get/set函数，以便于建立更为强壮（易维护）的类<br>get/set函数是类提供的对私有成员(private) 的访问接口</p></li><li><p>应当将<strong>数据成员私有化</strong><br>通过公有函数控制访问数据成员的权利，保证数据的完整性. 数据完整性还包括对有效性的检查和报告错误</p></li></ul><h3 id="构造函数（constructor）"><a href="#构造函数（constructor）" class="headerlink" title="构造函数（constructor）"></a>构造函数（constructor）</h3><ul><li>构造函数初始化对象；</li><li>构造函数可能为非显式；例如类<code>string</code>默认字符串的构造函数为空串</li><li>explicit构造函数必须显式调用。原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。<a href="https://blog.csdn.net/fengbingchun/article/details/51168728" target="_blank" rel="noopener">QUATE</a></li><li>构造函数不能返回值</li><li>通常构造函数声明为public（成员访问说明符)</li><li><code>Account</code>类构造函数定义如下<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VIM"><figure class="iseeu highlight /vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accoun<span class="variable">t:</span>:Account(<span class="keyword">int</span> <span class="keyword">number</span>):<span class="keyword">number</span>(<span class="keyword">number</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><p>此例中，构造函数通过成员初始化列表用构造函数形参<code>number</code>初始化数据成员<code>number</code></p><ul><li>析构函数形式通常为<code>~</code>+构造函数</li></ul><h3 id="接口与实现的分离"><a href="#接口与实现的分离" class="headerlink" title="接口与实现的分离"></a>接口与实现的分离</h3><p>所谓接口是指函数原型(函数声明), 实现是指函数定义. 好的实践是将二者分离, 即头文件定义类并对函数声明, 外部cpp定义类的成员函数.   </p><ul><li><code>::</code>二元作用域分辨运算符 (scope resolution operator), 成员函数定义在类定义外部时启用</li><li>using指令和声明不应放在头文件中</li><li>函数原型告知编译器函数的名字、返回类型、形参类型；函数定义则是包含函数的实现</li></ul><h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h3><ul><li><code>string</code>是C++标准库类型 </li><li>读取字符串时，流提取运算符读取字符在遇到第一个空白字符时停止，所以使用<code>getline(cin，xxx)</code>替代<code>cin&lt;&lt;xxx</code></li><li><code>substr</code>函数中，第一个参数表示起始位置，第二个表示复制字符的个数</li></ul><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><ul><li>UML图分为三层, 每一层用横线隔开, 采用<code>+`</code>-`对应公有和私有</li><li><p>上层为类名</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GradeBook</span></span><br></pre></td></tr></table></figure></div></li><li><p>中层为数据成员</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DELPHI"><figure class="iseeu highlight /delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- course <span class="keyword">Name</span>:<span class="keyword">String</span></span><br></pre></td></tr></table></figure></div></li><li><p>下层为成员函数</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DELPHI"><figure class="iseeu highlight /delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;<span class="function"><span class="keyword">constructor</span>&gt;&gt; + <span class="title">GradeBook</span><span class="params">(<span class="keyword">name</span>:<span class="keyword">String</span>)</span></span></span><br><span class="line"><span class="function">+ <span class="title">setName</span><span class="params">(<span class="keyword">name</span>:<span class="keyword">String</span>)</span></span></span><br><span class="line"><span class="function">+ <span class="title">getCourse</span> <span class="title">Name</span><span class="params">()</span>:</span><span class="keyword">String</span></span><br><span class="line">+ displayMessage()</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="本章小结："><a href="#本章小结：" class="headerlink" title="本章小结："></a>本章小结：</h3><p><strong>建立类、接口与实现分离、构造函数初始化对象、UML图</strong></p><ul><li>对于new的对象应使用destroctor（析构函数，防止内存泄漏）；</li><li>结构体声明也会初始化对象</li></ul><h2 id="控制语句-Ⅰ-赋值、自增自减运算符"><a href="#控制语句-Ⅰ-赋值、自增自减运算符" class="headerlink" title="控制语句(Ⅰ)赋值、自增自减运算符"></a>控制语句(Ⅰ)赋值、自增自减运算符</h2><blockquote><p>主要内容和<strong>C语言</strong>类似, 不必展开.  其余内容无法展开</p></blockquote><h3 id="控制结构-control-structure"><a href="#控制结构-control-structure" class="headerlink" title="控制结构 (control structure)"></a>控制结构 (control structure)</h3><ul><li><strong> 顺序 (sequence), 选择 (selection)和循环 (repetition)</strong></li><li>循环控制结构分为: 计数器控制和标记控制</li><li>控制结构可以嵌套</li></ul><p><em>One Trick of Selection Structure</em><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MATLAB"><figure class="iseeu highlight /matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">i</span> = <span class="built_in">i</span>==<span class="number">1</span>?<span class="built_in">i</span>=<span class="number">0</span>:<span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;(grade&gt;=<span class="number">60</span>?<span class="string">"passed"</span>:<span class="string">"failed"</span>;</span><br></pre></td></tr></table></figure></div></p><p>###　赋值</p><ul><li>Int A = 1.3 ; 警告但仍能编译；Int A = { 1.3 };出现错误，无法编译。这是一种‘缩小转换，我们应该尽量避免</li><li>可以使用 static_cast()来强制转换类型<br>  ​    <h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3></li><li><code>--a</code>和<code>a--</code>的区别: </li></ul><p><code>a--</code>中，变量表达式先使用a值，再对a进行更新<br><code>--a</code>中，a先更新，然后在变量表达式中使用<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i++&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// i=2 ;输出 1;</span></span><br></pre></td></tr></table></figure></div></p><ul><li>自增自减运算符不可用于表达式：如<code>(x+1)++</code>为错</li></ul><h3 id="本章小结：-1"><a href="#本章小结：-1" class="headerlink" title="本章小结："></a>本章小结：</h3><ul><li>算法：根据索要执行的动作及这些动作执行的顺序描述的解决问题的过程；</li><li>伪代码: <del>没啥用</del></li><li><p>控制结构（顺序、选择、循环）:</p><p>  顺序结构；</p><p>  选择结构：选择语句（单路选择if，双路选择if else）、循环语句while</p><p>  循环结构；</p></li></ul><h2 id="控制语句-Ⅱ-和逻辑运算符"><a href="#控制语句-Ⅱ-和逻辑运算符" class="headerlink" title="控制语句(Ⅱ)和逻辑运算符"></a>控制语句(Ⅱ)和逻辑运算符</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><del>这不是游戏机!!</del><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>: &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"guna!!!"</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"rua!!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h3 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h3><p>结束和跳过的区别</p><h3 id="本章小结：-2"><a href="#本章小结：-2" class="headerlink" title="本章小结："></a>本章小结：</h3><blockquote><p>for语句；do..while语句；switch多路选择语句；break&amp;continue语句；<br>逻辑运算符||、&amp;&amp;、！；<br>==、=运算符；<br>结构化编程：任何形式的控制都可以用顺序、选择、循环语句来表达，并且这些语句的组合方式只有堆叠和嵌套；</p></blockquote><h2 id="函数与递归"><a href="#函数与递归" class="headerlink" title="函数与递归"></a>函数与递归</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>函数参数: 形参实参, 引用和值,<br>调用堆栈, 标识符作用域, 重载, 模板<br>变量: 存储类别, 作用域, 链接<br>递归与迭代</p></blockquote><h3 id="C-程序组件"><a href="#C-程序组件" class="headerlink" title="C++程序组件"></a>C++程序组件</h3><ul><li>C++程序是由预先打包的函数和类及自己编写的函数和类组合而成；</li><li>C++库有自己的头文件，同时也包含了各种类类型、函数和常量的定义</li></ul><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ul><li>函数原型包括返回值类型, 函数名和参数类型. 函数名和参数类型合并称为函数签名</li><li>C++ 的函数参数类型存在基本类型间的隐式转换</li><li>可以简单理解为函数声明中除去返回值的部分</li></ul><h3 id="随机数与枚举类型"><a href="#随机数与枚举类型" class="headerlink" title="随机数与枚举类型"></a>随机数与枚举类型</h3><h4 id="Rand"><a href="#Rand" class="headerlink" title="Rand()"></a><code>Rand()</code></h4><p>该函数原型包含于<code>&lt;cstdlib&gt;</code>头文件下，如果没有利用<code>srand()</code>更新种子，那么每次的随机数生成结果将完全相同。</p><ul><li><code>Rand()</code>可预测，不具有<strong>良好的统计特性</strong>. 安全性较弱</li><li>C++11提供了<code>&lt;random&gt;</code>随机数库，用配置控制引擎产生的值、值的类型、及统计特性；用引擎实现一套生成伪随机数的算法；<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function">Int <span class="title">main</span><span class="params">()</span><span class="comment">//默认的随机数生成引擎和默认的配置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Default_random_engine   <span class="title">engine</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(time(<span class="number">0</span>)))</span></span>;</span><br><span class="line">Uniform_int_distribution&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;</span><br><span class="line">randomInt(<span class="number">1</span>,<span class="number">6</span>)<span class="comment">//Uniform_int_distribution是一个类模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="Srand"><a href="#Srand" class="headerlink" title="Srand()"></a><code>Srand()</code></h4><p>该函数原型包含于<code>&lt;cstdlib&gt;</code>头文件下，通常为<code>srand(static_cast&lt;unsigned int(time(0)))</code>，意为将<code>time()</code>返回的值（从格林尼治时间到当前的秒数）从<code>time_t</code>转换为<code>int</code>类型，并用作随机数种子。<br>实例<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srand(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>(time(<span class="number">0</span>)))；</span><br><span class="line">Number=C+rand()%A;<span class="comment">//生成值域为[C,C+A-1]的随机数</span></span><br></pre></td></tr></table></figure></div></p><h4 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h4><p>关键字enum+枚举类型名+一组由标识符表示的整型常量<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRYSTAL"><figure class="iseeu highlight /crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Status</span>&#123;<span class="title">CONTINUE</span>, <span class="title">WON</span>, <span class="title">LOST</span>&#125;;</span></span><br></pre></td></tr></table></figure></div></p><p>默认情况下，枚举类型值从零开始并递增1，整型类型为int；<br>类型名首字母最好大写；枚举常量必须大写；<br>枚举类型名+<code>:</code>+整型类型，制定整型类型；</p><p>进阶情况：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="KOTLIN"><figure class="iseeu highlight /kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>: <span class="type">unsigned int &#123;CONTINUE=1</span>, <span class="type">WON</span>, <span class="type">LOST&#125;;</span></span></span><br></pre></td></tr></table></figure></div></p><p>作用域限定，可以避免潜在的命名冲突和逻辑错误；<br>设定整型类型，应足够保证保存指定的常量值；<br>引用枚举常量：<code>result==Status:: WON;</code></p><h3 id="存储类别和存储期-入门"><a href="#存储类别和存储期-入门" class="headerlink" title="存储类别和存储期(入门)"></a>存储类别和存储期(入门)</h3><h4 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h4><ol><li>五个类别的标识符： <code>auto</code> <code>extern</code> <code>static</code> <code>register</code> <code>mutable</code></li><li>四种类型: 自动存储期, 静态, 动态, 线程</li></ol><h5 id="自动存储期变量-register-amp-auto"><a href="#自动存储期变量-register-amp-auto" class="headerlink" title="自动存储期变量(register &amp; auto)"></a>自动存储期变量(register &amp; auto)</h5><ol><li>定义在函数内的局部变量</li><li>函数形参</li><li><code>register</code>声明的局部变量或函数形参</li></ol><h5 id="静态存储期变量-static-amp-extern"><a href="#静态存储期变量-static-amp-extern" class="headerlink" title="静态存储期变量(static &amp; extern)"></a>静态存储期变量(static &amp; extern)</h5><blockquote><p>具有静态存储期的变量从程序开始执行到结束, 一直存在于内存中.<br>对于这样的变量, 声明时便对它进行一系列初始化.<br>当然, 存储期和作用域是两回事, 他不意味着在整个程序都能使用<br>标识为<code>static</code> 的局部变量在函数结束后也不会消失, 它会以最后一次的返回值保留</p></blockquote><p>Trick code<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> a= <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> b=<span class="number">1</span>;</span><br><span class="line">b++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;::a&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//10, 此时的:: 是一元作用域分辨符</span></span><br><span class="line">foo();</span><br><span class="line">foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h5 id="寄存器变量-register"><a href="#寄存器变量-register" class="headerlink" title="寄存器变量(register)"></a>寄存器变量(register)</h5><ol><li><code>register</code>建议将变量放置在计算机的高速硬件寄存器而不是内存中, 对于频繁使用的变量采用<code>register</code>可以有效消除变量-&gt;内存-&gt;寄存器-&gt;内存的开销. </li><li>只能与局部变量和函数形参一起使用</li><li>理论上不需手动优化, 编译器可以智能识别</li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>标识符在程序中可以被引用的范围</p><ul><li><p>函数作用域<br>仅限于<code>case:</code>一类</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>()&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">a:</span>&#123;&#125;;<span class="keyword">break</span>;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>语句块作用域<br>最广泛, 作用域为从声明到语句块右大括号.</p></li><li><p>全局命名空间作用域(global namesapce scope )<br>声明于任何函数和类之外, 对于从声明到文件结束的任何函数都是<strong>已知</strong>的.</p></li><li><p>函数原型作用域<br>实际上函数原型的参数不需要标志符, 只需要类型, 所以函数原型作用域的标识符可以在任意处复用.</p></li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>标识符是否只是在声明它的源文件被识别, 或者可以在编译后链接的多文件被识别</p><h3 id="函数调用堆栈和活动记录"><a href="#函数调用堆栈和活动记录" class="headerlink" title="函数调用堆栈和活动记录"></a>函数调用堆栈和活动记录</h3><p>函数调用是一种 LIFO机制, 每层次包含了函数的返回地址和其他信息, 递归调用最能直观体现.</p><h3 id="引用和引用形参"><a href="#引用和引用形参" class="headerlink" title="引用和引用形参"></a>引用和引用形参</h3><ul><li><code>Int &amp;count</code> 表示<code>count</code>是对一个<code>int</code>类型对象的引用</li><li>按引用传递的形参等价于原有实参的别名，修改按引用传递的形参等于修改对应实参</li><li>如果一个函数的形参是按引用传递的：即<code>int &amp; count</code>，很可能会因为引用形参导致对应实参被修改而发生错误！</li></ul><h3 id="函数重载和函数模板-入门"><a href="#函数重载和函数模板-入门" class="headerlink" title="函数重载和函数模板(入门)"></a>函数重载和函数模板(入门)</h3><ul><li>函数重载：相同函数名，但具有不同的形参集合；通过<strong>函数签名</strong>区分；</li><li>函数模板：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CEYLON"><figure class="iseeu highlight /ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T maximum(T <span class="keyword">value</span><span class="number">1</span>, T <span class="keyword">value</span><span class="number">2</span>, Tvalue<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">T maximumValue= <span class="keyword">value</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">//省略中间</span></span><br><span class="line"><span class="keyword">return</span> maximumValue;</span><br></pre></td></tr></table></figure></div></li></ul><p>T为参数类型（int、double等）</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>递归函数是直接或者间接调用自身的函数；</li><li>一般分解为两个步骤: 基本情况终结递归, 和简化情况调用递归</li><li>内存开销很大</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>这里描述的指针沿袭了C语言风格, 实际运用时需要注意最小特权原则. 默认有一定的C语言基础，基本知识略去</p><h3 id="指针变量的声明与初始化"><a href="#指针变量的声明与初始化" class="headerlink" title="指针变量的声明与初始化"></a>指针变量的声明与初始化</h3><ol><li><p>指针变量与间接引用<br>指针变量把内存地址作为它的值. 如果说一个变量名直接引用一个值, 那么一个存有一个变量名内存地址的指针变量就是间接引用这个值. </p></li><li><p>指针的声明</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AUTOIT"><figure class="iseeu highlight /autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> *<span class="built_in">ptr</span>, count<span class="comment">;</span></span><br><span class="line">// <span class="built_in">ptr</span>是一个是一个指向<span class="built_in">int</span>类型数据的指针</span><br><span class="line">// count是一个<span class="built_in">int</span>类型的变量</span><br><span class="line">// (*)在这里并不是运算符, 他只是用于表示<span class="built_in">ptr</span>是一个指针</span><br></pre></td></tr></table></figure></div></li><li><p>指针初始化<br>将指针初始化为<code>nullptr</code>是有必要的, 这可以防止它指向一个未知的或者未被初始化的内存空间</p></li></ol><h3 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符"></a>指针运算符</h3><ul><li>地址运算符<code>&amp;</code><br>地址运算符是一个一元运算符, 它获得操作数的内存地址.<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取址与赋值</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *yptr = <span class="literal">nullptr</span>;</span><br><span class="line">yptr = &amp;y;</span><br></pre></td></tr></table></figure></div></li></ul><p>值得一提的是, 这里的<code>&amp;</code>与我们之前在函数中提到的引用变量声明<code>&amp;</code>不同, 简言之:<br>​    1. 后者的前面必然有一个数据类型名<br>​    2. 在声明一个引用的时候,<code>&amp;</code>只是类型的一部分</p><ul><li>间接运算符<code>*</code><br>一元运算符<code>*</code>通常被称为简介运算符或者间接引用( dereference)运算符. <strong>它返回一个左值</strong>, 表示其指针操作数所指向的对象<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*yptr = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt; *yptr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; *yptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//两者等价</span></span><br></pre></td></tr></table></figure></div></li></ul><p>###　使用指针的按引用传递方式</p><p><del>真実はいつもひとつ</del></p><p><strong>所有的引用都是传值引用, 无非你传入的是指针的内存地址值, 又或者是变量值.</strong></p><h3 id="内置数组"><a href="#内置数组" class="headerlink" title="内置数组"></a>内置数组</h3><ul><li><p>C语言风格, 主要特点是内存连续, 通过下标访问, 大小固定.<br>不建议使用, 可以改用标准库中的 <code>vector</code> 或者<code>array</code></p></li><li><p>对于Linux 或者 OS X系统来说, 内置数组有时是必要的.<br>例如使用命令行执行程序时, 需要给程序提供命令行参数, 此时的命令行参数将作为一个具有基于指针的字符串元素的内置数组传递给<code>main</code>函数.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Windows 下常见的main函数声明方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">int</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="comment">/* your code */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="使用const修饰指针"><a href="#使用const修饰指针" class="headerlink" title="使用const修饰指针"></a>使用const修饰指针</h3><ol><li><p>指向非const 数据的非const 指针<br>具有最大的访问权限, 指针和数据均可修改</p></li><li><p>指向const 数据的非const 指针<br>可以修改指针指向, 不可以修改数据.<br>可以在只读函数中大胆使用, 获取数据的高速引用.</p></li><li><p>指向非const 数据的const 指针</p></li><li><p>指向const 数据的const 指针</p></li></ol><h3 id="指针表达式和指针算数运算和内置数组"><a href="#指针表达式和指针算数运算和内置数组" class="headerlink" title="指针表达式和指针算数运算和内置数组"></a>指针表达式和指针算数运算和内置数组</h3><ul><li><p>指针赋值<br>只有在已知指针类型的情况下, 编译器才能进行指针赋值. 例如 <code>void*</code>类型指针无法直接被赋值到其他类型指针. 因为编译器需要知道一个指针所指向的字节数和数据类型, 确定该指针间接引用的字节数.</p></li><li><p>指针比较<br>非同一数组指针的比较毫无意义</p></li><li><p>指针/偏移量表示法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">int</span> <span class="keyword">b[5];</span></span><br><span class="line"><span class="keyword">int* </span><span class="keyword">bPtr;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">//b[3]的几种写法</span></span><br><span class="line"><span class="keyword">*(bPtr </span>+ <span class="number">3</span>)</span><br><span class="line">*(<span class="keyword">b </span>+<span class="number">3</span>)</span><br><span class="line">* &amp;<span class="keyword">b[3]</span></span><br><span class="line"><span class="keyword">* </span>&amp;(<span class="keyword">bPtr </span>+<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div></li></ul><p>请注意, <code>b+= 3</code> 这种写法是错误的, 内置数组名不可修改.</p><h2 id="类的深入剖析：抛出异常"><a href="#类的深入剖析：抛出异常" class="headerlink" title="类的深入剖析：抛出异常"></a>类的深入剖析：抛出异常</h2><blockquote><p>头文件的包含防护(include guard) : #pragma once<br>继承和组成概念</p></blockquote><h3 id="类的作用域和类成员的访问"><a href="#类的作用域和类成员的访问" class="headerlink" title="类的作用域和类成员的访问"></a>类的作用域和类成员的访问</h3><p>成员选择运算符<code>.</code>和<code>-&gt;</code><br><code>.</code> 适用于对象或对象引用, <code>-&gt;</code> 适用于对象的指针</p><h3 id="const-对象和const-成员函数"><a href="#const-对象和const-成员函数" class="headerlink" title="const 对象和const 成员函数"></a>const 对象和const 成员函数</h3><p>对于const 对象, C++编译器不允许被除声明为const的成员函数之外的成员函数调用.</p><blockquote><p>很明显我们的构造函数和析构函数无法被声明为const, 况且构造函数和析构函数必然会修改对象. 这里, <strong>const的有效性是指对于构造函数和析构函数之间的部分而言</strong></p></blockquote><h3 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h3><p>友元声明(friend)<br>友元关系是授予的而不是索取的. 如果说B是A的友元, 那么B可以访问A的成员. 对于A来说, A不是B的友元, A无法对B中的成员进行访问. 例如<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classTwo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classOne</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">classTwo</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">classOne();</span><br><span class="line">~classOne()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h3 id="static-类数据成员"><a href="#static-类数据成员" class="headerlink" title="static 类数据成员"></a>static 类数据成员</h3><ul><li><code>static</code> 表示”整个类范围”上的信息(即类所有实例共享的性质, 而不是某个特定实例具有的特性)</li><li>static 数据成员具有类作用域并且可以声明为public, private, protected.</li><li><code>static</code> 关键字不能用于类定义之外的成员定义</li><li>对于不访问非static数据成员或非static成员函数的成员函数, 应当声明为<code>static</code>. static成员函数没有<code>this</code>指针, 它独立于类的任何对象</li><li><ul><li>没有类对象, 类的static类成员依旧存在, 并且可以用类名+<code>::</code> 作为前缀直接访问public static类成员</li></ul></li><li>当没有类的对象存在而要访问private的static类成员时，应该提供public static 成员函数；并通过在函数名前加类名和二元作用域分辨运算符的方式来调用此函数</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p blockquote=&quot;&quot; class=&quot;centerquote&quot;&gt;&lt;i&gt;  Better Than Nothing &lt;/i&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这只是心血来潮的产物, 他的内容基础到我都不好意思称呼他为一篇正经的C++指南…..&lt;/p&gt;
&lt;p&gt;最致命的一点, 估计就是大量的默认了解过C语言的相关概念了……&lt;/p&gt;
&lt;p&gt;总之算是我的一个尝试吧, &lt;del&gt;使我知道了写这样的博文会很蛋疼&lt;/del&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Human Learning" scheme="https://zlee.xyz/categories/Human-Learning/"/>
    
    
      <category term="Note" scheme="https://zlee.xyz/tags/Note/"/>
    
      <category term="C++" scheme="https://zlee.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>The Next</title>
    <link href="https://zlee.xyz/2018/12/16/The%20NexT/"/>
    <id>https://zlee.xyz/2018/12/16/The NexT/</id>
    <published>2018-12-16T12:47:25.000Z</published>
    <updated>2019-05-16T11:18:40.479Z</updated>
    
    <content type="html"><![CDATA[<p></p><p blockquote="" class="centerquote"><i>谨以此文, 纪念一个误入NexT坑的年轻人</i></p><a id="more"></a><h2 id="一点提示"><a href="#一点提示" class="headerlink" title="一点提示"></a>一点提示</h2><blockquote><p>Tips:<br><code>hexo s</code>后可以直接本地调试，也就是更改文件保存后，Hexo 后台会自动重新渲染文件，所以只要稍等片刻，浏览器刷新一下就能看到效果。</p></blockquote><h2 id="无序列表圆点"><a href="#无序列表圆点" class="headerlink" title="无序列表圆点"></a>无序列表圆点</h2><p>不喜欢默认空心圆无序列表，我们换成实心的列表：</p><p>主题目录：</p><p><code>source/css/_common/components/post/post-expand.styl:</code><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DSCONFIG"><figure class="iseeu highlight /dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ul </span><span class="string">li </span>&#123; <span class="built_in">list-style:</span> <span class="string">disc;</span> &#125;</span><br></pre></td></tr></table></figure></div></p><p>页面列表：<br><code>next/source/css/_custom/custom.styl:</code><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DSCONFIG"><figure class="iseeu highlight /dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ul </span>&#123;</span><br><span class="line">    <span class="built_in">list-style-type:</span> <span class="string">disc;</span>  // 空心圆，实心圆为 <span class="string">disc</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div></p><p>参考：<a href="https://github.com/iissnan/hexo-theme-next/issues/559" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/issues/559</a></p><h2 id="主页文章阴影"><a href="#主页文章阴影" class="headerlink" title="主页文章阴影"></a>主页文章阴影</h2><p>打开\themes/next/source/css/_custom/下的custom.styl, 添加<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight /scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">   -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">   -moz-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h2 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h2><p>打开主题配置文件<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VALA"><figure class="iseeu highlight /vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="meta"># Dependencies: https://github.com/theme-next/theme-next-pace</span></span><br><span class="line">pace: <span class="literal">false</span> #点击上述链接, 下载pace. 然后把这个修改为<span class="literal">true</span></span><br><span class="line"><span class="meta"># Themes list:</span></span><br><span class="line"><span class="meta">#pace-theme-big-counter</span></span><br><span class="line"><span class="meta">#pace-theme-bounce</span></span><br><span class="line"><span class="meta">#pace-theme-barber-shop</span></span><br><span class="line"><span class="meta">#pace-theme-center-atom</span></span><br><span class="line"><span class="meta">#pace-theme-center-circle</span></span><br><span class="line"><span class="meta">#pace-theme-center-radar</span></span><br><span class="line"><span class="meta">#pace-theme-center-simple</span></span><br><span class="line"><span class="meta">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="meta">#pace-theme-fill-left</span></span><br><span class="line"><span class="meta">#pace-theme-flash</span></span><br><span class="line"><span class="meta">#pace-theme-loading-bar</span></span><br><span class="line"><span class="meta">#pace-theme-mac-osx</span></span><br><span class="line"><span class="meta">#pace-theme-minimal</span></span><br><span class="line"><span class="meta"># For example</span></span><br><span class="line"><span class="meta"># pace_theme: pace-theme-center-simple</span></span><br><span class="line">pace_theme: pace-theme-minimal</span><br></pre></td></tr></table></figure></div></p><h2 id="修改网页底部图标"><a href="#修改网页底部图标" class="headerlink" title="修改网页底部图标"></a>修改网页底部图标</h2><p>还是打开<code>themes/next/layout/_partials/footer.swig</code>，找到：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DJANGO"><figure class="iseeu highlight /django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">itemprop</span>=<span class="string">"copyrightYear"</span>&gt;</span></span><span class="template-variable">&#123;&#123; current &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"with-love"</span> <span class="attr">id</span>=<span class="string">"animate"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fas fa-igloo"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div></p><p>前往<a href="https://fontawesome.com/" target="_blank" rel="noopener">FontAwesome</a>获取相应图标并替换</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fas fa-igloo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div><h2 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h2><p>打开<code>themes-&gt;next-&gt;layout-&gt;\_partials-&gt;head-&gt;head.swig</code>文件,在以下位置插入这样一段代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="string">'&#123;&#123; page.password &#125;&#125;'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (prompt(<span class="string">'请输入文章密码'</span>) !== <span class="string">'&#123;&#123; page.password &#125;&#125;'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                alert(<span class="string">'密码错误！'</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (history.length === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                    location.replace(<span class="string">"http://zlee.xyz"</span>); <span class="comment">// 这里替换成你的首页</span></span></span><br><span class="line"><span class="actionscript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="undefined">                    history.back();</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h2 id="萌え萌えlive2d"><a href="#萌え萌えlive2d" class="headerlink" title="萌え萌えlive2d"></a>萌え萌えlive2d</h2><p>首先安装live2d模块<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-helper-live2d</span></span><br></pre></td></tr></table></figure></div></p><p>然后选择要安装的live2d模型<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> live2d-widget-<span class="keyword">model</span>-[填入代号]</span><br></pre></td></tr></table></figure></div></p><p>在站点/主题配置文件_config.yml中追加<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/xiazeyu/live2d-widget.js</span></span><br><span class="line"><span class="comment">## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line"><span class="attr">  pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line"><span class="attr">  pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  debug:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-koharu</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line"><span class="attr">    vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    superSample:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">150</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">left</span></span><br><span class="line"><span class="attr">    hOffset:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">    vOffset:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">0.5</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line"><span class="attr">    opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure></div></p><p>大小方向自行调参, 重新生成即可. 如果生成出现<strong>YAML 解析错误</strong>, 请检查是否正确采用<code>tab</code>缩进.</p><h2 id="设置代码块"><a href="#设置代码块" class="headerlink" title="设置代码块"></a>设置代码块</h2><p>这是一个很长的故事…….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p blockquote=&quot;&quot; class=&quot;centerquote&quot;&gt;&lt;i&gt;谨以此文, 纪念一个误入NexT坑的年轻人&lt;/i&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://zlee.xyz/categories/Hexo/"/>
    
    
      <category term="Theme" scheme="https://zlee.xyz/tags/Theme/"/>
    
      <category term="css" scheme="https://zlee.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Data Structure and Algorithm Analysis</title>
    <link href="https://zlee.xyz/2018/12/13/Data-Structure-and-Algorithm-Analysis/"/>
    <id>https://zlee.xyz/2018/12/13/Data-Structure-and-Algorithm-Analysis/</id>
    <published>2018-12-13T00:36:32.000Z</published>
    <updated>2019-05-16T08:57:08.881Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><i>谨以此文, 纪念我没怎么听过的数据结构</i></blockquote><br><img src="http://i0.hdslb.com/bfs/archive/4c9309085933d7cee42218ca647f01f1ca7b46ac.jpg" alt="希尔——崩坏三"><br><a id="more"></a></p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是数据元素的非空有限集合</p><ul><li>唯一一个“ 开始节点”</li><li>唯一一个” 终端节点“</li><li>除开始结点外，集合中的每个数据元素均只有一个直接前驱</li><li>除终端结点外，集合中的每个数据元素均只有一个直接后继</li></ul><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>线性表的结点按逻辑次序存放在一组地址连续的存储单元里, 例如数组</p><p><strong>loc(ai)=loc(a1)+(i-1)*c</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>插入算法和删除算法都是O(n)</p><p>### </p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><ol><li><p>定义要点</p><ul><li>n个结点组成的有限集合</li><li>根结点(root)</li><li>其余结点分为m个子树(subtree)</li><li>x&lt;y, 则Tx在Ty右侧, 称为有序树</li></ul></li><li><p>基本术语<br> 结点(node)——表示树元素，包括数据项及指向其子树的分支<br> 结点的度(degree)——结点拥有的子树个数<br> 叶子(leaf)——度为0的结点，又称终端结点<br> 孩子(child)——结点子树的根称为该结点的孩子<br> 双亲(parents)——孩子结点的上层结点叫该结点的双亲<br> 兄弟(sibling)——同一双亲的孩子<br> 祖先(ancestor) ——树的根结点<br> 子孙(descendant) ——子树上的所有结点<br> 树的度(degree) ——一棵树中最大的结点度数<br> 结点的层次(level)——根为第一层，它的孩子为第二层……<br> 树的深度(depth)——树中结点的最大层次数<br> 森林(forest)——m(m&gt;=0)棵互不相交的树的集合</p></li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol><li>若二叉树的层次从1开始, 则在二叉树的第 i 层最多有2^i+1^ 个结点(i &gt;=1) </li><li>深度为k的二叉树最多有 2k-1个结点(k &gt;=1)</li><li>任意一颗二叉树, 如果其叶节点数为n~0~, 度为2的节点数为n~2~, 则有 n~0~=n~2~+1</li><li>具有 n 个结点的完全二叉树的深度为log~2~(n+1)  向上取整。</li></ol><blockquote><p>定义1  满二叉树(Full Binary Tree)<br>一棵深度为k且有2k –1结点的二叉树称为满二叉树。<br>特点：每一层上的结点数都是最大结点数。</p></blockquote><blockquote><p>定义2  完全二叉树(Complete Binary Tree)<br>若一棵二叉树只有最下两层上的结点的度数可以小于2，并且最下一层上的结点集中分布在该层左侧连续的若干位置上，则该二叉树称为完全二叉树。</p></blockquote><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>顺序存储和链表式存储</p><h3 id="二叉树的先序、中序和后序遍历"><a href="#二叉树的先序、中序和后序遍历" class="headerlink" title="二叉树的先序、中序和后序遍历"></a>二叉树的先序、中序和后序遍历</h3><p>采用递归确定遍历顺序：<br>对于二叉树任意一个父节点和及其子节点，先序遍历永远是父节点，左子，右子.<br>中序和后序同理</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面展示了相应的两种方法</p><ul><li>递归法</li><li>迭代法( 利用栈 )</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(BTreeNode *&amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushStack</span><span class="params">(BTreeNode *&amp;T, BTreeNode *&amp;child)</span></span>;</span><br><span class="line"><span class="function">BTreeNode *<span class="title">PopStack</span><span class="params">(BTreeNode *&amp;T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(BTreeNode *T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树节点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    ElemType data;</span><br><span class="line">    BTreeNode *leftChild;</span><br><span class="line">    BTreeNode *parent;</span><br><span class="line">    BTreeNode *rightChild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历的非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(BTreeNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTreeNode *s;       <span class="comment">//设置预留右子树指针</span></span><br><span class="line">    BTreeNode *p = T;   <span class="comment">//当前结点指向根结点</span></span><br><span class="line">    InitStack(s);       <span class="comment">//初始化空栈</span></span><br><span class="line">    PushStack(s, <span class="literal">NULL</span>); <span class="comment">//压一空指针进栈</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data; <span class="comment">//访问当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rightChild != <span class="literal">NULL</span>)</span><br><span class="line">            PushStack(s, p-&gt;rightChild);</span><br><span class="line">        <span class="comment">//进入左子树前预留右子树指针在栈中</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;leftChild != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;leftChild; <span class="comment">//进入左子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = PopStack(s); <span class="comment">//从栈中弹出相应的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BTreeNode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inOrder(T-&gt;leftChild);  <span class="comment">//中序遍历T的左子树</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; T-&gt;data;        <span class="comment">//访问根结点</span></span><br><span class="line">        inOrder(T-&gt;rightChild); <span class="comment">//中序遍历T的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历的非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(BTreeNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTreeNode *s;</span><br><span class="line">    BTreeNode *p = head;</span><br><span class="line">    InitStack(s);</span><br><span class="line">    PushStack(s, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p||(!isEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            PushStack(s, p);</span><br><span class="line">            p = p-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isEmpty(s))</span><br><span class="line">        &#123;</span><br><span class="line">            p = PopStack(s);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data;</span><br><span class="line">            p = p-&gt;rightChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">void</span> postOrder(BTreeNode *T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder(T-&gt;leftChild);  <span class="comment">//后序遍历T的左子树</span></span><br><span class="line">        postOrder(T-&gt;rightChild); <span class="comment">//后序遍历T的右子树</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; T-&gt;data;        <span class="comment">//访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//post Order Traverse </span></span><br><span class="line"><span class="keyword">void</span> postOrderTraverse(BTreeNode *head)</span><br><span class="line">&#123;</span><br><span class="line">    BTreeNode *s;</span><br><span class="line">    BTreeNode *visit;</span><br><span class="line">    InitStack(s);</span><br><span class="line">    PushStack(s, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (head || (!isEmpty(s)))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            PushStack(s, head);</span><br><span class="line">            head = head-&gt;leftChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">head = PopStack(s);</span><br><span class="line"><span class="comment">//右节点已经访问或者右节点为空的情况下,访问根结点</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;rightChild == <span class="literal">NULL</span> || head-&gt;rightChild == visit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; head-&gt;data;</span><br><span class="line">            visit = head;</span><br><span class="line">            head == <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//右节点尚未访问时,重新压入栈</span></span><br><span class="line">        PushStack(s,head);</span><br><span class="line">        <span class="comment">//访问右节点</span></span><br><span class="line">            head = head-&gt;rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>参考文章:</p><ul><li><a href="https://segmentfault.com/a/1190000016674584#articleHeader9" target="_blank" rel="noopener">二叉树的遍历方法</a></li></ul><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><blockquote><p>由于具有n个结点二叉树中， 共有n+1个指针域空置不用。为此，A.j.Parlis和C.Thornton 提出利用二叉数中这些空的链域来存储结点前驱或后继的地址信息的方法：<br>若某个结点的left指针为空， 则使该left指针指向该结点的前驱结点；若某个结点的right指针为空，则使该right指针指向该结点的后继结点。为了区别两个指针域的含义， 每个结点的存储结构中增加两个布尔型的线索标志字段Lthread 和Rthread。<br>指向前驱结点和后继结点的指针为线索(thread)， 带有线索的二叉树称为<strong>线索二叉树(Threaded Binary Tree) </strong>。</p></blockquote><h3 id="中序线索化二叉树的递归算法"><a href="#中序线索化二叉树的递归算法" class="headerlink" title="中序线索化二叉树的递归算法"></a>中序线索化二叉树的递归算法</h3><h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol><li>由于线索二叉树首先是二叉树，所以对它的任何算法可以是递归的。</li><li>按照中序遍历次序对二叉树进行线索化，对遍历到的每一个结点，先线索化其左子树，再线索化当前结点，最后线索化其右子树。</li><li>设置两个结点指针，分别指向遍历过程中的当前结点和它的前驱结点。</li><li>当前结点的左线索化和其前驱结点的右线索化同时进行.</li><li>若当前结点无左子树，构造其左线索(Lthread= true)及标志，若其前驱无右子树，则构造其前驱的右线索(Rthread= true)及标志。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TBTreeNode</span>    //线索二叉树类型定义</span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line"><span class="keyword">bool</span> Lthread, Rthread;</span><br><span class="line">    ElemType data;</span><br><span class="line">    TBTreeNode *leftChild;</span><br><span class="line">    TBTreeNode *rightChild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Threaded</span><span class="params">(TBTreeNode *t, <span class="keyword">int</span> flag = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> TBTreeNode *prenode; <span class="comment">//当前结点t的前驱指针</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">        prenode = <span class="literal">NULL</span>; <span class="comment">// prenode初值为空</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)      <span class="comment">//t树存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        Threaded(t-&gt;leftChild, <span class="number">1</span>); <span class="comment">//对左子树线索化</span></span><br><span class="line">         t-&gt;Lthread=t-&gt;leftChild==<span class="literal">NULL</span>?<span class="literal">true</span>:<span class="literal">false</span>;<span class="comment">//置左线索标志值</span></span><br><span class="line">        t-&gt;Rthread=t-&gt;rightChild==<span class="literal">NULL</span>?<span class="literal">true</span>:<span class="literal">false</span>;<span class="comment">//置右线索标志值</span></span><br><span class="line">        <span class="keyword">if</span> (prenode != <span class="literal">NULL</span>)    <span class="comment">//当前结点的前驱存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (prenode-&gt;Rthread)</span><br><span class="line">                prenode-&gt;rightChild = t; <span class="comment">//互指</span></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;Lthread)</span><br><span class="line">                t-&gt;leftChild = prenode;</span><br><span class="line">        &#125;</span><br><span class="line">        prenode = t;                <span class="comment">//t作为中序遍历后继结点的前驱</span></span><br><span class="line">        Threaded(t-&gt;rightChild, <span class="number">1</span>); <span class="comment">//对右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="中序线索二叉树的节点插入"><a href="#中序线索二叉树的节点插入" class="headerlink" title="中序线索二叉树的节点插入"></a>中序线索二叉树的节点插入</h3><p>在p所指结点与它的右子树之间插入q所指新结点，可以分两种情形考虑。</p><ul><li><p>P结点存在右子树：<br>此时将q结点作为p结点的右孩子点，p结点原来的右子树作为q结点的右子树，使q结点作为p结点的后继结点，p结点的原后继结点作为q结点的后继结点（将p结点右线索标志及右孩子指针拷贝到q结点），需对有关结点的线索进行赋值或修正。</p></li><li><p>P结点不存在右子树：<br>此时无论p结点是其父结点的左孩子或右孩子，将q结点作为p结点的右孩子结点前，将p结点右线索及标志拷贝到q结点即可。</p></li></ul><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertRight</span><span class="params">(TBTreeNode *p, TBTreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TBTreeNode *s;</span><br><span class="line">    s = InOrderSuc(p);             <span class="comment">//s指向结点p的后继</span></span><br><span class="line">    q-&gt;Lthread = <span class="literal">true</span>;             <span class="comment">//置插入结点左线索标志</span></span><br><span class="line">    q-&gt;leftChild = p;              <span class="comment">//插入点的左线索指向p结点</span></span><br><span class="line">    q-&gt;Rthread = p-&gt;Rthread;       <span class="comment">//复制p结点的右线索标志</span></span><br><span class="line">    q-&gt;rightChild = p-&gt;rightChild; <span class="comment">//复制p结点的右孩子指针</span></span><br><span class="line">    p-&gt;Rthread = <span class="literal">false</span>;            <span class="comment">//置p结点的右线索标志为假</span></span><br><span class="line">    p-&gt;rightChild = q;             <span class="comment">//p结点的右指针指向新插入q结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">NULL</span> &amp;&amp; s-&gt;Lthread)   <span class="comment">//结点p的后继存在且有左线索</span></span><br><span class="line">        s-&gt;leftChild = q;          <span class="comment">//修正使其指向q</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p><strong>二叉排序树(Binary Sort Tree)</strong>具有以下性质：</p><ol><li>二叉排序树可以是棵空树；</li><li>若它的左子树非空，则<strong>左子树的所有结点的关键字均小于根结点的关键字</strong>；</li><li>若它的右子树非空，则<strong>右子树的所有结点的关键字均大于等于根结点的关键字</strong>；</li><li>左子树、右子树本身也是二叉排序树。</li></ol><h3 id="平衡二叉树-AV树"><a href="#平衡二叉树-AV树" class="headerlink" title="平衡二叉树(AV树)"></a>平衡二叉树(AV树)</h3><p>一棵平衡二叉排序树或者是空树，或者是具有下列性质的二叉排序树：</p><ol><li>左子树与右子树的高度之差的绝对值小于等于1</li><li>左子树和右子树也是平衡二叉排序树</li></ol><p>平衡二叉排序树的平均查找长度为O(log~2~n)<br>平衡因子：结点的左子树深度与右子树深度之差(-1，0，1)</p><h3 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h3><ul><li>L和R的自由排列组合: LR, LL, RL, RR</li><li>四种组合没有什么特殊性, 只要注意超出的深度在那个子树上即可.</li><li>调整原则: <strong>所有左子树节点关键字均小于其相应的根节点关键字, 右子树的所有结点的关键字均大于等于根结点的关键字</strong>. </li></ul><blockquote><p>例如根节点左子树的右子树失去平衡, 就是LR型</p></blockquote><h2 id="偏序树"><a href="#偏序树" class="headerlink" title="偏序树"></a>偏序树</h2><p><strong>优先队列(Priority queue)</strong>中每个元素都有一个优先数，删除时，总是删除优先数最大的元素。实现优先队列的一种有效方法是将优先队列的元素组成完全二叉树，二叉树中任何结点的优先数(关键码)不小于它的子女结点的优先数(关键码)，具有这一性质的完全二叉树称为偏序树(Partially order tree)，又称最大堆。如果完全二叉树中任何结点的优先数(关键码)不大于它的子女结点的优先数(关键码)，则定义为最小堆。</p><h3 id="偏序树插入和删除算法"><a href="#偏序树插入和删除算法" class="headerlink" title="偏序树插入和删除算法"></a>偏序树插入和删除算法</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><strong>最大堆调整示例</strong></p><ul><li><p>插入操作</p><ol><li>元素放置到队尾( 队尾插入 )</li><li>与父节点比较. 如果大于父节点, 则两者交换, 否则插入完成</li><li>重复第2步, 父节点为空时, 插入完成</li></ol></li><li><p>删除操作</p><ol><li>交换根节点和尾节点后, 删除尾节点</li><li>调整偏序树:  从根节点作为父节点开始. 如果父节点小于子节点, 将父节点与子节点中最大的一个交换. </li><li>父节点设为交换后的子节点, 重复第2步. 如果子节点为空, 或者子节点均小于父节点, 调整完成.</li></ol></li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>略</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>最小权值</p><h3 id="构造哈夫曼树的哈夫曼算法"><a href="#构造哈夫曼树的哈夫曼算法" class="headerlink" title="构造哈夫曼树的哈夫曼算法"></a>构造哈夫曼树的哈夫曼算法</h3><ol><li>根据给定的n个权值{w1，w2，…,wn}, 构成n棵二叉树的集合(森林）F={T1,T2,….,Tn },其中每棵二叉树Ti中只有带权为wi的根结点,其左右子树均空。</li><li>在F中选取两棵根结点的权值最小的树作为左右子树(左小右大)构造一棵新的二叉树,且置新的二叉树的根结点的权值为其左、右子树根结点的权值之和。</li><li>在F中删除这两棵树,同时将新的二叉树加入F中。</li><li>重复 2 和 3 , 直到F只含一棵树为止.这棵树便是哈夫曼树。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>略</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ul><li><p>图的定义<br>图是由顶点集合(vertex)及顶点间的关系集合组成的一种数据结构：<br>$$G＝( V, E )$$<br>其中    V = { x | x ∈ 某个数据对象}是顶点的有穷非空集合}；<br>无向图: $$E = {(x, y) | x, y ∈  V }$$<br>或<br>有向图: $$E = {&lt;x, y&gt; | x, y ∈  V,  Path (x, y)}$$<br>顶点之间关系的有穷集合(可以为空)，也叫做边(edge)集合。$$Path (x, y)$$表示从 x 到 y 的一条单向通路, 它是有方向的。</p></li><li><p>有向图(directed graph)</p><blockquote><p>有向图(Directed graph)G是由两个集合 V(G)和E(G)组成。<br>  其中：V(G)是顶点的非空有限集，E(G)是有向边(也称弧)的有限集合，弧是顶点的有序对，记为&lt;v,w&gt;， v为弧的起点，w为弧头的终点, 注意&lt;v,w&gt;≠&lt;w,v&gt;。</p></blockquote></li><li><p>无向图(undirected graph)</p><blockquote><p>无向图(Undirected graph)G是由两个集合V(G)和E(G)组成</p></blockquote></li><li><p>完全图<br>  n个顶点的无向图拥有n(n-1)/2个节点, 即为完全图</p></li></ul><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul><li>对由n个记录组成的表(或文件)L=(r1,r2,…….,rn)，依据记录中某个数据项的值重新进行排列的过程称之为<strong>排序（sorting）</strong>，该数据项称为排序码，一般情况下， 总是选择记录的关键码(字)作为排序码。</li><li>如果待排序的表中含有多个排序码值相等的记录，用某种排序方法排序后，这些记录的相对次序不变，则说这种排序方法为稳定的（stable），否则是不稳定的。</li><li>按照待排序数据驻留的介质不同排序问题可分为内部排序(Internal sorting)和外部排序(External sorting)两类：<ol><li>内排序:  待排序的表中记录可存放内存，整个排序过程都在内存进行，只涉及对内存的访问。</li><li>外排序:   待排序的表中含有巨量记录，无法存放到内存，整个排序过程都在外存进行，涉及对外存的访问。</li></ol></li><li>按照排序的依据原则内部排序可分为：插入排序、交换排序、选择排序、归并排序和分配排序等五类。</li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>顾名思义<br>最好的情况是已经排好序:O(n), 最坏的情况是:O(n*n)<br>该排序是<strong>稳定排序</strong></p><blockquote><p>请注意, 插入排序有大量的插入操作, 使用链表较为适宜</p></blockquote><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>循环将数插入到已经排序的序列中, 知道未排序数组为空</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> LMAX = <span class="number">10</span>; <span class="comment">//顺序表最大长度</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectype</span>        //记录类型定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    keytype key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqList</span> //顺序表类型定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    rectype r[LMAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span> <span class="comment">//直接插入排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[<span class="number">0</span>] = L.r[i]; <span class="comment">//将第i个记录复制到L.r[0]中</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//依次后移</span></span><br><span class="line">        <span class="keyword">while</span> (L.r[<span class="number">0</span>].key &lt; L.r[j].key)</span><br><span class="line">        &#123;</span><br><span class="line">            L.r[j + <span class="number">1</span>] = L.r[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入待排序数</span></span><br><span class="line">        L.r[j + <span class="number">1</span>] = L.r[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>复杂度为O(n*n), 如果已经有序, 则 复杂度为O(0)<br>该排序是<strong>稳定排序</strong></p><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>对于具有n个元素的数组, 进行n-1 次遍历<br>第 k 次遍历过程, 如果发现某元素小于元素[k-1], 交换两者.<br>最终实现: 最小的数放在队头, 第二小的数放在第二个……..</p><p>排序完成</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>又叫递减增量排序</p><blockquote><p><del>希尔排序听起来总让我想起崩坏学园</del><br><del>所以我钦点了<em>希尔 · 爱乐芙</em> 作为本篇博文置顶图23333</del></p></blockquote><p>希尔排序的性能大约为:O(n^3/2^), 这主要是因为他的递减增量<br>希尔排序是<strong>不稳定的</strong></p><h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>取某一增量d; 将数列按照增量d 分成若干组;</li><li>对若干组进行插入排序</li><li>降低增量d, 重复1, 2步骤直到d为1;</li></ol><h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> increment = L.length;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">increment /= <span class="number">2</span></span><br><span class="line"><span class="comment">//执行插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = increment; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">rectype extra = L.r[i];</span><br><span class="line"><span class="keyword">int</span> j = i - increment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; (extra.key &lt; L.r[j].key))</span><br><span class="line">&#123;</span><br><span class="line">L.r[j + increment] = L.r[j];</span><br><span class="line">j = j - increment;</span><br><span class="line">&#125;</span><br><span class="line">L.r[j + increment] = extra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (increment &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序(Quick sort)</strong> 的基本思想是选取被排序表中某个关键码作为基准(pivot)，将表划分成左右两个子表： 左子表中各记录的关键码均小于或等于基准值，而右子表中各记录的关键码均大于或等于基准值。然后以同样的方法递归地处理这两个子表，直到完成全部记录的排序。<br>该排序是<strong>不稳定排序</strong></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>对含有n个记录的表，若算法总是以子表中间记录的关键码作为基准划分,最坏的情况(基准为最小或最大)是每次将将表分为含1个记录的子表和含n-1个记录的子表。需划分n次，比较次数为：<br><strong>n*(n-1)/2=O(n^2^)</strong></p><p>若总是以子表的第一个记录的关键码作为基准划分,  当被排序的表是按关键码有序或逆序，将出现最坏的情况。设c(n)为用QuickSort算法对含有n个记录的表进行排序所作的比较次数, s(n)为交换次数，显然c(1)=0和s(1)=0。 算法将n个记录的表划分为r记录和n-r记录两个子表需比较n次。所以<br>​          c(n)=n+c(r)+c(n-r)<br>对于最坏情形:每次划分时r=1,  n-r=n-1, 则有:<br>​          c(n)=n+c(1)+c(n-1)=n+c(n-1)<br>于是下列诸式成立:<br>​          c(1)=0<br>​          c(2)=2+c(1)=2<br>​          c(3)=3+c(2)=3+2=5<br>​          c(4)=4+c(3)=4+3+2=9<br>​          ……..<br>​          c(n)=n+c(n-1)=n+(n-1)+(n-2)+….+3+2=(n+2)(n-1)/2<br>​           =(n2+n-2)/2=O(n2)</p><p>若 QuickSort 算法总是以表中关键码的中值作为基准划分,将出现最好的情况：每次将表分为两个长度大致相等的子表。<br>​         c(n)≤n+2c(n/2)<br>​                 ≤n+2[n/2+2c(n/22)]=2n+4c(n/22)<br>​                 ≤2n+4[n/4+2c(n/23)]=3n+8c(n/23)<br>​                 ≤……..<br>​                 ≤kn+2kc(n/2k)=nlog2n+nc(1)=O(nlog2n)<br>​          (这里：k=log2n )<br>对于交换次数, 有<br>$$ s(n)&lt;=O(nlog_2n) $$</p><p>快速排序是<strong>不稳定的</strong></p><h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = low;</span><br><span class="line">    <span class="keyword">int</span> last = high;</span><br><span class="line">    <span class="keyword">int</span> key = a[first];<span class="comment">/*用字表的第一个记录作为枢轴*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(first &lt; last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; a[last] &gt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            --last;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        a[first] = a[last];<span class="comment">/*将比第一个小的移到低端*/</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; a[first] &lt;= key)</span><br><span class="line">        &#123;</span><br><span class="line">            ++first;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        a[last] = a[first];    </span><br><span class="line"><span class="comment">/*将比第一个大的移到高端*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[first] = key;<span class="comment">/*枢轴记录到位*/</span></span><br><span class="line">    Qsort(a, low, first<span class="number">-1</span>);</span><br><span class="line">    Qsort(a, first+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>归并排序（merge sort）</strong>是归并操作上的一种有效的排序算法<br>归并排序每次都是在相邻的数据中进行操作，在O(N*logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。</p><blockquote><p>设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。</p></blockquote><h3 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h3><p>对于整体无序的数列</p><ol><li>递归(recursion)分割数列为左右两部分, 直至数列不可再分</li><li>对当前不可再分的左右数列进行归并</li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> front, <span class="keyword">int</span> mid, <span class="keyword">int</span> rear, <span class="keyword">int</span> temp[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = front, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= rear)</span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[front + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursive</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> front, <span class="keyword">int</span> rear, <span class="keyword">int</span> temp[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (front&lt;rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (front + rear) / <span class="number">2</span>;</span><br><span class="line">recursive(arr, front, mid, temp);</span><br><span class="line">recursive(arr, mid + <span class="number">1</span>, rear, temp);</span><br><span class="line">merge(arr, front, mid, rear, temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//辅助表空间, 避免数列数组被覆写, 省去临时声明空间的时间开销</span></span><br><span class="line"><span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">recursive(arr, <span class="number">0</span>, n - <span class="number">1</span>, temp);</span><br><span class="line"><span class="keyword">delete</span>[] temp;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">8</span>] = &#123; <span class="number">12</span>,<span class="number">12</span>,<span class="number">123</span>,<span class="number">45</span>,<span class="number">654</span>,<span class="number">78</span>,<span class="number">96</span>,<span class="number">2</span> &#125;;</span><br><span class="line">mergeSort(arr, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是利用堆这种数据结构而设计的一种排序算法，它是一种<strong>选择排序</strong>.<br>它的最坏，最好，平均时间复杂度均为<strong>O(nlogn)</strong>，它也是<strong>不稳定排序</strong>.</p><h3 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li><p>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p></li><li><p>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p></li><li><p>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p></li></ol><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> front, <span class="keyword">int</span> rear)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>tmp = arr[front];</span><br><span class="line">arr[front] = arr[rear];</span><br><span class="line">arr[rear] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; len; k = k * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((k + <span class="number">1</span>) &lt; len&amp;&amp;arr[k] &lt; arr[k + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr[k] &gt; temp)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = arr[k];</span><br><span class="line">i = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 构建大顶堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">adjustHeap(arr, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 交换堆顶元素和末尾元素, 调整堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">swap(arr, <span class="number">0</span>, i);</span><br><span class="line">adjustHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">8</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">45</span>,<span class="number">65</span>,<span class="number">78</span>,<span class="number">98</span>,<span class="number">45</span>,<span class="number">32</span> &#125;;</span><br><span class="line">sort(arr, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><strong>基数排序 (radix sort) </strong>属于”分配式排序”  (distribution sort) , 重点在于对关键字进行 “分配” 和 “收集” , 而不是对关键字的比较.<br>基数排序算法是<strong>稳定</strong>的, 时间复杂度是O(d*(n＋r))</p><blockquote><p>将表中n个记录分配到r个队列中去的时间为O(n), 收集时将r个队列连成一个表的时间O(r), 一次分配和收集的时间为O(n＋r), 由于算法对n个记录共进行了d遍分配和收集,所以共花费的时间为O(d*(n＋r)).</p></blockquote><h3 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>将关键码按照位数最小/最大值分配入箱</li><li>按照箱子的顺序收集关键码</li><li>重复1，2步骤直到位数到达最大/最小值</li></ol><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>最高位优先(Most Significant Digit first)，简称MSD<br>最低位优先(Least Significant Digit first)，简称LSD<br>下面采用LSD法，值得一提的是，这种实现比较耗费内存, 从理论上来说, 申请的数组空间利用率只有10%.<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序数组实现*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> RADIX = <span class="number">10</span>;<span class="comment">//桶数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">10</span>;<span class="comment">//桶容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> src, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">temp *= <span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> (src / temp) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort_Array</span><span class="params">(<span class="keyword">int</span> *src, <span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* tempArray[RADIX];<span class="comment">//定义桶数 RADIX</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RADIX; ++i)<span class="comment">//定义桶容量</span></span><br><span class="line">&#123;</span><br><span class="line">tempArray[i] = <span class="keyword">new</span> <span class="keyword">int</span> [Max + <span class="number">1</span>];</span><br><span class="line">tempArray[i][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始化为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pos = <span class="number">1</span>; pos &lt;= digits; ++pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Max; ++i)<span class="comment">//分配进桶</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = getDigit(src[i], pos);<span class="comment">//获取指定位的数字</span></span><br><span class="line">++tempArray[tmp][<span class="number">0</span>];</span><br><span class="line">tempArray[tmp][tempArray[tmp][<span class="number">0</span>]] = src[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;RADIX; ++i)<span class="comment">//收集</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=tempArray[i][<span class="number">0</span>]; ++j )</span><br><span class="line">&#123;</span><br><span class="line">src[index++] = tempArray[i][j];</span><br><span class="line">&#125;</span><br><span class="line">tempArray[i][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//重置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Max; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; src[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> src[Max] = &#123; <span class="number">12</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">14</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">56</span>,<span class="number">12</span>,<span class="number">456</span>,<span class="number">789</span> &#125;;</span><br><span class="line"><span class="comment">/*std::cout &lt;&lt; "最大三位数" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">for (RADIX_t i = 0; i &lt; Max; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">std::cin &gt;&gt; src[i];</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Max; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; src[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">radixSort_Array(src, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Max; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; src[i]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><p>查找操作的性能主要考虑时间复杂度, 整个查找过程主要是在关键字和查找表的数据上. 即平均查找长度.<br><strong>平均查找长度ASL(Average Search Length)</strong>：为确定记录在表中的位置，需和给定值进行比较的记录个数的期望值叫查找算法的平均查找长度。</p><p>$$ ASL=\sum_{n}^{i=1}p_{i}c_{i} ​$$</p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul><li>对于每次查找均成功的情况下<br>$$ ASL=\frac{n+1}{2}$$</li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>通过建立一个二叉查找树, 我们能很清晰的看到<br>$$ ASL=log~2~(n+1)-1</p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>分块查找，也叫索引顺序查找，算法实现除了需要查找表本身之外，还需要根据查找表建立一个索引表<br>建立的索引表要求按照关键字进行升序排序，查找表要么整体有序，要么分块有序</p><blockquote><p>分块有序指的是第二个子表中所有关键字都要大于第一个子表中的最大关键字，第三个子表的所有关键字都要大于第二个子表中的最大关键字，依次类推。</p></blockquote><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>分块查找分为两个过程:</p><ol><li>查找快<br>可以采用顺序查找, 也可以采用折半查找</li><li>块内查找<br>采用顺序查找</li></ol><blockquote><p>总体而言, 分块查找效率介于顺序查找和折半查找之间</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;i&gt;谨以此文, 纪念我没怎么听过的数据结构&lt;/i&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;img src=&quot;http://i0.hdslb.com/bfs/archive/4c9309085933d7cee42218ca647f01f1ca7b46ac.jpg&quot; alt=&quot;希尔——崩坏三&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Human Learning" scheme="https://zlee.xyz/categories/Human-Learning/"/>
    
    
      <category term="Note" scheme="https://zlee.xyz/tags/Note/"/>
    
      <category term="Hobby" scheme="https://zlee.xyz/tags/Hobby/"/>
    
  </entry>
  
  <entry>
    <title>Tutorial For Hexo</title>
    <link href="https://zlee.xyz/2018/12/12/Simple-Tutorial-For-Hexo/"/>
    <id>https://zlee.xyz/2018/12/12/Simple-Tutorial-For-Hexo/</id>
    <published>2018-12-12T12:47:25.000Z</published>
    <updated>2019-05-16T08:56:37.062Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。Hexo同时也是GitHub上的开源项目，如果想要更加全面的了解Hexo，可以到其官网 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，你可以查阅到优质的中文文档.</p></blockquote><a id="more"></a><h2 id="Hexo基础"><a href="#Hexo基础" class="headerlink" title="Hexo基础"></a>Hexo基础</h2><p>基于Github pages 的静态博客所必须的步骤</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>提供了一个免费账户, 这对于我们来说可以很方便的搭建静态博客, 当然, 这也是本篇的目标. </p><ol><li>登录到GitHub, 如果没有GitHub帐号，使用你的邮箱注册GitHub帐号. </li><li>点击GitHub中的New repository创建新仓库，仓库名应该为：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名<span class="selector-class">.github</span><span class="selector-class">.io</span></span><br></pre></td></tr></table></figure></div><p>用户名请使用你的GitHub帐号名称代替. 这是固定写法，比如我的仓库名为:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnesium12<span class="selector-class">.github</span><span class="selector-class">.io</span></span><br></pre></td></tr></table></figure></div></p><h3 id="安装Git-amp-Node-js"><a href="#安装Git-amp-Node-js" class="headerlink" title="安装Git&amp;Node.js"></a>安装Git&amp;Node.js</h3><p>在安装前，你必须检查电脑中是否已安装下列应用程序：</p><ul><li>Node.js</li><li>Git  </li></ul><blockquote><p><strong> Windows 用户 </strong></p><p>如果你的电脑中尚未安装所需要的程序，请到官网下载Node.js &amp; Git的安装程序进行安装.<br>注意安装Node.js时注意勾选<strong>Add to PATH</strong>选项, 这将使得Node.js添加到你的计算机环境变量中.<br>Git安装完成后，右键菜单会出现git bash, 我们所有的命令都需要在git bash中执行,.</p></blockquote><p>下载Git可能会有些慢, 请耐心等待或者自行寻找过其他源. </p><h3 id="配置SSH免密访问"><a href="#配置SSH免密访问" class="headerlink" title="配置SSH免密访问"></a>配置SSH免密访问</h3><ol><li>本地安装 Git</li></ol><p>我本地是Windows，采用 git-bash. 如果你是新手的话, 在安装过程中只要一路next就OK</p><ol start="2"><li>配置本地免密ssh远程登陆</li></ol><p>在本地写作的机器上，搜索Git Bash，设置user.name和user.email配置信息：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"你的GitHub用户名"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure></div></p><ol start="3"><li>生成ssh密钥文件</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure></div><p>一路回车，<code>~/.ssh/</code>目录下会生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件。</p><ol><li>打开GitHub_Settings_keys 页面，新建new SSH Key</li></ol><p>Title为标题，任意填即可，将刚刚复制的<code>id_rsa.pub</code>内容粘贴进去，最后点击Add SSH key.<br>在Git Bash中检测GitHub公钥设置是否成功，输入<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​<span class="selector-tag">ssh</span> <span class="selector-tag">git</span>@<span class="keyword">github</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure></div></p><ul><li>如果是第一次链接的话, 可能会询问是否创建<code>known_hosts</code>文件, 这当然是<code>yes</code></li></ul><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>如果你的电脑中已经安装上述必备程序，那么恭喜你！接下来只需使用 npm 即可完成 Hexo 的安装。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AVRASM"><figure class="iseeu highlight /avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure></div><p>Hexo安装完成后, 输入以下命令并执行</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure></div><p>请注意, <code>&lt;folder&gt;</code>是你指定的文件夹路径, 并且该文件夹必须为空. <code>&lt;`</code>&gt;`是特殊字符, 命令端输入时应当去除, 例如</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CMAKE"><figure class="iseeu highlight /cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init /d/<span class="keyword">Project</span>/Hexo</span><br><span class="line">cd /d/<span class="keyword">Project</span>/Hexo</span><br><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure></div><p>或者直接打开Hexo文件夹, 右键git bash, 输入<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EBNF"><figure class="iseeu highlight /ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure></div></p><p>如果你看到<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLEAN"><figure class="iseeu highlight /clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO Start blogging <span class="keyword">with</span> Hexo!`</span><br></pre></td></tr></table></figure></div></p><p>这意味着本地建站已完成, congratulations!你已经到达新手村. </p><h3 id="站点结构"><a href="#站点结构" class="headerlink" title="站点结构"></a>站点结构</h3><p>新建完成后, 本地hexo站点结构如下</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQF"><figure class="iseeu highlight /sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="variable">_config</span>.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── <span class="variable">_drafts</span></span><br><span class="line">|   └── <span class="variable">_posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></div><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的配置信息, 你可以在这里选择配置大部分参数, 我们称为<code>站点配置文件</code>.</p><ul><li>可以设定主题, 网站标题, 副标题, author etc. 详情请阅读.md文档</li></ul><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>应用程序的信息. </p><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p>模板文件夹, Hexo会根据<code>scaffolds</code>来建立文件. Hexo的模板是指在新建的markdown文件中默认填充的内容. 例如, 如果您修改scaffold/post.md中的Front-matter内容, 那么每次新建一篇文章时都会包含这个修改.</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方. 除<code>_posts</code> 文件夹之外, 开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略. Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹, 而其他文件会被拷贝过去. </p><blockquote><p>发布的博文存储在/public/</p></blockquote><h4 id="theme"><a href="#theme" class="headerlink" title="theme"></a>theme</h4><p>主题 文件夹。Hexo 会根据主题来生成静态页面</p><ul><li>存在默认主题, 但还是请选择一个你喜欢的主题, it does matter.</li><li>主题文件夹内会有<code>_config.yml</code>配置文件, 我们称为<strong>主题配置文件</strong></li></ul><h3 id="Hexo常用指令"><a href="#Hexo常用指令" class="headerlink" title="Hexo常用指令"></a>Hexo常用指令</h3><p>**请注意, 这些操作必须在<code>../hexo/</code>目录下进行</p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACCESSLOG"><figure class="iseeu highlight /accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init <span class="string">[folder]</span></span><br></pre></td></tr></table></figure></div><p>新建一个网站。如果没有设置 folder , Hexo 默认在目前的文件夹建立网站. </p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo new [layout] &lt;title&gt;</span><br><span class="line"><span class="variable">$ </span>hexo n <span class="string">"article"</span></span><br></pre></td></tr></table></figure></div><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VERILOG"><figure class="iseeu highlight /verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">generate</span></span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></div><p>生成静态文件</p><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo deploy</span><br><span class="line"><span class="variable">$ </span>hexo d</span><br></pre></td></tr></table></figure></div><p>文件生成后立即部署网站</p><h4 id="generate-1"><a href="#generate-1" class="headerlink" title="generate"></a>generate</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo gengerate</span><br><span class="line"><span class="variable">$ </span>hexo g</span><br></pre></td></tr></table></figure></div><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLEAN"><figure class="iseeu highlight /clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s</span><br><span class="line">```</span><br><span class="line">启动服务器。默认情况下，访问网址为： http:<span class="comment">//localhost:4000/ . 如果需要修改,</span></span><br></pre></td></tr></table></figure></div><p>$ hexo sever -p 5000 #更改端口至5000<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLEAN"><figure class="iseeu highlight /clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### clean</span><br></pre></td></tr></table></figure></div></p><p>$ hexo clean<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLEAN"><figure class="iseeu highlight /clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span><br><span class="line">在某些情况（尤其是更换主题后）, 如果发现您对站点的更改无论如何也不生效, 您可能需要运行该命令.</span><br><span class="line"></span><br><span class="line">### 发布网站</span><br><span class="line">如果你已经迫不及待地打开在hexo 目录下打开Git bash</span><br></pre></td></tr></table></figure></div></p><p>hexo g<br>hexo s<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在http:<span class="comment">//localhost:4000 你将预览到自己的博客, 但是别人是看不到的, 毕竟一般情况下别人不能看到你的计算机的本地内容. **Github pages**可以帮助我们解决这个问题. </span></span><br><span class="line"></span><br><span class="line">下一步把GitHub和我们的Hexo关联起来, 打开站点的\_config<span class="selector-class">.yml</span>, 找到</span><br></pre></td></tr></table></figure></div></p><p>deploy:<br>  type:<br>  repo:<br>  branch:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight /makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">修改如下:</span></span><br></pre></td></tr></table></figure></div></p><p>deploy:<br>  type: git</p><p>  #创建仓库的完整路径, 末尾记得加.git<br>  repo: <a href="https://github.com/Magnesium12/magnesium12.github.io.git" target="_blank" rel="noopener">https://github.com/Magnesium12/magnesium12.github.io.git</a><br>  branch: master<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把<span class="keyword">blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。</span></span><br><span class="line"><span class="keyword">最后安装Git部署插件, </span>输入命令:</span><br></pre></td></tr></table></figure></div></p><p>npm install hexo-deployer-git –save<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight /makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">现在我们输入:</span></span><br></pre></td></tr></table></figure></div></p><p>hexo clean<br>hexo g<br>hexo d<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLEAN"><figure class="iseeu highlight /clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在浏览器中输入: xxxx. github.io</span><br><span class="line"></span><br><span class="line">你会发现这时你的博客已经上线,</span><br><span class="line"></span><br><span class="line">Congratulations! </span><br><span class="line"></span><br><span class="line">**Now. Sharing  the fantasy <span class="keyword">of</span> your own to the world. **</span><br><span class="line"></span><br><span class="line">##  Hexo进阶</span><br><span class="line"></span><br><span class="line">### NexT相关</span><br><span class="line"></span><br><span class="line">注意到<span class="number">6.</span>x版本next仓库的变动, 需要下载最新版本的同学请选择</span><br></pre></td></tr></table></figure></div></p><p>cd hexo<br>git clone <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a> themes/next<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之后跟进更新</span><br></pre></td></tr></table></figure></div></p><p>cd theme/next<br>git pull<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果是从v5.x升级到v6.x, 请另行参阅[<span class="string">这篇文档</span>](<span class="link">https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 主题配置</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>打开\_config.yml 文件</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>阅读 README.md</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>依照字面意思来配置</span><br><span class="line"></span><br><span class="line"><span class="section">## 常见问题</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*眼睛不需要的话, 可以捐给其他人.    by 鲁迅*</span></span><br><span class="line"></span><br><span class="line"><span class="section">### .swig</span></span><br></pre></td></tr></table></figure></div></p><p>Unhandled rejection Error: ENOENT: no such file or directory, open ‘D:\Project\Hexo\themes\next\layout_scripts\schemes.swig’<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLEAN"><figure class="iseeu highlight /clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NexT使用版本:  <span class="number">5.1</span><span class="number">.4</span></span><br><span class="line">原因：social加入链接时, #social: 这一行没有把注释打开.....</span><br><span class="line"></span><br><span class="line">### 怎么写博客</span><br><span class="line"></span><br><span class="line">- 请bing一下markdown.</span><br><span class="line">- 此外, 推荐**VS Code**作为你的博客项目管理工具.</span><br><span class="line">- 推荐**Typora**作为你写markdown的书写工具.</span><br><span class="line"></span><br><span class="line">### 语言设定</span><br><span class="line"></span><br><span class="line">请修改站点文件, zh-CN意味着站点语言默认为中文</span><br></pre></td></tr></table></figure></div></p><p>language: zh-CN<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLEAN"><figure class="iseeu highlight /clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 标签&amp;分类</span><br><span class="line"></span><br><span class="line">进入hexo文件夹</span><br></pre></td></tr></table></figure></div></p><p>hexo new page “tags”<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VIM"><figure class="iseeu highlight /vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意已生成<span class="keyword">source</span>/<span class="keyword">tags</span>/<span class="built_in">index</span>.md,  <span class="built_in">index</span>.md中修改如下</span><br></pre></td></tr></table></figure></div></p><hr><p>title: categories<br>date: 2016-11-15 19:11:13</p><h2 id="type-“tags”"><a href="#type-“tags”" class="headerlink" title="type: “tags”"></a>type: “tags”</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当你试图为你的文章添加标签时, 请在文章头部添加</span><br></pre></td></tr></table></figure></div><hr><p>title: 基于Hexo和Github搭建博客<br>date: 2018-12-14</p><h2 id="tags-npm-hexo-github"><a href="#tags-npm-hexo-github" class="headerlink" title="tags: [npm, hexo, github]"></a>tags: [npm, hexo, github]</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLEAN"><figure class="iseeu highlight /clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories 分类 如上</span><br><span class="line"></span><br><span class="line">### hexo d 出错</span><br></pre></td></tr></table></figure></div><p>$ hexo d<br>ERROR Deployer not found: git<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight /makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">解决方案: 最新的hexo版本，必须执行</span></span><br></pre></td></tr></table></figure></div></p><p>npm install –save hexo-deployer-git<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。Hexo同时也是GitHub上的开源项目，如果想要更加全面的了解Hexo，可以到其官网 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，你可以查阅到优质的中文文档.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://zlee.xyz/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://zlee.xyz/tags/Hexo/"/>
    
      <category term="Tutorial" scheme="https://zlee.xyz/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫（三）：从JSON解决Ajax</title>
    <link href="https://zlee.xyz/2018/12/07/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%88%AC%E5%8F%96js%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/"/>
    <id>https://zlee.xyz/2018/12/07/Python爬虫（三）：爬取js动态网页/</id>
    <published>2018-12-07T15:34:54.000Z</published>
    <updated>2019-05-16T09:00:48.585Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>上一篇博文中, 笔者采用了selenium驱动chrome来抓取网页, 总结来看及其低效…..</li><li>想了一下, 不能这样搞, 他要刷新局部界面肯定是要利用JavaScript调用已经写好的json的. 通常来说不会有前端选择瞎搞地址. 如果能观察出那个json的地址特点, 就到了ButifulSoup为所欲为的时间辣(●’◡’●)</li><li>对于json参数偏移量不规律的网页,那当然是 <del>直接打死</del> ,哦不, <em>仔细观察</em>. 对于一个正常的前端同学来说, 不规律的json只可能是有限的, <del>我不做人啦,jojo!</del>. 我们只要把有限的偏移量写成一个字典(dic)就大功告成</li></ul></blockquote><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>Chrome浏览器</li><li>Python3.7</li><li>requests, BeautifulSoup4模块</li><li>一点点耐心以及正常的视力</li></ul><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ul><li>chrome浏览器打开目标网页, </li><li>检查元素   <del>F12, CTRL+ shift+i, CTRL+shift+c爱用那个用哪个</del></li><li><p>继续加载内容，注意观察network栏下的xhr文件</p></li><li><p>很明显，那个since=就是我们要找的<br>*点击展开，根据 Query string 构造parameter参数字典</p></li><li><p>requests 负责请求，bs4 为所欲为</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">json_url = <span class="string">'https://富强民主文明和谐'</span></span><br><span class="line"><span class="comment">#无规则偏移量，自行逆向分析得到偏移量字典</span></span><br><span class="line">since_list = [<span class="number">26961.554</span>, <span class="number">26961.474</span>, <span class="number">26961.419</span>, <span class="number">26961.346</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#实现提取json，加载动态内容，但是封装性不好，不能重复利用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMorePages</span><span class="params">(list,count=<span class="number">1</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    params_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        keyword=str(list[i])</span><br><span class="line">        params_list.append(&#123;</span><br><span class="line">            <span class="string">'since'</span>: keyword,</span><br><span class="line">            <span class="string">'grid_type'</span>: <span class="string">'flow'</span>,</span><br><span class="line">            <span class="string">'sort'</span>: <span class="string">'hot'</span>,</span><br><span class="line">            <span class="string">'tag_id'</span>: <span class="string">'399'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    url = json_url</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> params_list:</span><br><span class="line">        req=requests.get(url, params=i).content</span><br><span class="line">        soup=BeautifulSoup(req,<span class="string">'lxml'</span>)</span><br><span class="line">        getURL(soup)</span><br></pre></td></tr></table></figure></div><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>很显然，这样做效率会高很多  <del>发现json规律成为了木桶的最短板</del>，为了避免那个网站被薅羊毛，我就手动屏蔽惹OTZ……<br>另外，代码只放入了相关的一部分，有兴趣的同学可以尝试结合上一篇，整合功能鸭~<br>Good night！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;上一篇博文中, 笔者采用了selenium驱动chrome来抓取网页, 总结来看及其低效…..&lt;/li&gt;
&lt;li&gt;想了一下, 不能这样搞, 他要刷新局部界面肯定是要利用JavaScript调用已经写好的json的. 通常来说不会有前端选择瞎搞地址. 如果能观察出那个json的地址特点, 就到了ButifulSoup为所欲为的时间辣(●’◡’●)&lt;/li&gt;
&lt;li&gt;对于json参数偏移量不规律的网页,那当然是 &lt;del&gt;直接打死&lt;/del&gt; ,哦不, &lt;em&gt;仔细观察&lt;/em&gt;. 对于一个正常的前端同学来说, 不规律的json只可能是有限的, &lt;del&gt;我不做人啦,jojo!&lt;/del&gt;. 我们只要把有限的偏移量写成一个字典(dic)就大功告成&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://zlee.xyz/categories/Python/"/>
    
    
      <category term="Web Crawler" scheme="https://zlee.xyz/tags/Web-Crawler/"/>
    
  </entry>
  
  <entry>
    <title>A LETTER</title>
    <link href="https://zlee.xyz/2018/12/03/%E6%AD%8C%E6%9B%B2%E6%8E%A8%E8%8D%90The-Song-For-You/"/>
    <id>https://zlee.xyz/2018/12/03/歌曲推荐The-Song-For-You/</id>
    <published>2018-12-03T10:45:27.000Z</published>
    <updated>2019-05-16T09:05:47.688Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/12/03/5c05272799b4b.jpg" alt="午夜"></p><blockquote class="blockquote-center"><i> You don’t have to throw your life away </i></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=499027&auto=1&height=66"></iframe><p><em>本来也不想写文字，但是不写一点文字,又怎么知道当时所思所想是什么，自己又是为什么要去写这篇博文呢?</em></p><p>……</p><p> <em>A LETTER</em> 是由<a href="https://zh.moegirl.org/%E6%B3%BD%E9%87%8E%E5%BC%98%E4%B9%8B" target="_blank" rel="noopener">泽野弘之</a><br>创作的插曲——也许提及<em>高达UC</em>会让他更容易被想起.</p><p>歌姬Cyua确实很适合去唱这首歌, 她的声线与舒缓空旷的乐音彼此交融, 编织出这首弥漫着伤感, 空灵以及希望的歌曲. 倘若你愿意闭上双眸, 浮现出的场景大概会是独角兽在孤独地进行着只属于自己的宇宙漫途, 但或许你需要知道的是, 这首歌曲更多在表达的是对自己的鼓励和对未来的希冀.</p><p>每个人都是宇宙中的独角兽, 命运指定的航线终将我们彼此分离, 忙碌追赶又有什么意义呢？命运的轨迹充满了错误,  等待我们的会是痛苦, 遗憾, 还是……希望?</p><p>指向正确的道路或许很艰辛, 可是总有一天能够到达尽头. </p><p><em>Now you see light in pain.</em></p><p><strong>Kevin .</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/03/5c05272799b4b.jpg&quot; alt=&quot;午夜&quot;&gt;&lt;/p&gt;
&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;i&gt; You don’t have to throw your life away &lt;/i&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Thought" scheme="https://zlee.xyz/categories/Thought/"/>
    
    
      <category term="Unknown" scheme="https://zlee.xyz/tags/Unknown/"/>
    
      <category term="Recommend" scheme="https://zlee.xyz/tags/Recommend/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫（二）：Selenium + ChromeDriver 解决异步加载</title>
    <link href="https://zlee.xyz/2018/12/01/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASelenium%20+%20ChromeDriver%20%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <id>https://zlee.xyz/2018/12/01/Python爬虫（二）：Selenium + ChromeDriver 解决异步加载/</id>
    <published>2018-12-01T02:16:50.000Z</published>
    <updated>2019-05-16T09:00:52.883Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>在上一篇博文中, python代码趋向于平铺直叙——或者说代码习惯十分不好, 稍微复杂点的功能都会举步维艰</li><li>对于选择使用js控制加载网页结构的网站, 以urllib为基础的python库来说无法<del>直接</del>解决这个问题，例如爬取下拉刷新的网页：”<a href="https://bcy.net/coser&quot;" target="_blank" rel="noopener">https://bcy.net/coser&quot;</a></li><li>但是事在人为, 对于笔者这个小白来说还是有<del>傻瓜式</del>替代解决思路的, 虽然很慢==</li></ul></blockquote><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>默认看过<a href="https://zlee.xyz/2018/12/01/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARequests&amp;BS4%20%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/">Python爬虫（一）：Requests&amp;BS4 爬虫实例</a></li><li>预装模块: requests, selenium, bs4, os</li><li>下载<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">chromedriver</a></li></ul><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ul><li>bs4+selenium+chromedriver <del>强行爆破</del> 模拟点击行为获取完全加载的html</li><li><del>然后用beautifulsoup为所欲为</del><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># **************************Declaration**************************</span></span><br><span class="line"><span class="comment"># @File name:        Crawler</span></span><br><span class="line"><span class="comment"># @Function:         requests+selenium+chromedriver</span></span><br><span class="line"><span class="comment"># @Author:           Ogiso Kazusa</span></span><br><span class="line"><span class="comment"># @Date:             2018/11/15</span></span><br><span class="line"><span class="comment"># @Version Number:   2.0</span></span><br><span class="line"><span class="comment"># ******************************end******************************</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment">#常量</span></span><br><span class="line">URL = <span class="string">'https://bcy.net'</span></span><br><span class="line">index_url = <span class="string">'https://bcy.net/coser'</span></span><br><span class="line">CachePath = <span class="string">"D:\\CrawlerCache\\"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#储存CN的键值对, 用于isInDic()</span></span><br><span class="line">dic=&#123;<span class="string">'test'</span>:<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查字典, 判断是否下载过</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isInDic</span><span class="params">(src)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> src <span class="keyword">in</span> dic:</span><br><span class="line">        dic[src] = dic[src] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[src] = <span class="number">0</span></span><br><span class="line">    dst = src + <span class="string">"_"</span> + str(dic[src])</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="comment"># 去除首位空格</span></span><br><span class="line">    path = path.strip()</span><br><span class="line">    <span class="comment"># 去除尾部 \ 符号</span></span><br><span class="line">    path = path.rstrip(<span class="string">"\\"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断路径是否存在</span></span><br><span class="line">    <span class="comment"># 存在     True</span></span><br><span class="line">    <span class="comment"># 不存在   False</span></span><br><span class="line">    isExists = os.path.exists(path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        <span class="comment"># 如果不存在则创建目录</span></span><br><span class="line">        <span class="comment"># 创建目录操作函数</span></span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        print(path + <span class="string">' 创建成功'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果目录存在则不创建，并提示目录已存在</span></span><br><span class="line">        print(path + <span class="string">' 目录已存在'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现图片下载功能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadImg</span><span class="params">(url, name)</span>:</span></span><br><span class="line">    <span class="comment"># 请求url页面内容,此时页面为图床页面,只有图片内容</span></span><br><span class="line">    url = requests.get(url)</span><br><span class="line">    <span class="comment"># 格式和下载位置</span></span><br><span class="line"></span><br><span class="line">    path = CachePath + name + <span class="string">".jpg"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代器和生成器,实现下载</span></span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(url.content)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#驱动chrome,获取加载完全的html</span></span><br><span class="line"><span class="comment">#木桶效应的最短板, 也是本次解决方案的致命点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getJsHtml</span><span class="params">(URL, cosImg)</span>:</span></span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line">    driver.get(URL)</span><br><span class="line">    html = driver.page_source</span><br><span class="line">    driver.close()</span><br><span class="line"></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">    content = soup.find_all(<span class="string">'div'</span>, &#123;<span class="string">"class"</span>: <span class="string">"img-wrap-inner"</span>&#125;)</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> content:</span><br><span class="line">        src = element.find(<span class="string">'img'</span>)[<span class="string">'src'</span>]</span><br><span class="line"></span><br><span class="line">        name=cosImg + <span class="string">'_'</span> + str(i)</span><br><span class="line">        downloadImg(src, name)</span><br><span class="line">        print(<span class="string">"下载进度："</span>,i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定存储目录CachePath,没有则生成</span></span><br><span class="line">mkdir(CachePath)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求页面内容</span></span><br><span class="line">session = requests.get(index_url)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取requests 对象的内容，建议使用content，requests会尝试提供字节数</span></span><br><span class="line">soup = BeautifulSoup(session.content, <span class="string">"lxml"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># find 直接返回值, findall 返回列表(list)</span></span><br><span class="line">index = soup.find_all(<span class="string">'a'</span>, &#123;<span class="string">'class'</span>: <span class="string">"db posr ovf"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> index:</span><br><span class="line">    <span class="comment"># print(element)可以看到</span></span><br><span class="line">    <span class="comment"># 利用标签的父子关系，能够选择标签或者子标签中的属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我们获取cos发布地址</span></span><br><span class="line">    img_url = element[<span class="string">'href'</span>]</span><br><span class="line">    url = URL + img_url</span><br><span class="line"></span><br><span class="line">    <span class="comment"># CN = element.get('title')貌似两种写法均可</span></span><br><span class="line">    CN = element[<span class="string">'title'</span>]</span><br><span class="line">    print(<span class="string">'准备下载：'</span> + CN)</span><br><span class="line">    CN = isInDic(CN)</span><br><span class="line">    getJsHtml(url, CN)</span><br><span class="line"></span><br><span class="line"><span class="comment">#大功告成</span></span><br><span class="line"><span class="comment">#可以考虑指定需要获取的json？</span></span><br></pre></td></tr></table></figure></div><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><ul><li>吐槽一下, 这玩意儿奇慢无比, 调用浏览器中出现了大量不必要的步骤==</li><li>另一种意义上的模拟人类点击机制, <del>慢也有点用?</del>,效率实在太低</li><li>令人头皮发麻，</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在上一篇博文中, python代码趋向于平铺直叙——或者说代码习惯十分不好, 稍微复杂点的功能都会举步维艰&lt;/li&gt;
&lt;li&gt;对于选择使用js控制加载网页结构的网站, 以urllib为基础的python库来说无法&lt;del&gt;直接&lt;/del&gt;解决这个问题，例如爬取下拉刷新的网页：”&lt;a href=&quot;https://bcy.net/coser&amp;quot;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bcy.net/coser&amp;quot;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;但是事在人为, 对于笔者这个小白来说还是有&lt;del&gt;傻瓜式&lt;/del&gt;替代解决思路的, 虽然很慢==&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://zlee.xyz/categories/Python/"/>
    
    
      <category term="Web Crawler" scheme="https://zlee.xyz/tags/Web-Crawler/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫（一）:Requests&amp;BS4 爬虫实例</title>
    <link href="https://zlee.xyz/2018/12/01/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARequests&amp;BS4%20%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/"/>
    <id>https://zlee.xyz/2018/12/01/Python爬虫（一）：Requests&amp;BS4 爬虫实例/</id>
    <published>2018-12-01T02:16:34.000Z</published>
    <updated>2019-05-16T09:00:43.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>这篇文章主要是方便入门爬虫的同学获得入门的正反馈，配合代码注释可能轻松<del>愉悦</del>的对爬虫有个大概了解~</li><li>我们选择对于使用静态网页的小说网站, 小说的文本内容往往分配在一个&lt;div里,  <strong>逻辑比较简单</strong>. </li><li>那就开始吧＜（＾－＾）＞</li></ul></blockquote><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>安装python3.7</li><li>安装requests, BeautifulSoup4(或者说bs4)</li><li>安装chrome浏览器</li><li>掌握Python基础语法 </li></ul><p>可以尝试 <a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Python 3 教程</a> </p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ul><li>请求URL指向的页面-&gt;获取网页内容</li><li>设定筛选条件-&gt;获取指定内容</li><li>写入本地文件</li></ul><h2 id="检查网站代码"><a href="#检查网站代码" class="headerlink" title="检查网站代码"></a>检查网站代码</h2><ul><li><strong>ctrl +shift +c</strong>, 检查网页源代码[^3], 得知章节地址<br><del><em>F12</em></del>, <del><em>ctrl+shift+i</em></del> , <del><em>右键-检查</em></del>, 等等均可</li><li>[^3]:本教程仅供参考, 保护创作者版权, 提倡付费阅读</li></ul><ul><li><p>根据章节地址跳转页面</p></li><li><p>检查章节页面, 得知章节文本内容 </p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># *********************Declaration*********************</span></span><br><span class="line"><span class="comment"># @File name:        WebCrawler</span></span><br><span class="line"><span class="comment"># @Function:         Download Single Novel</span></span><br><span class="line"><span class="comment"># @Author:           Ogiso Kazusa                    </span></span><br><span class="line"><span class="comment"># @Date:             2018/11/14                      </span></span><br><span class="line"><span class="comment"># @Version Number:   1.0    </span></span><br><span class="line"><span class="comment"># *************************end*************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入模块</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment">#小说网页目录地址, 准备遍历全部章节地址</span></span><br><span class="line">index_url=<span class="string">'https://www.88dush.com/xiaoshuo/27/27584/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取页面内容</span></span><br><span class="line">index_req=requests.get(index_url)</span><br><span class="line">index_html=index_req.content</span><br><span class="line">page_main=BeautifulSoup(index_html,<span class="string">"lxml"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建D盘根目录文件“单本下载.txt”，</span></span><br><span class="line"><span class="comment">#格式为ab+:向二进制文件末添加数据，且允许读；</span></span><br><span class="line">fo=open(<span class="string">"D:\\单本下载.txt"</span>,<span class="string">"ab+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取div , class="mulu" 包含的内容</span></span><br><span class="line">chap_BS=page_main.find(<span class="string">"div"</span>,&#123;<span class="string">"class"</span>:<span class="string">"mulu"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成器对象</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> chap_BS.ul.children:</span><br><span class="line">    <span class="keyword">if</span> child!=<span class="string">"\n"</span>:</span><br><span class="line">        <span class="comment">#href：目标url的属性名</span></span><br><span class="line">        chap_url=index_url+child.a.get(<span class="string">"href"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#素质三联，获取lxml文档</span></span><br><span class="line">        chap_req=requests.get(chap_url)</span><br><span class="line">        chap_html=chap_req.content.decode(<span class="string">"gbk"</span>)</span><br><span class="line">        soup_text=BeautifulSoup(chap_html,<span class="string">"lxml"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#寻找div段落，class=yd_text2的属性块内容</span></span><br><span class="line">        chap_text=soup_text.find(<span class="string">"div"</span>，&#123;<span class="string">"class"</span>:<span class="string">"yd_text2"</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#.text指获取文字内容，\r\n是指写入文件中的换行符, ==</span></span><br><span class="line">        fo.write((child.string+ <span class="string">"\r\n"</span>+chap_text.text+<span class="string">"\r\n"</span>).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        print(child.string+<span class="string">'\t已下载'</span>)</span><br><span class="line">        </span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure></div><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Enjoy it !</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;这篇文章主要是方便入门爬虫的同学获得入门的正反馈，配合代码注释可能轻松&lt;del&gt;愉悦&lt;/del&gt;的对爬虫有个大概了解~&lt;/li&gt;
&lt;li&gt;我们选择对于使用静态网页的小说网站, 小说的文本内容往往分配在一个&amp;lt;div里,  &lt;strong&gt;逻辑比较简单&lt;/strong&gt;. &lt;/li&gt;
&lt;li&gt;那就开始吧＜（＾－＾）＞&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://zlee.xyz/categories/Python/"/>
    
    
      <category term="Web Crawler" scheme="https://zlee.xyz/tags/Web-Crawler/"/>
    
  </entry>
  
  <entry>
    <title>A Whisper To The World</title>
    <link href="https://zlee.xyz/2018/12/01/A-Whisper-To-The-World/"/>
    <id>https://zlee.xyz/2018/12/01/A-Whisper-To-The-World/</id>
    <published>2018-11-30T17:36:32.000Z</published>
    <updated>2019-05-16T08:58:56.452Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/12/01/5c017a914a980.jpg" alt="Nier"></p><p></p><p blockquote="" class="centerquote"><i> NieR:Automata </i><br><a id="more"></a></p><blockquote><p>Everything that lives is designed to end.<br>一切活着的事物，都注定要终结。<br>We are perpetually trapped …<br>我们被永远地囚禁……<br>… in a never-ending spiral of life and death.<br>……于永无止境的生死轮回之中。<br>Is this a curse?<br>这是一种诅咒？<br>Or some kind of punishment?<br>还是某种惩罚？<br>I often think about the god who blessed us with this cryptic puzzle …<br>我时常想起那用模糊的谜团祝福我们的神……<br>… and wonder if we’ll ever have the chance to kill him.<br>……并猜想我们是否终有弑神的机会。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/12/01/5c017a914a980.jpg&quot; alt=&quot;Nier&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p blockquote=&quot;&quot; class=&quot;centerquote&quot;&gt;&lt;i&gt; NieR:Automata &lt;/i&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Thoughts" scheme="https://zlee.xyz/categories/Thoughts/"/>
    
    
      <category term="Nier:Automata" scheme="https://zlee.xyz/tags/Nier-Automata/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zlee.xyz/2018/11/30/hello-world/"/>
    <id>https://zlee.xyz/2018/11/30/hello-world/</id>
    <published>2018-11-29T17:36:32.000Z</published>
    <updated>2019-05-16T08:55:54.788Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hello" scheme="https://zlee.xyz/tags/Hello/"/>
    
  </entry>
  
</feed>
