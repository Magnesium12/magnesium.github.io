

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="$Better \space Than \space Nothing$">
  <meta name="author" content="YuXiu">
  <meta name="keywords" content="">
  
  <title>Simple Tutorial for C++ Programming - YuXiu`s Space</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>YuXiu`s World</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Simple Tutorial for C++ Programming">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-12-29 00:00" pubdate>
        December 29, 2018 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Simple Tutorial for C++ Programming</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：April 24, 2021 pm
                
              </p>
            
            <div class="markdown-body">
              <p>$Better \space Than \space Nothing$</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这只是心血来潮的产物, 他的内容基础到我都不好意思称呼他为一篇正经的C++指南…..</p>
<p>最致命的一点, 估计就是大量的默认了解过C语言的相关概念了……</p>
<p>总之算是我的一个尝试吧, <del>使我知道了写这样的博文会很蛋疼</del></p>
<h2 id="计算机与C-简介"><a href="#计算机与C-简介" class="headerlink" title="计算机与C++简介"></a>计算机与C++简介</h2><blockquote>
<p>选择性了解</p>
</blockquote>
<h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><ul>
<li>输入单元 (input unit)</li>
<li>输出单元 (output unit)</li>
<li>内存单元 (memory unit)</li>
<li>算术逻辑单元 (arithmetic and logic unit, ALU)</li>
<li>中央处理器 (central processing unit, CPU)</li>
<li>辅助存储单元 (secondary storage unit)</li>
</ul>
<h3 id="数据的层次结构"><a href="#数据的层次结构" class="headerlink" title="数据的层次结构"></a>数据的层次结构</h3><ul>
<li><p>位 (Bit)<br>位, 计算机最小的数据项, 数值为0或1. (Binary digit)</p>
</li>
<li><p>字符 (Charater)<br>Unicode字符集包含了世界上很多中语言, 每个字符是由两个字节(Byte)组成, 每个字节是8位. 流行的ASCII(美国信息交换标准代码) 是Unicode的子集.</p>
</li>
<li><p>字段 (Field)</p>
</li>
<li><p>记录 (Record)</p>
</li>
<li><p>文件 (File)</p>
</li>
<li><p>数据库 (Database)<br>层次结构中, 除去数据库之外, 其余相邻层次均为组成与被组成关系</p>
</li>
</ul>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul>
<li><p>机器语言<br>一般由0/1组成, 令人费解. 计算机能直接执行.</p>
</li>
<li><p>汇编语言<br>采用类似英语缩写的指令表示基本操作. 汇编器(assembler) 负责将汇编语言转换成机器语言, 然后才能被计算机理解.</p>
</li>
<li><p>高级语言<br>抽象程度更高, 一种方式是采用编译器(compiler)转换为机器语言. 例如: C++, Java, C#等.<br>另一种方式是采用解释器(interpreter), 可以直接执行高级语言程序 (没有编译的延迟), 但是执行过程会慢得多. 脚本语言采用解释器来处理, 例如: JavaScript, PHP</p>
</li>
</ul>
<h3 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h3><ul>
<li>对象</li>
<li>成员函数和类</li>
<li>实例化</li>
<li>重用</li>
<li>消息和成员函数调用</li>
<li>属性和数据成员</li>
<li>封装 (encapsulate)</li>
<li>继承 (inheritance)</li>
<li><strong>UML (统一建模语言)</strong><br>Unified Modeling Language</li>
</ul>
<h2 id="C-编程入门"><a href="#C-编程入门" class="headerlink" title="C++ 编程入门"></a>C++ 编程入门</h2><blockquote>
<p>没什么好说的, 简单提几点</p>
</blockquote>
<h3 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入/输出流"></a>输入/输出流</h3><ul>
<li>输出流对象<code>std::cout</code>用于输出数据, 串联的流插入运算符<code>&lt;&lt;</code>可以输出多个数据</li>
<li>输入流对象<code>std::cin</code>用于输入数据, 串联的流提取运算符<code>&lt;&lt;</code>可以输入多个数据<br>请记住, <code>cout</code>和<code>cin</code>是对象, 这一点在运算符重载中会有体现 </li>
</ul>
<h3 id="变量和内存"><a href="#变量和内存" class="headerlink" title="变量和内存"></a>变量和内存</h3><ul>
<li>每个变量都具有: 名字, 值, 类型, 内存大小,<strong>存储类别, 作用域和链接</strong> .</li>
<li>对内存的读取过程是非破坏性的, 写入则相反</li>
</ul>
<h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><ul>
<li>求模运算符 (%) 只能得到整数除法的余数</li>
<li>using 声明<br>using std::cout;<br>表示告知编译器, 在命名空间 <code>std</code> 中找到<code>cout</code></li>
</ul>
<h2 id="类-对象和字符串"><a href="#类-对象和字符串" class="headerlink" title="类, 对象和字符串"></a>类, 对象和字符串</h2><blockquote>
<p>类、对象、数据成员、成员函数、UML图、构造函数</p>
</blockquote>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><ul>
<li>通常来说, 类应当包括数据成员和成员函数, 两者对应着类的属性和行为</li>
<li>成员访问说明符: <code>public``private``protected</code></li>
<li>类的数据成员应当设计成私有（private）、成员函数设计成公有（public）</li>
</ul>
<ul>
<li>按照惯例, 类名每个单词首字母大写, 函数名则采用驼峰式写法<br><del>这样优雅</del></li>
</ul>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><ul>
<li>成员函数一般声明为public</li>
<li>定义同<strong>C语言</strong>的函数语法</li>
</ul>
<h3 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h3><ul>
<li><p>数据成员可以被声明为 public/private/protected</p>
</li>
<li><p>尽可能复用get/set函数，以便于建立更为强壮（易维护）的类<br>get/set函数是类提供的对私有成员(private) 的访问接口</p>
</li>
<li><p>应当将<strong>数据成员私有化</strong><br>通过公有函数控制访问数据成员的权利，保证数据的完整性. 数据完整性还包括对有效性的检查和报告错误</p>
</li>
</ul>
<h3 id="构造函数（constructor）"><a href="#构造函数（constructor）" class="headerlink" title="构造函数（constructor）"></a>构造函数（constructor）</h3><ul>
<li><p>构造函数初始化对象；</p>
</li>
<li><p>构造函数可能为非显式；例如类<code>string</code>默认字符串的构造函数为空串</p>
</li>
<li><p>explicit构造函数必须显式调用。原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。<a target="_blank" rel="noopener" href="https://blog.csdn.net/fengbingchun/article/details/51168728">QUATE</a></p>
</li>
<li><p>构造函数不能返回值</p>
</li>
<li><p>通常构造函数声明为public（成员访问说明符)</p>
</li>
<li><p><code>Account</code>类构造函数定义如下</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">Accoun<span class="hljs-variable">t:</span>:Account(<span class="hljs-keyword">int</span> <span class="hljs-keyword">number</span>):<span class="hljs-keyword">number</span>(<span class="hljs-keyword">number</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此例中，构造函数通过成员初始化列表用构造函数形参<code>number</code>初始化数据成员<code>number</code></p>
</li>
<li><p>析构函数形式通常为<code>~</code>+构造函数</p>
</li>
</ul>
<h3 id="接口与实现的分离"><a href="#接口与实现的分离" class="headerlink" title="接口与实现的分离"></a>接口与实现的分离</h3><p>所谓接口是指函数原型(函数声明), 实现是指函数定义. 好的实践是将二者分离, 即头文件定义类并对函数声明, 外部cpp定义类的成员函数.   </p>
<ul>
<li><code>::</code>二元作用域分辨运算符 (scope resolution operator), 成员函数定义在类定义外部时启用</li>
<li>using指令和声明不应放在头文件中</li>
<li>函数原型告知编译器函数的名字、返回类型、形参类型；函数定义则是包含函数的实现</li>
</ul>
<h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h3><ul>
<li><code>string</code>是C++标准库类型 </li>
<li>读取字符串时，流提取运算符读取字符在遇到第一个空白字符时停止，所以使用<code>getline(cin，xxx)</code>替代<code>cin&lt;&lt;xxx</code></li>
<li><code>substr</code>函数中，第一个参数表示起始位置，第二个表示复制字符的个数</li>
</ul>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><ul>
<li><p>UML图分为三层, 每一层用横线隔开, 采用<code>+``-</code>对应公有和私有</p>
</li>
<li><p>上层为类名</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">GradeBook</span><br></code></pre></td></tr></table></figure></li>
<li><p>中层为数据成员</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">- course <span class="hljs-keyword">Name</span>:<span class="hljs-keyword">String</span><br></code></pre></td></tr></table></figure></li>
<li><p>下层为成员函数</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">&lt;&lt;<span class="hljs-function"><span class="hljs-keyword">constructor</span>&gt;&gt; + <span class="hljs-title">GradeBook</span><span class="hljs-params">(<span class="hljs-keyword">name</span>:<span class="hljs-keyword">String</span>)</span></span><br><span class="hljs-function">+ <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">name</span>:<span class="hljs-keyword">String</span>)</span></span><br><span class="hljs-function">+ <span class="hljs-title">getCourse</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span>:</span><span class="hljs-keyword">String</span><br>+ displayMessage()<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="本章小结："><a href="#本章小结：" class="headerlink" title="本章小结："></a>本章小结：</h3><p><strong>建立类、接口与实现分离、构造函数初始化对象、UML图</strong></p>
<ul>
<li>对于new的对象应使用destroctor（析构函数，防止内存泄漏）；</li>
<li>结构体声明也会初始化对象</li>
</ul>
<h2 id="控制语句-Ⅰ-赋值、自增自减运算符"><a href="#控制语句-Ⅰ-赋值、自增自减运算符" class="headerlink" title="控制语句(Ⅰ)赋值、自增自减运算符"></a>控制语句(Ⅰ)赋值、自增自减运算符</h2><blockquote>
<p>主要内容和<strong>C语言</strong>类似, 不必展开.  其余内容无法展开</p>
</blockquote>
<h3 id="控制结构-control-structure"><a href="#控制结构-control-structure" class="headerlink" title="控制结构 (control structure)"></a>控制结构 (control structure)</h3><ul>
<li>** 顺序 (sequence), 选择 (selection)和循环 (repetition)**</li>
<li>循环控制结构分为: 计数器控制和标记控制</li>
<li>控制结构可以嵌套</li>
</ul>
<p><em>One Trick of Selection Structure</em></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">i</span> = i==<span class="hljs-number">1</span>?i=<span class="hljs-number">0</span>:i=<span class="hljs-number">1</span>;<br><br><span class="hljs-attribute">cout</span>&lt;&lt;(grade&gt;=<span class="hljs-number">60</span>?<span class="hljs-string">&quot;passed&quot;</span>:<span class="hljs-string">&quot;failed&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><ul>
<li>Int A = 1.3 ; 警告但仍能编译；Int A = { 1.3 };出现错误，无法编译。这是一种‘缩小转换，我们应该尽量避免</li>
<li>可以使用 static_cast()来强制转换类型<br>  ​    <h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3></li>
<li> <code>--a</code>和<code>a--</code>的区别: </li>
</ul>
<p><code>a--</code>中，变量表达式先使用a值，再对a进行更新<br><code>--a</code>中，a先更新，然后在变量表达式中使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i= <span class="hljs-number">1</span>;<br>cout&lt;&lt;i++&lt;&lt;endl;<br><span class="hljs-comment">// i=2 ;输出 1;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>自增自减运算符不可用于表达式：如<code>(x+1)++</code>为错</li>
</ul>
<h3 id="本章小结：-1"><a href="#本章小结：-1" class="headerlink" title="本章小结："></a>本章小结：</h3><ul>
<li><p>算法：根据索要执行的动作及这些动作执行的顺序描述的解决问题的过程；</p>
</li>
<li><p>伪代码: <del>没啥用</del></p>
</li>
<li><p>控制结构（顺序、选择、循环）:</p>
<p>  顺序结构；</p>
<p>  选择结构：选择语句（单路选择if，双路选择if else）、循环语句while</p>
<p>  循环结构；</p>
</li>
</ul>
<h2 id="控制语句-Ⅱ-和逻辑运算符"><a href="#控制语句-Ⅱ-和逻辑运算符" class="headerlink" title="控制语句(Ⅱ)和逻辑运算符"></a>控制语句(Ⅱ)和逻辑运算符</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><del>这不是游戏机!!</del></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (grade)<br>&#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>: &#123;cout&lt;&lt;<span class="hljs-string">&quot;guna!!!&quot;</span>; <span class="hljs-keyword">break</span>;&#125;<br>	<span class="hljs-keyword">default</span>:<br>		cout&lt;&lt;<span class="hljs-string">&quot;rua!!!&quot;</span>&lt;&lt;endl;<br>		<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h3><p>结束和跳过的区别</p>
<h3 id="本章小结：-2"><a href="#本章小结：-2" class="headerlink" title="本章小结："></a>本章小结：</h3><blockquote>
<p>for语句；do..while语句；switch多路选择语句；break&amp;continue语句；<br>逻辑运算符||、&amp;&amp;、！；<br>==、=运算符；<br>结构化编程：任何形式的控制都可以用顺序、选择、循环语句来表达，并且这些语句的组合方式只有堆叠和嵌套；</p>
</blockquote>
<h2 id="函数与递归"><a href="#函数与递归" class="headerlink" title="函数与递归"></a>函数与递归</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote>
<p>函数参数: 形参实参, 引用和值,<br>调用堆栈, 标识符作用域, 重载, 模板<br>变量: 存储类别, 作用域, 链接<br>递归与迭代</p>
</blockquote>
<h3 id="C-程序组件"><a href="#C-程序组件" class="headerlink" title="C++程序组件"></a>C++程序组件</h3><ul>
<li>C++程序是由预先打包的函数和类及自己编写的函数和类组合而成；</li>
<li>C++库有自己的头文件，同时也包含了各种类类型、函数和常量的定义</li>
</ul>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ul>
<li>函数原型包括返回值类型, 函数名和参数类型. 函数名和参数类型合并称为函数签名</li>
<li>C++ 的函数参数类型存在基本类型间的隐式转换</li>
<li>可以简单理解为函数声明中除去返回值的部分</li>
</ul>
<h3 id="随机数与枚举类型"><a href="#随机数与枚举类型" class="headerlink" title="随机数与枚举类型"></a>随机数与枚举类型</h3><h4 id="Rand"><a href="#Rand" class="headerlink" title="Rand()"></a><code>Rand()</code></h4><p>该函数原型包含于<code>&lt;cstdlib&gt;</code>头文件下，如果没有利用<code>srand()</code>更新种子，那么每次的随机数生成结果将完全相同。</p>
<ul>
<li><code>Rand()</code>可预测，不具有<strong>良好的统计特性</strong>. 安全性较弱</li>
<li>C++11提供了<code>&lt;random&gt;</code>随机数库，用配置控制引擎产生的值、值的类型、及统计特性；用引擎实现一套生成伪随机数的算法；<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;random&gt;</span></span><br>Int main()<span class="hljs-comment">//默认的随机数生成引擎和默认的配置</span><br>&#123;<br>	Default_random_engine   engine(static_cast&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(time(<span class="hljs-number">0</span>)));<br>	Uniform_int_distribution&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;<br>	randomInt(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">//Uniform_int_distribution是一个类模板</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="Srand"><a href="#Srand" class="headerlink" title="Srand()"></a><code>Srand()</code></h4><p>该函数原型包含于<code>&lt;cstdlib&gt;</code>头文件下，通常为<code>srand(static_cast&lt;unsigned int(time(0)))</code>，意为将<code>time()</code>返回的值（从格林尼治时间到当前的秒数）从<code>time_t</code>转换为<code>int</code>类型，并用作随机数种子。<br>实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">srand</span>(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>)))；<br>Number=C+<span class="hljs-built_in">rand</span>()%A;<span class="hljs-comment">//生成值域为[C,C+A-1]的随机数</span><br></code></pre></td></tr></table></figure>

<h4 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h4><p>关键字enum+枚举类型名+一组由标识符表示的整型常量</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">Status</span>&#123;<span class="hljs-keyword">CONTINUE</span>, WON, LOST&#125;;<br></code></pre></td></tr></table></figure>
<p>默认情况下，枚举类型值从零开始并递增1，整型类型为int；<br>类型名首字母最好大写；枚举常量必须大写；<br>枚举类型名+<code>:</code>+整型类型，制定整型类型；</p>
<p>进阶情况：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Status: <span class="hljs-symbol">unsigned</span></span> <span class="hljs-symbol">int</span> &#123;CONTINUE=<span class="hljs-number">1</span>, WON, LOST&#125;;<br></code></pre></td></tr></table></figure>
<p>作用域限定，可以避免潜在的命名冲突和逻辑错误；<br>设定整型类型，应足够保证保存指定的常量值；<br>引用枚举常量：<code>result==Status:: WON;</code></p>
<h3 id="存储类别和存储期-入门"><a href="#存储类别和存储期-入门" class="headerlink" title="存储类别和存储期(入门)"></a>存储类别和存储期(入门)</h3><h4 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h4><ol>
<li>五个类别的标识符： <code>auto</code> <code>extern</code> <code>static</code> <code>register</code> <code>mutable</code></li>
<li>四种类型: 自动存储期, 静态, 动态, 线程</li>
</ol>
<h5 id="自动存储期变量-register-amp-auto"><a href="#自动存储期变量-register-amp-auto" class="headerlink" title="自动存储期变量(register &amp; auto)"></a>自动存储期变量(register &amp; auto)</h5><ol>
<li>定义在函数内的局部变量</li>
<li>函数形参</li>
<li><code>register</code>声明的局部变量或函数形参</li>
</ol>
<h5 id="静态存储期变量-static-amp-extern"><a href="#静态存储期变量-static-amp-extern" class="headerlink" title="静态存储期变量(static &amp; extern)"></a>静态存储期变量(static &amp; extern)</h5><blockquote>
<p>具有静态存储期的变量从程序开始执行到结束, 一直存在于内存中.<br>对于这样的变量, 声明时便对它进行一系列初始化.<br>当然, 存储期和作用域是两回事, 他不意味着在整个程序都能使用<br>标识为<code>static</code> 的局部变量在函数结束后也不会消失, 它会以最后一次的返回值保留</p>
</blockquote>
<p>Trick code</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> a= <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">static</span> b=<span class="hljs-number">1</span>;<br>	b++;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>;<br>	cout&lt;&lt;::a&lt;&lt;a&lt;&lt;endl;<span class="hljs-comment">//10, 此时的:: 是一元作用域分辨符</span><br>	<span class="hljs-built_in">foo</span>();<br>	<span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="寄存器变量-register"><a href="#寄存器变量-register" class="headerlink" title="寄存器变量(register)"></a>寄存器变量(register)</h5><ol>
<li><code>register</code>建议将变量放置在计算机的高速硬件寄存器而不是内存中, 对于频繁使用的变量采用<code>register</code>可以有效消除变量-&gt;内存-&gt;寄存器-&gt;内存的开销. </li>
<li>只能与局部变量和函数形参一起使用</li>
<li>理论上不需手动优化, 编译器可以智能识别</li>
</ol>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>标识符在程序中可以被引用的范围</p>
<ul>
<li><p>函数作用域<br>仅限于<code>case:</code>一类</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span>()&#123;<br>    <span class="hljs-keyword">case</span> a:&#123;&#125;;<span class="hljs-keyword">break</span>;<br>	.....<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>语句块作用域<br>最广泛, 作用域为从声明到语句块右大括号.</p>
</li>
<li><p>全局命名空间作用域(global namesapce scope )<br>声明于任何函数和类之外, 对于从声明到文件结束的任何函数都是<strong>已知</strong>的.</p>
</li>
<li><p>函数原型作用域<br>实际上函数原型的参数不需要标志符, 只需要类型, 所以函数原型作用域的标识符可以在任意处复用.</p>
</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>标识符是否只是在声明它的源文件被识别, 或者可以在编译后链接的多文件被识别</p>
<h3 id="函数调用堆栈和活动记录"><a href="#函数调用堆栈和活动记录" class="headerlink" title="函数调用堆栈和活动记录"></a>函数调用堆栈和活动记录</h3><p>函数调用是一种 LIFO机制, 每层次包含了函数的返回地址和其他信息, 递归调用最能直观体现.</p>
<h3 id="引用和引用形参"><a href="#引用和引用形参" class="headerlink" title="引用和引用形参"></a>引用和引用形参</h3><ul>
<li><code>Int &amp;count</code> 表示<code>count</code>是对一个<code>int</code>类型对象的引用</li>
<li>按引用传递的形参等价于原有实参的别名，修改按引用传递的形参等于修改对应实参</li>
<li>如果一个函数的形参是按引用传递的：即<code>int &amp; count</code>，很可能会因为引用形参导致对应实参被修改而发生错误！</li>
</ul>
<h3 id="函数重载和函数模板-入门"><a href="#函数重载和函数模板-入门" class="headerlink" title="函数重载和函数模板(入门)"></a>函数重载和函数模板(入门)</h3><ul>
<li>函数重载：相同函数名，但具有不同的形参集合；通过<strong>函数签名</strong>区分；</li>
<li>函数模板：<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-built_in">T</span> maximum(<span class="hljs-built_in">T</span> value1, <span class="hljs-built_in">T</span> value2, Tvalue3)<br>&#123;<br>	<span class="hljs-built_in">T</span> maximumValue= value1;<br>	//省略中间<br>	<span class="hljs-built_in">return</span> maximumValue;<br></code></pre></td></tr></table></figure>
T为参数类型（int、double等）</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>递归函数是直接或者间接调用自身的函数；</li>
<li>一般分解为两个步骤: 基本情况终结递归, 和简化情况调用递归</li>
<li>内存开销很大</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>这里描述的指针沿袭了C语言风格, 实际运用时需要注意最小特权原则. 默认有一定的C语言基础，基本知识略去</p>
<h3 id="指针变量的声明与初始化"><a href="#指针变量的声明与初始化" class="headerlink" title="指针变量的声明与初始化"></a>指针变量的声明与初始化</h3><ol>
<li><p>指针变量与间接引用<br>指针变量把内存地址作为它的值. 如果说一个变量名直接引用一个值, 那么一个存有一个变量名内存地址的指针变量就是间接引用这个值. </p>
</li>
<li><p>指针的声明</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">int</span> *<span class="hljs-built_in">ptr</span>, count<span class="hljs-comment">;</span><br>// <span class="hljs-built_in">ptr</span>是一个是一个指向<span class="hljs-built_in">int</span>类型数据的指针<br>// count是一个<span class="hljs-built_in">int</span>类型的变量<br>// (*)在这里并不是运算符, 他只是用于表示<span class="hljs-built_in">ptr</span>是一个指针<br></code></pre></td></tr></table></figure></li>
<li><p>指针初始化<br>将指针初始化为<code>nullptr</code>是有必要的, 这可以防止它指向一个未知的或者未被初始化的内存空间</p>
</li>
</ol>
<h3 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符"></a>指针运算符</h3><ul>
<li>地址运算符<code>&amp;</code><br>地址运算符是一个一元运算符, 它获得操作数的内存地址.<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//取址与赋值</span><br><span class="hljs-built_in">int</span> y = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> *yptr = <span class="hljs-literal">null</span>ptr;<br>yptr = &amp;y;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>值得一提的是, 这里的<code>&amp;</code>与我们之前在函数中提到的引用变量声明<code>&amp;</code>不同, 简言之:<br>​    1. 后者的前面必然有一个数据类型名<br>​    2. 在声明一个引用的时候,<code>&amp;</code>只是类型的一部分</p>
<ul>
<li>间接运算符<code>*</code><br>一元运算符<code>*</code>通常被称为简介运算符或者间接引用( dereference)运算符. <strong>它返回一个左值</strong>, 表示其指针操作数所指向的对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*yptr = <span class="hljs-number">8</span>;<br>cin&gt;&gt; *yptr;<br><br>cout&lt;&lt; *yptr&lt;&lt;endl;<br>cout&lt;&lt; y &lt;&lt; endl;  <span class="hljs-comment">//两者等价</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用指针的按引用传递方式"><a href="#使用指针的按引用传递方式" class="headerlink" title="使用指针的按引用传递方式"></a>使用指针的按引用传递方式</h3><p><del>真実はいつもひとつ</del></p>
<p><strong>所有的引用都是传值引用, 无非你传入的是指针的内存地址值, 又或者是变量值.</strong></p>
<h3 id="内置数组"><a href="#内置数组" class="headerlink" title="内置数组"></a>内置数组</h3><ul>
<li><p>C语言风格, 主要特点是内存连续, 通过下标访问, 大小固定.<br>不建议使用, 可以改用标准库中的 <code>vector</code> 或者<code>array</code></p>
</li>
<li><p>对于Linux 或者 OS X系统来说, 内置数组有时是必要的.<br>例如使用命令行执行程序时, 需要给程序提供命令行参数, 此时的命令行参数将作为一个具有基于指针的字符串元素的内置数组传递给<code>main</code>函数.</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//Windows 下常见的main函数声明方式</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">int</span> *argv[])</span></span>&#123;<br>	<span class="hljs-comment">/* your code */</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用const修饰指针"><a href="#使用const修饰指针" class="headerlink" title="使用const修饰指针"></a>使用const修饰指针</h3><ol>
<li><p>指向非const 数据的非const 指针<br>具有最大的访问权限, 指针和数据均可修改</p>
</li>
<li><p>指向const 数据的非const 指针<br>可以修改指针指向, 不可以修改数据.<br>可以在只读函数中大胆使用, 获取数据的高速引用.</p>
</li>
<li><p>指向非const 数据的const 指针</p>
</li>
<li><p>指向const 数据的const 指针</p>
</li>
</ol>
<h3 id="指针表达式和指针算数运算和内置数组"><a href="#指针表达式和指针算数运算和内置数组" class="headerlink" title="指针表达式和指针算数运算和内置数组"></a>指针表达式和指针算数运算和内置数组</h3><ul>
<li><p>指针赋值<br>只有在已知指针类型的情况下, 编译器才能进行指针赋值. 例如 <code>void*</code>类型指针无法直接被赋值到其他类型指针. 因为编译器需要知道一个指针所指向的字节数和数据类型, 确定该指针间接引用的字节数.</p>
</li>
<li><p>指针比较<br>非同一数组指针的比较毫无意义</p>
</li>
<li><p>指针/偏移量表示法</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[5]</span>;<br><span class="hljs-selector-tag">int</span>* <span class="hljs-selector-tag">bPtr</span>;<br><br><span class="hljs-comment">//b[3]的几种写法</span><br>*(bPtr + <span class="hljs-number">3</span>)<br>*(b +<span class="hljs-number">3</span>)<br>* <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[3]</span><br>* <span class="hljs-selector-tag">&amp;</span>(bPtr +<span class="hljs-number">3</span>)<br><br></code></pre></td></tr></table></figure>
<p>请注意, <code> b+= 3</code> 这种写法是错误的, 内置数组名不可修改.</p>
</li>
</ul>
<h2 id="类的深入剖析"><a href="#类的深入剖析" class="headerlink" title="类的深入剖析"></a>类的深入剖析</h2><blockquote>
<p>头文件的包含防护(include guard) : #pragma once<br>继承和组成概念</p>
</blockquote>
<h3 id="类的作用域和类成员的访问"><a href="#类的作用域和类成员的访问" class="headerlink" title="类的作用域和类成员的访问"></a>类的作用域和类成员的访问</h3><p>成员选择运算符<code>.</code>和<code>-&gt;</code><br><code>.</code> 适用于对象或对象引用, <code>-&gt;</code> 适用于对象的指针</p>
<h3 id="const-对象和const-成员函数"><a href="#const-对象和const-成员函数" class="headerlink" title="const 对象和const 成员函数"></a>const 对象和const 成员函数</h3><p>对于const 对象, C++编译器不允许被除声明为const的成员函数之外的成员函数调用.</p>
<blockquote>
<p>很明显我们的构造函数和析构函数无法被声明为const, 况且构造函数和析构函数必然会修改对象. 这里, <strong>const的有效性是指对于构造函数和析构函数之间的部分而言</strong></p>
</blockquote>
<h3 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h3><p>友元声明(friend)<br>友元关系是授予的而不是索取的. 如果说B是A的友元, 那么B可以访问A的成员. 对于A来说, A不是B的友元, A无法对B中的成员进行访问. 例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classTwo</span></span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classOne</span></span><br><span class="hljs-class"></span>&#123;<br>	friend <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classTwo</span></span>;<br>	<span class="hljs-function">friend <span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>	classOne();<br>	~classOne()<br><br>&#125;	<br></code></pre></td></tr></table></figure>

<h3 id="static-类数据成员"><a href="#static-类数据成员" class="headerlink" title="static 类数据成员"></a>static 类数据成员</h3><ul>
<li><code>static</code> 表示”整个类范围”上的信息(即类所有实例共享的性质, 而不是某个特定实例具有的特性)</li>
<li>static 数据成员具有类作用域并且可以声明为public, private, protected.</li>
<li><code>static</code> 关键字不能用于类定义之外的成员定义</li>
<li>对于不访问非static数据成员或非static成员函数的成员函数, 应当声明为<code>static</code>. static成员函数没有<code>this</code>指针, 它独立于类的任何对象</li>
<li><ul>
<li>没有类对象, 类的static类成员依旧存在, 并且可以用类名+<code>::</code> 作为前缀直接访问public static类成员</li>
</ul>
</li>
<li>当没有类的对象存在而要访问private的static类成员时，应该提供public static 成员函数；并通过在函数名前加类名和二元作用域分辨运算符的方式来调用此函数</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    A *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    a-&gt;<span class="hljs-built_in">foo</span>();   <span class="hljs-comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>每一个声明虚函数的类会占据更多的空间</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>类的一个特征就是封装，public和private作用就是实现这一目的</strong>。所以：</p>
<p>用户代码（类外）可以访问public成员而不能访问private成员；private成员只能由类成员（类内）和友元访问。</p>
<p><strong>类的另一个特征就是继承，protected的作用就是实现这一目的</strong>。所以：</p>
<p>protected成员可以被派生类对象访问，不能被用户代码（类外）访问。</p>
<p>如下图所示：</p>
<table>
<thead>
<tr>
<th>继承类型</th>
<th>基类public成员</th>
<th>protected成员</th>
<th>private成员</th>
</tr>
</thead>
<tbody><tr>
<td><strong>public继承</strong></td>
<td>public</td>
<td>protected</td>
<td>private</td>
</tr>
<tr>
<td><strong>protected继承</strong></td>
<td>protected</td>
<td>protected</td>
<td>private</td>
</tr>
<tr>
<td><strong>private继承</strong></td>
<td>private</td>
<td>private</td>
<td>private</td>
</tr>
</tbody></table>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Todo/">Todo</a>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/12/31/%E4%BA%8C%E3%80%87%E4%B8%80%E5%85%AB/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">The Destination of 2018</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/13/DataStruct/">
                        <span class="hidden-mobile">Data Structure</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
