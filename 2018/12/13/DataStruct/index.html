

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="
谨以此文, 纪念我没怎么听过的数据结构">
  <meta name="author" content="YuXiu">
  <meta name="keywords" content="">
  
  <title>Data Structure - YuXiu`s Space</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>YuXiu`s World</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Data Structure">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-12-13 08:36" pubdate>
        December 13, 2018 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Data Structure</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：April 24, 2021 pm
                
              </p>
            
            <div class="markdown-body">
              <p><img src="http://i0.hdslb.com/bfs/archive/4c9309085933d7cee42218ca647f01f1ca7b46ac.jpg" srcset="/img/loading.gif" lazyload alt="希尔~~排序~~"></p>
<blockquote class="blockquote-center"><i>谨以此文, 纪念我没怎么听过的数据结构</i></blockquote>
<span id="more"></span>

<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是数据元素的非空有限集合</p>
<ul>
<li>  唯一一个“ 开始节点”</li>
<li>  唯一一个” 终端节点“</li>
<li>  除开始结点外，集合中的每个数据元素均只有一个直接前驱</li>
<li>  除终端结点外，集合中的每个数据元素均只有一个直接后继</li>
</ul>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>线性表的结点按逻辑次序存放在一组地址连续的存储单元里, 例如数组</p>
<p><strong>loc(ai)=loc(a1)+(i-1)*c</strong></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>插入算法和删除算法都是 $O(n)$</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><ol>
<li><p>定义要点</p>
<ul>
<li>n 个结点组成的有限集合</li>
<li>根结点(root)</li>
<li>其余结点分为 m 个子树(subtree)</li>
<li>x&lt;y, 则 Tx 在 Ty 右侧, 称为有序树</li>
</ul>
</li>
<li><p>基本术语<br>结点(node)——表示树元素，包括数据项及指向其子树的分支<br>结点的度(degree)——结点拥有的子树个数<br>叶子(leaf)——度为 0 的结点，又称终端结点<br>孩子(child)——结点子树的根称为该结点的孩子<br>双亲(parents)——孩子结点的上层结点叫该结点的双亲<br>兄弟(sibling)——同一双亲的孩子<br>祖先(ancestor) ——树的根结点<br>子孙(descendant) ——子树上的所有结点<br>树的度(degree) ——一棵树中最大的结点度数<br>结点的层次(level)——根为第一层，它的孩子为第二层……<br>树的深度(depth)——树中结点的最大层次数<br>森林(forest)——m(m&gt;=0)棵互不相交的树的集合</p>
</li>
</ol>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol>
<li>若二叉树的层次从 1 开始, 则在二叉树的第 i 层最多有 2^i+1^ 个结点(i &gt;=1)</li>
<li>深度为 k 的二叉树最多有 2k-1 个结点(k &gt;=1)</li>
<li>任意一颗二叉树, 如果其叶节点数为 n<del>0</del>, 度为 2 的节点数为 n<del>2</del>, 则有 n<del>0</del>=n<del>2</del>+1</li>
<li>具有 n 个结点的完全二叉树的深度为 log<del>2</del>(n+1) 向上取整。</li>
</ol>
<blockquote>
<p>定义 1 满二叉树(Full Binary Tree)<br>一棵深度为 k 且有 2k –1 结点的二叉树称为满二叉树。<br>特点：每一层上的结点数都是最大结点数。</p>
</blockquote>
<blockquote>
<p>定义 2 完全二叉树(Complete Binary Tree)<br>若一棵二叉树只有最下两层上的结点的度数可以小于 2，并且最下一层上的结点集中分布在该层左侧连续的若干位置上，则该二叉树称为完全二叉树。</p>
</blockquote>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>顺序存储和链表式存储</p>
<h3 id="二叉树的先序、中序和后序遍历"><a href="#二叉树的先序、中序和后序遍历" class="headerlink" title="二叉树的先序、中序和后序遍历"></a>二叉树的先序、中序和后序遍历</h3><p>采用递归确定遍历顺序：<br>对于二叉树任意一个父节点和及其子节点，先序遍历永远是父节点，左子，右子.<br>中序和后序同理</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面展示了相应的两种方法</p>
<ul>
<li>  递归法</li>
<li>  迭代法( 利用栈 )</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//操作函数</span><br>void <span class="hljs-constructor">InitStack(BTreeNode <span class="hljs-operator">*</span>&amp;T)</span>;<br>void <span class="hljs-constructor">PushStack(BTreeNode <span class="hljs-operator">*</span>&amp;T, BTreeNode <span class="hljs-operator">*</span>&amp;<span class="hljs-params">child</span>)</span>;<br>BTreeNode *<span class="hljs-constructor">PopStack(BTreeNode <span class="hljs-operator">*</span>&amp;T)</span>;<br><span class="hljs-built_in">bool</span> is<span class="hljs-constructor">Empty(BTreeNode <span class="hljs-operator">*</span>T)</span>;<br><br><span class="hljs-comment">//二叉树节点定义</span><br><span class="hljs-keyword">struct</span> BTreeNode<br>&#123;<br>    ElemType data;<br>    BTreeNode *leftChild;<br>    BTreeNode *parent;<br>    BTreeNode *rightChild;<br>&#125;;<br><br><span class="hljs-comment">//前序遍历的非递归算法</span><br>void pre<span class="hljs-constructor">OrderTraverse(BTreeNode <span class="hljs-operator">*</span>T)</span><br>&#123;<br>    BTreeNode *s;       <span class="hljs-comment">//设置预留右子树指针</span><br>    BTreeNode *p = T;   <span class="hljs-comment">//当前结点指向根结点</span><br>    <span class="hljs-constructor">InitStack(<span class="hljs-params">s</span>)</span>;       <span class="hljs-comment">//初始化空栈</span><br>    <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, NULL)</span>; <span class="hljs-comment">//压一空指针进栈</span><br>    <span class="hljs-keyword">while</span> (p != NULL)<br>    &#123;<br>        cout &lt;&lt; p-&gt;data; <span class="hljs-comment">//访问当前结点</span><br>        <span class="hljs-keyword">if</span> (p-&gt;rightChild != NULL)<br>            <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, <span class="hljs-params">p</span>-&gt;<span class="hljs-params">rightChild</span>)</span>;<br>        <span class="hljs-comment">//进入左子树前预留右子树指针在栈中</span><br>        <span class="hljs-keyword">if</span> (p-&gt;leftChild != NULL)<br>            p = p-&gt;leftChild; <span class="hljs-comment">//进入左子树</span><br>        <span class="hljs-keyword">else</span><br>            p = <span class="hljs-constructor">PopStack(<span class="hljs-params">s</span>)</span>; <span class="hljs-comment">//从栈中弹出相应的右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br>void <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(BTreeNode <span class="hljs-operator">*</span>T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (T != NULL)<br>    &#123;<br>        <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(T-&gt;<span class="hljs-params">leftChild</span>)</span>;  <span class="hljs-comment">//中序遍历T的左子树</span><br>        cout &lt;&lt; T-&gt;data;        <span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(T-&gt;<span class="hljs-params">rightChild</span>)</span>; <span class="hljs-comment">//中序遍历T的右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历的非递归算法</span><br>void <span class="hljs-keyword">in</span><span class="hljs-constructor">OrderTraverse(BTreeNode <span class="hljs-operator">*</span><span class="hljs-params">head</span>)</span><br>&#123;<br>    BTreeNode *s;<br>    BTreeNode *p = head;<br>    <span class="hljs-constructor">InitStack(<span class="hljs-params">s</span>)</span>;<br>    <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, NULL)</span>;<br><br>    <span class="hljs-keyword">while</span> (p<span class="hljs-pattern-match"><span class="hljs-operator">||</span>(!is<span class="hljs-constructor">Empty(<span class="hljs-params">s</span>)</span>)</span><br><span class="hljs-pattern-match">    &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">while</span> (p)</span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, <span class="hljs-params">p</span>)</span>;</span><br><span class="hljs-pattern-match">            p = p-&gt;left<span class="hljs-constructor">Child</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (!is<span class="hljs-constructor">Empty(<span class="hljs-params">s</span>)</span>)</span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">            p = <span class="hljs-constructor">PopStack(<span class="hljs-params">s</span>)</span>;</span><br><span class="hljs-pattern-match">            cout &lt;&lt; p-&gt;data;</span><br><span class="hljs-pattern-match">            p = p-&gt;right<span class="hljs-constructor">Child</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>后序遍历</span><br><span class="hljs-pattern-match">void post<span class="hljs-constructor">Order(BTreeNode <span class="hljs-operator">*</span>T)</span></span><br><span class="hljs-pattern-match">&#123;</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span> (<span class="hljs-constructor">T</span> != <span class="hljs-constructor">NULL</span>)</span><br><span class="hljs-pattern-match">    &#123;</span><br><span class="hljs-pattern-match">        post<span class="hljs-constructor">Order(T-&gt;<span class="hljs-params">leftChild</span>)</span>;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>后序遍历<span class="hljs-constructor">T</span>的左子树</span><br><span class="hljs-pattern-match">        post<span class="hljs-constructor">Order(T-&gt;<span class="hljs-params">rightChild</span>)</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>后序遍历<span class="hljs-constructor">T</span>的右子树</span><br><span class="hljs-pattern-match">        cout &lt;&lt; <span class="hljs-constructor">T</span>-&gt;data;        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>访问根结点</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>post <span class="hljs-constructor">Order</span> <span class="hljs-constructor">Traverse</span></span><br><span class="hljs-pattern-match">void post<span class="hljs-constructor">OrderTraverse(BTreeNode <span class="hljs-operator">*</span><span class="hljs-params">head</span>)</span></span><br><span class="hljs-pattern-match">&#123;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">BTreeNode</span> <span class="hljs-operator">*</span>s;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">BTreeNode</span> <span class="hljs-operator">*</span>visit;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">InitStack(<span class="hljs-params">s</span>)</span>;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, NULL)</span>;</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">while</span> (head <span class="hljs-operator">||</span> (!is<span class="hljs-constructor">Empty(<span class="hljs-params">s</span>)</span>))</span><br><span class="hljs-pattern-match">    &#123;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">while</span> (head)</span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, <span class="hljs-params">head</span>)</span>;</span><br><span class="hljs-pattern-match">            head = head-&gt;left<span class="hljs-constructor">Child</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">		head = <span class="hljs-constructor">PopStack(<span class="hljs-params">s</span>)</span>;</span><br><span class="hljs-pattern-match">		<span class="hljs-operator">/</span><span class="hljs-operator">/</span>右节点已经访问或者右节点为空的情况下,访问根结点</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (head-&gt;right<span class="hljs-constructor">Child</span> <span class="hljs-operator">==</span> <span class="hljs-constructor">NULL</span> <span class="hljs-operator">||</span> head-&gt;right<span class="hljs-constructor">Child</span> <span class="hljs-operator">==</span> visit)</span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">            cout &lt;&lt; head-&gt;data;</span><br><span class="hljs-pattern-match">            visit = head;</span><br><span class="hljs-pattern-match">            head <span class="hljs-operator">==</span> <span class="hljs-constructor">NULL</span>;</span><br><span class="hljs-pattern-match">        &#125;<span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">        	<span class="hljs-operator">/</span><span class="hljs-operator">/</span>右节点尚未访问时,重新压入栈</span><br><span class="hljs-pattern-match">        	<span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>,<span class="hljs-params">head</span>)</span>;</span><br><span class="hljs-pattern-match">        	<span class="hljs-operator">/</span><span class="hljs-operator">/</span>访问右节点</span><br><span class="hljs-pattern-match">            head = head-&gt;right<span class="hljs-constructor">Child</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>参考:</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016674584#articleHeader9">二叉树的遍历方法</a></li>
</ul>
</blockquote>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><blockquote>
<p>由于具有 n 个结点二叉树中， 共有 n+1 个指针域空置不用。为此，A.j.Parlis 和 C.Thornton 提出利用二叉数中这些空的链域来存储结点前驱或后继的地址信息的方法：<br>若某个结点的 left 指针为空， 则使该 left 指针指向该结点的前驱结点；若某个结点的 right 指针为空，则使该 right 指针指向该结点的后继结点。为了区别两个指针域的含义， 每个结点的存储结构中增加两个布尔型的线索标志字段 Lthread 和 Rthread。<br>指向前驱结点和后继结点的指针为线索(thread)， 带有线索的二叉树称为**线索二叉树(Threaded Binary Tree) **。</p>
</blockquote>
<h3 id="中序线索化二叉树的递归算法"><a href="#中序线索化二叉树的递归算法" class="headerlink" title="中序线索化二叉树的递归算法"></a>中序线索化二叉树的递归算法</h3><h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol>
<li>由于线索二叉树首先是二叉树，所以对它的任何算法可以是递归的。</li>
<li>按照中序遍历次序对二叉树进行线索化，对遍历到的每一个结点，先线索化其左子树，再线索化当前结点，最后线索化其右子树。</li>
<li>设置两个结点指针，分别指向遍历过程中的当前结点和它的前驱结点。</li>
<li>当前结点的左线索化和其前驱结点的右线索化同时进行.</li>
<li>若当前结点无左子树，构造其左线索(Lthread= true)及标志，若其前驱无右子树，则构造其前驱的右线索(Rthread= true)及标志。</li>
</ol>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs php">struct TBTreeNode    <span class="hljs-comment">//线索二叉树类型定义</span><br>&#123;<br>	<span class="hljs-keyword">bool</span> Lthread, Rthread;<br>    ElemType data;<br>    TBTreeNode *leftChild;<br>    TBTreeNode *rightChild;<br>&#125;;<br><br><br><span class="hljs-keyword">void</span> Threaded(TBTreeNode *t, <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">static</span> TBTreeNode *prenode; <span class="hljs-comment">//当前结点t的前驱指针</span><br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>        prenode = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// prenode初值为空</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">NULL</span>)      <span class="hljs-comment">//t树存在</span><br>    &#123;<br>        Threaded(t-&gt;leftChild, <span class="hljs-number">1</span>); <span class="hljs-comment">//对左子树线索化</span><br>         t-&gt;Lthread=t-&gt;leftChild==<span class="hljs-literal">NULL</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<span class="hljs-comment">//置左线索标志值</span><br>        t-&gt;Rthread=t-&gt;rightChild==<span class="hljs-literal">NULL</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<span class="hljs-comment">//置右线索标志值</span><br>        <span class="hljs-keyword">if</span> (prenode != <span class="hljs-literal">NULL</span>)    <span class="hljs-comment">//当前结点的前驱存在</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (prenode-&gt;Rthread)<br>                prenode-&gt;rightChild = t; <span class="hljs-comment">//互指</span><br>            <span class="hljs-keyword">if</span> (t-&gt;Lthread)<br>                t-&gt;leftChild = prenode;<br>        &#125;<br>        prenode = t;                <span class="hljs-comment">//t作为中序遍历后继结点的前驱</span><br>        Threaded(t-&gt;rightChild, <span class="hljs-number">1</span>); <span class="hljs-comment">//对右子树线索化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="中序线索二叉树的节点插入"><a href="#中序线索二叉树的节点插入" class="headerlink" title="中序线索二叉树的节点插入"></a>中序线索二叉树的节点插入</h3><p>在 p 所指结点与它的右子树之间插入 q 所指新结点，可以分两种情形考虑。</p>
<ul>
<li><p>P 结点存在右子树：<br>  此时将 q 结点作为 p 结点的右孩子点，p 结点原来的右子树作为 q 结点的右子树，使 q 结点作为 p 结点的后继结点，p 结点的原后继结点作为 q 结点的后继结点（将 p 结点右线索标志及右孩子指针拷贝到 q 结点），需对有关结点的线索进行赋值或修正。</p>
</li>
<li><p>P 结点不存在右子树：<br>  此时无论 p 结点是其父结点的左孩子或右孩子，将 q 结点作为 p 结点的右孩子结点前，将 p 结点右线索及标志拷贝到 q 结点即可。</p>
</li>
</ul>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xl">void InsertRight(TBTreeNode *p, TBTreeNode *q)<br>&#123;<br>    TBTreeNode *s;<br>    s = InOrderSuc(p);             <span class="hljs-comment">//s指向结点p的后继</span><br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span>Lthread = <span class="hljs-literal">true</span>;             <span class="hljs-comment">//置插入结点左线索标志</span><br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span>leftChild = p;              <span class="hljs-comment">//插入点的左线索指向p结点</span><br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span>R<span class="hljs-function"><span class="hljs-title">thread</span> = p-&gt;</span>Rthread;       <span class="hljs-comment">//复制p结点的右线索标志</span><br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">rightChild</span> = p-&gt;</span>rightChild; <span class="hljs-comment">//复制p结点的右孩子指针</span><br>    <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>Rthread = <span class="hljs-literal">false</span>;            <span class="hljs-comment">//置p结点的右线索标志为假</span><br>    <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>rightChild = q;             <span class="hljs-comment">//p结点的右指针指向新插入q结点</span><br><br>    <span class="hljs-function"><span class="hljs-title">if</span> (s != NULL &amp;&amp; s-&gt;</span>Lthread)   <span class="hljs-comment">//结点p的后继存在且有左线索</span><br>        <span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span>leftChild = q;          <span class="hljs-comment">//修正使其指向q</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p><strong>二叉排序树(Binary Sort Tree)</strong> 具有以下性质：</p>
<ol>
<li>二叉排序树可以是棵空树；</li>
<li>若它的左子树非空，则<strong>左子树的所有结点的关键字均小于根结点的关键字</strong>；</li>
<li>若它的右子树非空，则<strong>右子树的所有结点的关键字均大于等于根结点的关键字</strong>；</li>
<li>左子树、右子树本身也是二叉排序树。</li>
</ol>
<h2 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树(AVL 树)"></a>平衡二叉树(AVL 树)</h2><p>一棵平衡二叉排序树或者是空树，或者是具有下列性质的二叉排序树：</p>
<ol>
<li>左子树与右子树的高度之差的绝对值小于等于 1</li>
<li>左子树和右子树也是平衡二叉排序树</li>
</ol>
<p>平衡二叉排序树的平均查找长度为 $O(log<del>2</del>n)$<br>平衡因子：结点的左子树深度与右子树深度之差(-1，0，1)</p>
<h3 id="平衡二叉树的调整-Todo"><a href="#平衡二叉树的调整-Todo" class="headerlink" title="平衡二叉树的调整[Todo]"></a>平衡二叉树的调整[Todo]</h3><blockquote>
<p>旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子</p>
</blockquote>
<ul>
<li>  L 和 R 的自由排列组合: LR, LL, RL, RR</li>
<li>  四种组合没有什么特殊性, 只要注意超出的深度在那个子树上即可.</li>
<li>  调整原则: <strong>所有左子树节点关键字均小于其相应的根节点关键字, 右子树的所有结点的关键字均大于等于根结点的关键字</strong>.</li>
</ul>
<p>例如根节点左子树的右子树失去平衡, 就是 LR 型</p>
<h2 id="红黑树-Red-Black-tree"><a href="#红黑树-Red-Black-tree" class="headerlink" title="红黑树(Red-Black tree)"></a>红黑树(Red-Black tree)</h2><blockquote>
<p>红黑树是在AVL树的基础上发展而来的，是AVL树的一个变种<br>参考博客：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012728513">红黑树详细分析，看了都说好 - coolblog.SegmentFault</a></p>
</blockquote>
<h3 id="红黑树性质"><a href="#红黑树性质" class="headerlink" title="红黑树性质"></a>红黑树性质</h3><ol>
<li><p>每个节点非红即黑</p>
</li>
<li><p>根节点是黑的;</p>
</li>
<li><p>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p>
</li>
<li><p>如果一个节点是红色的，则它的子节点必须是黑色的。</p>
</li>
<li><p>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p>
</li>
</ol>
<h3 id="实现-Todo"><a href="#实现-Todo" class="headerlink" title="实现[Todo]"></a>实现[Todo]</h3><p>插入在叶结点，并且颜色设置为红色（参考第5条规则）</p>
<h3 id="调整操作"><a href="#调整操作" class="headerlink" title="调整操作"></a>调整操作</h3><p>主要难点在于调整，调整分为结构调整和颜色调整，颜色调整参考4</p>
<p>结构调整，左旋和右旋，和AVL树一致</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>AVL 树是高度平衡的，频繁的插入和删除，会引起<strong>频繁的rebalance</strong>，导致效率下降；<br>红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<p>所以红黑树在查找，插入删除的性能都是 $O(logn)$，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<h2 id="偏序树-堆"><a href="#偏序树-堆" class="headerlink" title="偏序树/堆"></a>偏序树/堆</h2><p><strong>优先队列(Priority queue)</strong> 中每个元素都有一个优先数，删除时，总是删除优先数最大的元素。实现优先队列的一种有效方法是将优先队列的元素组成完全二叉树，二叉树中任何结点的优先数(关键码)不小于它的子女结点的优先数(关键码)，具有这一性质的完全二叉树称为偏序树(Partially order tree)，又称最大堆。如果完全二叉树中任何结点的优先数(关键码)不大于它的子女结点的优先数(关键码)，则定义为最小堆。</p>
<h3 id="偏序树插入和删除算法"><a href="#偏序树插入和删除算法" class="headerlink" title="偏序树插入和删除算法"></a>偏序树插入和删除算法</h3><p><strong>最大堆调整示例</strong></p>
<ul>
<li><p>插入操作</p>
<ol>
<li> 元素放置到队尾( 队尾插入 )</li>
<li> 与父节点比较. 如果大于父节点, 则两者交换, 否则插入完成</li>
<li> 重复第 2 步, 父节点为空时, 插入完成</li>
</ol>
</li>
<li><p>删除操作</p>
<ol>
<li> 交换根节点和尾节点后, 删除尾节点</li>
<li> 调整偏序树: 从根节点作为父节点开始. 如果父节点小于子节点, 将父节点与子节点中最大的一个交换.</li>
<li> 父节点设为交换后的子节点, 重复第 2 步. 如果子节点为空, 或者子节点均小于父节点, 调整完成.</li>
</ol>
</li>
</ul>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>略</p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>最小权值</p>
<h3 id="构造哈夫曼树的哈夫曼算法"><a href="#构造哈夫曼树的哈夫曼算法" class="headerlink" title="构造哈夫曼树的哈夫曼算法"></a>构造哈夫曼树的哈夫曼算法</h3><ol>
<li>根据给定的 n 个权值 ${w_1,w2,\cdots,wn}$, 构成 n 棵二叉树的集合(森林）$F={T_1,T_2,\cdots,T_n }$, 其中每棵二叉树 $T_i$ 中只有带权为 $w_i$ 的根结点, 其左右子树均空。</li>
<li>在 $F$ 中选取两棵根结点的权值最小的树作为左右子树(左小右大)构造一棵新的二叉树,且置新的二叉树的根结点的权值为其左、右子树根结点的权值之和。</li>
<li>在 $F$ 中删除这两棵树,同时将新的二叉树加入 $F$ 中。</li>
<li>重复步骤 2 和 3 , 直到 $F$ 只含一棵树为止.这棵树便是哈夫曼树。</li>
</ol>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>略</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是由顶点集合(vertex)及顶点间的关系集合组成的一种数据结构：<br>$$<br>G＝( V, E )<br>$$<br>其中 V = { x | x ∈ 某个数据对象}是顶点的有穷非空集合}；<br>无向图:<br>$$<br>    E = {(x, y) | x, y ∈  V }<br>$$<br>或有向图:<br>$$<br>E = {&lt;x, y&gt; | x, y ∈  V,  Path (x, y)}<br>$$<br>顶点之间关系的有穷集合(可以为空)，也叫做边(edge)集合。$$Path (x, y)$$表示从 x 到 y 的一条单向通路, 它是有方向的。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>有向图(directed graph)</p>
<p>  有向图(Directed graph)G 是由两个集合 $V(G)$ 和 $E(G)$ 组成。<br>  其中：$V(G)$ 是顶点的非空有限集，$E(G)$ 是有向边(也称弧)的有限集合，弧是顶点的有序对，记为 $&lt;v,w&gt;$， v 为弧的起点，w 为弧头的终点, 注意 $&lt;v,w&gt;≠&lt;w,v&gt;$。</p>
</li>
<li><p>无向图(undirected graph)</p>
<p>  无向图(undirected graph) G 是由两个集合 $V(G)$ 和 $E(G)$ 组成</p>
</li>
<li><p>完全图<br>  n 个顶点的无向图拥有 n(n-1)/2 个节点, 即为完全图</p>
</li>
</ul>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul>
<li>  对由 n 个记录组成的表(或文件)L=(r1,r2,……,rn)，依据记录中某个数据项的值重新进行排列的过程称之为<strong>排序（sorting）</strong>，该数据项称为排序码，一般情况下， 总是选择记录的关键码(字)作为排序码。</li>
<li>  如果待排序的表中含有多个排序码值相等的记录，用某种排序方法排序后，这些记录的相对次序不变，则说这种排序方法为稳定的（stable），否则是不稳定的。</li>
<li>按照待排序数据驻留的介质不同排序问题可分为内部排序(Internal sorting)和外部排序(External sorting)两类：<ol>
<li> 内排序: 待排序的表中记录可存放内存，整个排序过程都在内存进行，只涉及对内存的访问。</li>
<li> 外排序: 待排序的表中含有巨量记录，无法存放到内存，整个排序过程都在外存进行，涉及对外存的访问。</li>
</ol>
</li>
<li>  按照排序的依据原则内部排序可分为：插入排序、交换排序、选择排序、归并排序和分配排序等五类。</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>顾名思义,最好的情况是已经排好序: $O(n)$, 最坏的情况是:$O(n^2)$<br>该排序是<strong>稳定排序</strong></p>
<p>请注意, 插入排序有大量的插入操作, 使用链表较为适宜</p>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>循环将数插入到已经排序的序列中, 知道未排序数组为空</p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> LMAX = <span class="hljs-number">10</span>; <span class="hljs-comment">//顺序表最大长度</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rectype</span>        //记录类型定义</span><br><span class="hljs-class">&#123;</span><br>    keytype key;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqList</span> //顺序表类型定义</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> length;<br>    rectype r[LMAX];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(SqList &amp;L)</span> <span class="hljs-comment">//直接插入排序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= L.length; i++)<br>    &#123;<br>        L.r[<span class="hljs-number">0</span>] = L.r[i]; <span class="hljs-comment">//将第i个记录复制到L.r[0]中</span><br>        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//依次后移</span><br>        <span class="hljs-keyword">while</span> (L.r[<span class="hljs-number">0</span>].key &lt; L.r[j].key)<br>        &#123;<br>            L.r[j + <span class="hljs-number">1</span>] = L.r[j];<br>            j = j - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//插入待排序数</span><br>        L.r[j + <span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>复杂度为$O(n^2)$, 如果已经有序, 则复杂度为 $O(1)$<br>该排序是<strong>稳定排序</strong></p>
<h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>对于具有 n 个元素的数组, 进行 n-1 次遍历<br>第 k 次遍历过程, 如果发现某元素小于元素[k-1], 交换两者.<br>最终实现: 最小的数放在队头, 第二小的数放在第二个……..</p>
<p>排序完成</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>又叫递减增量排序</p>
<blockquote>
<p><del>希尔排序听起来总让我想起崩坏学园</del> &gt; <del>所以我钦点了<em>希尔 · 爱乐芙</em> 作为本篇博文置顶图 23333</del></p>
</blockquote>
<p>希尔排序的性能大约为:O(n^3/2^), 这主要是因为他的递减增量<br>希尔排序是<strong>不稳定的</strong></p>
<h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><ol>
<li>取某一增量 d; 将数列按照增量 d 分成若干组;</li>
<li>对若干组进行插入排序</li>
<li>降低增量 d, 重复 1, 2 步骤直到 d 为 1;</li>
</ol>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> increment = L.length;<br>	<span class="hljs-keyword">do</span><br>	&#123;<br>		increment /= <span class="hljs-number">2</span><br>		<span class="hljs-comment">//执行插入排序</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = increment; i &lt; L.length; i++)<br>		&#123;<br>			rectype extra = L.r[i];<br>			<span class="hljs-keyword">int</span> j = i - increment;<br><br>			<span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; (extra.key &lt; L.r[j].key))<br>			&#123;<br>				L.r[j + increment] = L.r[j];<br>				j = j - increment;<br>			&#125;<br>			L.r[j + increment] = extra;<br>		&#125;<br><br>	&#125; <span class="hljs-keyword">while</span> (increment &gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序(Quick sort)</strong> 的基本思想是选取被排序表中某个关键码作为基准(pivot)，将表划分成左右两个子表： 左子表中各记录的关键码均小于或等于基准值，而右子表中各记录的关键码均大于或等于基准值。然后以同样的方法递归地处理这两个子表，直到完成全部记录的排序。<br>该排序是<strong>不稳定排序</strong></p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>对含有 n 个记录的表，若算法总是以子表中间记录的关键码作为基准划分,最坏的情况(基准为最小或最大)是每次将将表分为含 1 个记录的子表和含 n-1 个记录的子表。需划分 n 次，比较次数为：<br><strong>n*(n-1)/2=O(n^2^)</strong></p>
<p>若总是以子表的第一个记录的关键码作为基准划分, 当被排序的表是按关键码有序或逆序，将出现最坏的情况。设 c(n)为用 QuickSort 算法对含有 n 个记录的表进行排序所作的比较次数, s(n)为交换次数，显然 c(1)=0 和 s(1)=0。 算法将 n 个记录的表划分为 r 记录和 n-r 记录两个子表需比较 n 次。所以<br>​ c(n)=n+c(r)+c(n-r)<br>对于最坏情形:每次划分时 r=1, n-r=n-1, 则有:<br>​ c(n)=n+c(1)+c(n-1)=n+c(n-1)<br>于是下列诸式成立:<br>​ c(1)=0<br>​ c(2)=2+c(1)=2<br>​ c(3)=3+c(2)=3+2=5<br>​ c(4)=4+c(3)=4+3+2=9<br>​ ……..<br>​ c(n)=n+c(n-1)=n+(n-1)+(n-2)+….+3+2=(n+2)(n-1)/2<br>​ =(n^2^+n-2)/2=O(n^2^)</p>
<p>若 QuickSort 算法总是以表中关键码的中值作为基准划分,将出现最好的情况：每次将表分为两个长度大致相等的子表。<br>​ c(n)≤n+2c(n/2)<br>​ ≤n+2[n/2+2c(n/22)]=2n+4c(n/22)<br>​ ≤2n+4[n/4+2c(n/23)]=3n+8c(n/23)<br>​ ≤……..<br>​ ≤kn+2kc(n/2k)=nlog2n+nc(1)=O(nlog2n)<br>​ (这里：k=log<del>2</del>n )<br>对于交换次数, 有<br>$$ s(n)&lt;=O(nlog_2n) $$</p>
<p>快速排序是<strong>不稳定的</strong></p>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs maxima">void Qsort(int a[], int low, int high)<br>&#123;<br>    <span class="hljs-keyword">if</span>(low &gt;= high)<br>    &#123;<br>        <span class="hljs-built_in">return</span>;<br>    &#125;<br>    int <span class="hljs-built_in">first</span> = low;<br>    int <span class="hljs-built_in">last</span> = high;<br>    int <span class="hljs-built_in">key</span> = a[<span class="hljs-built_in">first</span>];<span class="hljs-comment">/*用字表的第一个记录作为枢轴*/</span><br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">first</span> &lt; <span class="hljs-built_in">last</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">first</span> &lt; <span class="hljs-built_in">last</span> &amp;&amp; a[<span class="hljs-built_in">last</span>] &gt;= <span class="hljs-built_in">key</span>)<br>        &#123;<br>            --<span class="hljs-built_in">last</span>;<br>        &#125;<br><br>        a[<span class="hljs-built_in">first</span>] = a[<span class="hljs-built_in">last</span>];<span class="hljs-comment">/*将比第一个小的移到低端*/</span><br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">first</span> &lt; <span class="hljs-built_in">last</span> &amp;&amp; a[<span class="hljs-built_in">first</span>] &lt;= <span class="hljs-built_in">key</span>)<br>        &#123;<br>            ++<span class="hljs-built_in">first</span>;<br>        &#125;<br><br>        a[<span class="hljs-built_in">last</span>] = a[<span class="hljs-built_in">first</span>];<br><span class="hljs-comment">/*将比第一个大的移到高端*/</span><br>    &#125;<br>    a[<span class="hljs-built_in">first</span>] = <span class="hljs-built_in">key</span>;<span class="hljs-comment">/*枢轴记录到位*/</span><br>    Qsort(a, low, <span class="hljs-built_in">first</span>-<span class="hljs-number">1</span>);<br>    Qsort(a, <span class="hljs-built_in">first</span>+<span class="hljs-number">1</span>, high);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>归并排序(merge sort)</strong> 是归并操作上的一种有效的排序算法<br>归并排序每次都是在相邻的数据中进行操作，在 $O(NlogN)$ 的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。</p>
<blockquote>
<p>设数列长为 $N$ ，将数列分开成小数列一共要 $logN$ 步，每步都是一个合并有序数列的过程，时间复杂度可以记为$O(N)$ ，故一共为 $O(NlogN)$ 。</p>
</blockquote>
<h3 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h3><p>对于整体无序的数列</p>
<ol>
<li>递归(recursion)分割数列为左右两部分, 直至数列不可再分</li>
<li>对当前不可再分的左右数列进行归并</li>
</ol>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//归并排序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> rear, <span class="hljs-keyword">int</span> temp[])</span> </span>&#123;<br><br>	<span class="hljs-keyword">int</span> i = front, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= rear)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (arr[i] &lt; arr[j])<br>		&#123;<br>			temp[k++] = arr[j++];<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			temp[k++] = arr[i++];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">while</span> (i &lt;= mid)<br>	&#123;<br>		temp[k++] = arr[i++];<br>	&#125;<br>	<span class="hljs-keyword">while</span> (j &lt;= rear)<br>	&#123;<br>		temp[k++] = arr[j++];<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>	&#123;<br>		arr[front + i] = temp[i];<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recursive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[],<span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> rear, <span class="hljs-keyword">int</span> temp[])</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (front&lt;rear)<br>	&#123;<br>		<span class="hljs-keyword">int</span> mid = (front + rear) / <span class="hljs-number">2</span>;<br>		<span class="hljs-built_in">recursive</span>(arr, front, mid, temp);<br>		<span class="hljs-built_in">recursive</span>(arr, mid + <span class="hljs-number">1</span>, rear, temp);<br>		<span class="hljs-built_in">merge</span>(arr, front, mid, rear, temp);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>	<span class="hljs-comment">//辅助表空间, 避免数列数组被覆写, 省去临时声明空间的时间开销</span><br>	<span class="hljs-keyword">int</span>* temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n];<br>	<span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-built_in">recursive</span>(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, temp);<br>	<span class="hljs-keyword">delete</span>[] temp;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> arr[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">123</span>,<span class="hljs-number">45</span>,<span class="hljs-number">654</span>,<span class="hljs-number">78</span>,<span class="hljs-number">96</span>,<span class="hljs-number">2</span> &#125;;<br>	<span class="hljs-built_in">mergeSort</span>(arr, <span class="hljs-number">8</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>	&#123;<br>		cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>	&#125;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是利用堆这种数据结构而设计的一种排序算法，它是一种<strong>选择排序</strong>.<br>它的最坏，最好，平均时间复杂度均为$O(nlogn)$，它也是<strong>不稳定排序</strong>.</p>
<h3 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路 5"></a>算法思路 5</h3><ol>
<li><p>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p>
</li>
<li><p>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p>
</li>
<li><p>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p>
</li>
</ol>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> rear)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span>	tmp = arr[front];<br>	arr[front] = arr[rear];<br>	arr[rear] = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> temp = arr[i];<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; k &lt; len; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-keyword">if</span> ((k + <span class="hljs-number">1</span>) &lt; len&amp;&amp;arr[k] &lt; arr[k + <span class="hljs-number">1</span>])<br>		&#123;<br>			k++;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (arr[k] &gt; temp)<br>		&#123;<br>			arr[i] = arr[k];<br>			i = k;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	arr[i] = temp;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>	<span class="hljs-comment">//1. 构建大顶堆</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>	&#123;<br>		<span class="hljs-built_in">adjustHeap</span>(arr, i, len);<br>	&#125;<br><br>	<span class="hljs-comment">//2. 交换堆顶元素和末尾元素, 调整堆</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>	&#123;<br>		<span class="hljs-built_in">swap</span>(arr, <span class="hljs-number">0</span>, i);<br>		<span class="hljs-built_in">adjustHeap</span>(arr, <span class="hljs-number">0</span>, i);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> arr[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">65</span>,<span class="hljs-number">78</span>,<span class="hljs-number">98</span>,<span class="hljs-number">45</span>,<span class="hljs-number">32</span> &#125;;<br>	<span class="hljs-built_in">sort</span>(arr, <span class="hljs-number">8</span>);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>	&#123;<br>		cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>	&#125;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><strong>基数排序 (radix sort)</strong> 属于”分配式排序” (distribution sort) , 重点在于对关键字进行 “分配” 和 “收集” , 而不是对关键字的比较.<br>基数排序算法是<strong>稳定</strong>的, 时间复杂度是 $O(d*(n＋r))$</p>
<blockquote>
<p>将表中 n 个记录分配到 r 个队列中去的时间为$O(n)$, 收集时将 r 个队列连成一个表的时间$O(r)$, 一次分配和收集的时间为$O(n＋r)$, 由于算法对 n 个记录共进行了 d 遍分配和收集,所以共花费的时间为$O(d*(n＋r))$.</p>
</blockquote>
<h3 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h3><ol>
<li>将关键码按照位数最小/最大值分配入箱</li>
<li>按照箱子的顺序收集关键码</li>
<li>重复 1，2 步骤直到位数到达最大/最小值</li>
</ol>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>最高位优先(Most Significant Digit first)，简称 MSD<br>最低位优先(Least Significant Digit first)，简称 LSD<br>下面采用 LSD 法，值得一提的是，这种实现比较耗费内存, 从理论上来说, 申请的数组空间利用率只有 10%.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*顺序数组实现*/</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> RADIX = <span class="hljs-number">10</span>;<span class="hljs-comment">//桶数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Max = <span class="hljs-number">10</span>;<span class="hljs-comment">//桶容量</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> temp = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pos - <span class="hljs-number">1</span>; ++i) &#123;<br>		temp *= <span class="hljs-number">10</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> (src / temp) % <span class="hljs-number">10</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radixSort_Array</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *src, <span class="hljs-keyword">int</span> digits)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span>* tempArray[RADIX];<span class="hljs-comment">//定义桶数 RADIX</span><br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; RADIX; ++i)<span class="hljs-comment">//定义桶容量</span><br>	&#123;<br>		tempArray[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [Max + <span class="hljs-number">1</span>];<br>		tempArray[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化为0</span><br>	&#125;<br><br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pos = <span class="hljs-number">1</span>; pos &lt;= digits; ++pos)<br>	&#123;<br>		<span class="hljs-keyword">int</span> tmp;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Max; ++i)<span class="hljs-comment">//分配进桶</span><br>		&#123;<br>			tmp = <span class="hljs-built_in">getDigit</span>(src[i], pos);<span class="hljs-comment">//获取指定位的数字</span><br>			++tempArray[tmp][<span class="hljs-number">0</span>];<br>			tempArray[tmp][tempArray[tmp][<span class="hljs-number">0</span>]] = src[i];<br>		&#125;<br><br><br>		<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;RADIX; ++i)<span class="hljs-comment">//收集</span><br>		&#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=tempArray[i][<span class="hljs-number">0</span>]; ++j )<br>			&#123;<br>				src[index++] = tempArray[i][j];<br>			&#125;<br>			tempArray[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//重置</span><br>		&#125;<br>		cout &lt;&lt; endl;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Max; i++) &#123;<br>			cout &lt;&lt; src[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>		&#125;<br>	&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> src[Max] = &#123; <span class="hljs-number">12</span>,<span class="hljs-number">123</span>,<span class="hljs-number">123</span>,<span class="hljs-number">14</span>,<span class="hljs-number">56</span>,<span class="hljs-number">78</span>,<span class="hljs-number">56</span>,<span class="hljs-number">12</span>,<span class="hljs-number">456</span>,<span class="hljs-number">789</span> &#125;;<br>	<span class="hljs-comment">/*std::cout &lt;&lt; &quot;最大三位数&quot; &lt;&lt; std::endl;</span><br><span class="hljs-comment">	for (RADIX_t i = 0; i &lt; Max; i++)</span><br><span class="hljs-comment">	&#123;</span><br><span class="hljs-comment">		std::cin &gt;&gt; src[i];</span><br><span class="hljs-comment">		cout &lt;&lt; endl;</span><br><span class="hljs-comment">	&#125;*/</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Max; i++) &#123;<br>		cout &lt;&lt; src[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>	&#125;<br><br>	<span class="hljs-built_in">radixSort_Array</span>(src, <span class="hljs-number">3</span>);<br><br>	cout &lt;&lt; endl;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Max; i++) &#123;<br>		cout &lt;&lt; src[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>	&#125;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="基数排序、计数排序、桶排序"><a href="#基数排序、计数排序、桶排序" class="headerlink" title="基数排序、计数排序、桶排序"></a>基数排序、计数排序、桶排序</h3><blockquote>
<p>三者还是比较容易搞混的</p>
</blockquote>
<p><strong>桶排序(Bucket Sort)</strong></p>
<ol>
<li><p>将待排序元素划分到不同的痛。先扫描一遍序列求出最大值 $maxV$ 和最小值 $minV$ ，设桶的个数为 $k$ ，则把区间 $[minV, maxV]$ 均匀划分成 $k$ 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</p>
</li>
<li><p>对每个桶内的元素进行排序。可以选择任意一种排序算法。</p>
</li>
<li><p>各桶进行归并排序</p>
</li>
</ol>
<p><strong>计数排序</strong><br>桶排序中令 $k= maxV-minV+1$</p>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><p>查找操作的性能主要考虑时间复杂度, 整个查找过程主要是在关键字和查找表的数据上. 即平均查找长度.<br>**平均查找长度 ASL(Average Search Length)**：为确定记录在表中的位置，需和给定值进行比较的记录个数的期望值叫查找算法的平均查找长度。</p>
<p>$$<br>ASL=\sum_{n}^{i=1}p_{i}c_{i}<br>$$</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul>
<li>  对于每次查找均成功的情况下</li>
</ul>
<p>$$<br>ASL=\frac{n+1}{2}​<br>$$</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>通过建立一个二叉查找树, 我们能很清晰的看到</p>
<p>$$<br>ASL=log<del>2</del>(n+1)-1<br>$$</p>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>分块查找，也叫索引顺序查找，算法实现除了需要查找表本身之外，还需要根据查找表建立一个索引表<br>建立的索引表要求按照关键字进行升序排序，查找表要么整体有序，要么分块有序</p>
<blockquote>
<p>分块有序指的是第二个子表中所有关键字都要大于第一个子表中的最大关键字，第三个子表的所有关键字都要大于第二个子表中的最大关键字，依次类推。</p>
</blockquote>
<h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>分块查找分为两个过程:</p>
<ol>
<li>查找块<br>可以采用顺序查找, 也可以采用折半查找</li>
<li>块内查找<br>采用顺序查找</li>
</ol>
<blockquote>
<p>总体而言, 分块查找效率介于顺序查找和折半查找之间</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Todo/">Todo</a>
                    
                      <a class="hover-with-bg" href="/tags/CS/">CS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/12/29/C++%20Programing/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Simple Tutorial for C++ Programming</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/12/Simple-tutorial-for-hexo/">
                        <span class="hidden-mobile">Simple tutorial for Hexo</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
