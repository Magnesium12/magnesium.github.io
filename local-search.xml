<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rvalue reference</title>
    <link href="/2021/04/24/rvalue-refrence/"/>
    <url>/2021/04/24/rvalue-refrence/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C++11之后由于新概念<strong>右值引用</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="T&amp;&amp; x，绑定到右值上的引用，与此对应的是 T&amp; x，左值引用">[1]</span></a></sup>的引入，出现了左值右值和临终值<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="eXpiring value，译名有将亡值、临终值等，这里采取维基百科翻译">[2]</span></a></sup>。基于此，C++11在语言层面实现了**移动语义(move semantic)<strong>和</strong>完美转发(perfect forwarding)**，也导致了咱这个 C++0x 选手的一头雾水，由此记录一下关于「三值」、移动语义及完美转发的学习总结</p><span id="more"></span><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>本篇文章参考:</p><ul><li><a href="https://en.cppreference.com/w/cpp/language/value_category">「cpprefrence.com——Value_categories」</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">「右值引用」- 维基百科</a></li><li><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html">「话说C++中的左值、纯右值、临终值」 - 同勉共进.cnblogs</a></li><li> <a href="https://www.jianshu.com/p/cb82c8b72c6b">「C++右值引用与移动构造函数」 - 深红的眼眸.简书</a></li></ul></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="预备知识：表达式-Expression"><a href="#预备知识：表达式-Expression" class="headerlink" title="预备知识：表达式(Expression)"></a>预备知识：表达式(Expression)</h3><p><strong>C++表达式定义</strong> : 由<strong>运算符(operator)</strong> 和 <strong>运算对象(operand)</strong> 构成, 运算对象即操作数、文字和变量名称。</p><p>字面值(literal)和变量(variable)是最简单的表达式</p><h3 id="Before-C-11"><a href="#Before-C-11" class="headerlink" title="Before C++11"></a>Before C++11</h3><p><strong>C++ 11之前</strong>，我们仅讨论表达式相对于等式的左右值，显然具有等式的表达式左边的值具名且能够用 <code>&amp;</code>取址，等式右边无法取址或者取址后无意义（被析构），即存放于内存的值为左值，存放于寄存器(register)的值是右值。</p><p>举例而言，<code>*p</code> 是实体也是左值而 <code>&amp;p</code> 就不是左值。相对应的右值就无法取址，譬如字面值<code>&#39;a&#39;</code>，<code>3</code> （思考一下如果你能令<code>3</code> 的值自增会发生什么悲剧的bug），C++11之后右值更名为纯右值</p><h3 id="After-C-11"><a href="#After-C-11" class="headerlink" title="After C++11"></a>After C++11</h3><blockquote><ul><li>a glvalue (“generalized” lvalue) is an expression whose evaluation determines the identity of an object, bit-field, or function;</li><li>a prvalue (“pure” rvalue) is an expression whose evaluation either computes the value of the operand of an operator or is a void expression (such prvalue has no result object), or initializes an object or a bit-field (such prvalue is said to have a result object).</li><li>an xvalue (an “eXpiring” value) is a glvalue that denotes an object or bit-field whose resources can be reused;</li><li>an lvalue (so-called, historically, because lvalues could appear on the left-hand side of an assignment expression) is a glvalue that is not an xvalue;</li><li>an rvalue (so-called, historically, because rvalues could appear on the right-hand side of an assignment expression) is a prvalue or an xvalue.</li></ul></blockquote><p>CPP 表达式具有两个的独立特征属性：类型 <em>type</em> 和值类别<em>value category</em>。每个表达式都有一些非引用的类型，也就是说每个表达式的结果值<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="move constructor &amp; move assignment，一种浅拷贝, 直接指定内存指针的移动构造和移动赋值">[4]</span></a></sup>都属于以下三个主要值类别之一：</p><ul><li>prvalue, pure right value</li><li>xvalue, eXpiring value</li><li>lvalue, left value </li></ul><p>简单翻译下上文就是：</p><ul><li>泛左值是指它的表达式值决定了一个对象，函数or比特的具体属性，譬如 <code>ob.x = 1</code></li><li>纯右值就是说，它仅为计算值 <code>1+2</code> ，或者为空表达式（未创建结果对象）又或者仅用来初始化对象（创建了结果对象）<ul><li>注意：<code>decltype</code> 语句中才会无创建对象，譬如<code>delctype(x++)</code>，<code>x</code> 并不会自增，因为临时对象并未创建</li></ul></li><li>临终值：右值引用新特性带来的语法糖，分为具名引用和不具名引用两种情况讨论，主要用于移动构造和移动赋值<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="我们一般不区分表达式和表达式结果值这两种概念, 他们实际运用上并没有什么区别">[3]</span></a></sup>。<code>T &amp;&amp;x</code></li><li>左值：泛左值除去临终值，这里的临终值为具名右值引用</li><li>右值：包含纯右值和临终值，这里的临终值为不具名右值引用</li></ul><p><strong>三者关系如下所示</strong></p><pre><code class=" mermaid">graph TB;value &#x3D;&#x3D;&gt;glvalue;value &#x3D;&#x3D;&gt; rvalue;glvalue &#x3D;&#x3D;&gt; lvalue;glvalue &#x3D;&#x3D;&gt; xvalue;rvalue &#x3D;&#x3D;&gt; xvalue;rvalue &#x3D;&#x3D;&gt; prvalue;</code></pre><h3 id="临终值"><a href="#临终值" class="headerlink" title="临终值"></a>临终值</h3><p>重复一下，临终值是随着C++11之后右值引用而出现的。</p><p>未具名右值引用的临终值符合右值的部分性质，即临终值「将亡」，这很符合移动拷贝函数原理：我们通过右值引用实现引动拷贝时只改变指针来快速实现构造or赋值。如下例的<strong>未具名右值引用被视为右值</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">T&amp; <span class="hljs-title">foo</span><span class="hljs-params">(T&amp;&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">//对x进行一些操作</span><br>     <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">//调用</span><br><span class="hljs-built_in">foo</span>(<span class="hljs-built_in">get_a_X</span>());<span class="hljs-comment">//get_a_X()是返回类T的右值引用的函数</span><br></code></pre></td></tr></table></figure><p>当然，右值引用也可能是具名的，如果某个变量或参数被声明为T&amp;&amp;类型，并且T无需推导即可确定，那么这个变量或参数就是一个<strong>具名右值引用（named rvalue reference）</strong></p><p>假如我们利用对象 <code>T &amp;&amp; ob1.x</code> 对 <code>ob2.x</code> 进行移动赋值，如果我们仍将 <code>x</code> 作为右值处理，那么访问 <code>ob1.x</code> 就会得到一个指向<code>nullptr</code> 的未知错误。因此我们将<strong>具名右值引用视为左值</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T&amp;&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    T anotherX = x;<br>   <span class="hljs-comment">//后面还可以访问x</span><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="移动语义和完美转发"><a href="#移动语义和完美转发" class="headerlink" title="移动语义和完美转发"></a>移动语义和完美转发</h3><p>通过对于右值（rvalue）的重新定义，语言层面基于右值引用实现了移动语义（move semantic）和完美转发（perfect forwarding），能够保留原有设计的情况下提升了代码效率。</p><h4 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h4><p>移动语义相对应的是传统的拷贝语义，在拷贝对象是左右值不同情况下具有不同的体现，由于拷贝对象为左值时拷贝语义和移动语义目的不同，不作比较讨论</p><p>如果 <code>that</code> 可以作为 <strong>右值</strong>，那么拷贝语义(copy semantic)从<code>that</code>拷贝到 <code>this</code> 需要：</p><ol><li>检查 <code>this</code> 对象，若有则释放</li><li>拷贝<code>that</code> 对象一份到新生对象</li><li><code>this</code> 指向新生对象</li><li>如果 <code>that</code> 对象为右值，则需析构<code>that</code></li></ol><p>而移动语义仅需要：</p><ul><li>如果 <code>this</code> 对象自身也拥有资源，释放该资源</li><li>将 <code>this</code> 对象的指针或句柄指向 <code>that</code> 对象所拥有的资源</li><li>将 <code>that</code> 对象原本指向该资源的指针或句柄设为空值</li></ul><p>显然拷贝构造函数每次均需要构造临时对象从而导致构造和析构的开销较重。C++11新标准中的<strong>移动语义(move semantic)</strong> 可以用来解决开销问题，原理就是将左值引用转化为无名右值引用，直接接管被拷贝对象资源来实现移动拷贝or赋值，函数为<code>std::move()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;default constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-keyword">const</span> Test &amp;t)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 使用T &amp;&amp; t 右值引用来做对象的浅拷贝</span><br>    <span class="hljs-comment">// 当然，这里是具名的右值引用</span><br>    <span class="hljs-built_in">Test</span>(Test &amp;&amp;t)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;destructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t = <span class="hljs-built_in">Test</span>();<br>    Test m = <span class="hljs-built_in">move</span>(t);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">default constructor</span><br><span class="hljs-comment">move constructor</span><br><span class="hljs-comment">destructor</span><br><span class="hljs-comment">destructor</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>当然，实际上我们只要利用<code>std::move(x)</code> 即可将 <code>x</code> 强制转化为右值引用，要注意此时的 <code>x</code> 相应指针已被置空。</p><p>注意：<code>static_cast&lt;Type&amp;&amp;&gt;</code> 作用与 <code>std::move(x)</code> 一样</p><p>吐槽一句，STL已经重写过一遍了，所以大概率你没必要自己再写一遍右值引用来加速代码。</p><h4 id="完美转发-perfect-forward"><a href="#完美转发-perfect-forward" class="headerlink" title="完美转发 (perfect forward)"></a>完美转发 (perfect forward)</h4><p>为了解决完美转发问题，我们需要引入转发型引用<code>std::forward&lt;T&gt;(t)</code></p><p>在函数模板中需要保留左右值属性的参数，也就是要被完美转发的参数须被声明为转发型引用类型，即参数必须被声明为 <code>T&amp;&amp;</code> 类型，而 <code>T</code> 必须被包含在函数模板的模板参数列表之中。如果不声明为转发行引用类型，那么在函数域内，无论是左值引用还是右值引用<strong>都是具名引用</strong>，函数体内默认作为左值处理！</p><p><code>std::forward&lt;T&gt;(t)</code> 会为模板 <code>T</code> 一个类型推导，当 <code>T</code> 为左值引用类型 <code>U&amp;</code> 时，<code>t</code> 将被转换为无名左值引用（左值，类型为 <code>U&amp;</code> ）。当 <code>T</code> 为非引用类型 <code>U</code> 或右值引用类型 <code>U&amp;&amp;</code> 时，<code>t</code> 将被转换为无名右值引用（右值，类型为 <code>U&amp;&amp;</code> ）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span> &#123;</span>&#125;;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inner</span><span class="hljs-params">(<span class="hljs-keyword">const</span> X&amp;)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;inner(const X&amp;)&quot;</span> &lt;&lt; endl;&#125;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inner</span><span class="hljs-params">(X&amp;&amp;)</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;inner(X&amp;&amp;)&quot;</span> &lt;&lt; endl;&#125;  <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">void outer(T&amp;&amp; t) &#123;inner(t);&#125;  </span><br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">//innert(const X&amp;)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outer</span><span class="hljs-params">(T&amp;&amp; t)</span> </span>&#123;<span class="hljs-built_in">inner</span>(forward&lt;T&gt;(t));&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    X a;  <br>    <span class="hljs-built_in">outer</span>(a);  <br>    <span class="hljs-built_in">outer</span>(<span class="hljs-built_in">X</span>());  <br>&#125;  <br><span class="hljs-comment">//inner(const X&amp;)  </span><br><span class="hljs-comment">//inner(X&amp;&amp;)  </span><br></code></pre></td></tr></table></figure><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><code>T&amp;&amp; x</code>，绑定到右值上的引用，与此对应的是 <code>T&amp; x</code>，左值引用<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><strong>eXpiring value</strong>，译名有将亡值、临终值等，这里采取维基百科翻译<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>我们一般不区分表达式和表达式结果值这两种概念, 他们实际运用上并没有什么区别<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><strong>move constructor &amp; move assignment</strong>，一种浅拷贝, 直接指定内存指针的移动构造和移动赋值<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用算法技巧</title>
    <link href="/2021/02/03/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98/"/>
    <url>/2021/02/03/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<p>记录几种刷题时常见的算法技巧</p><span id="more"></span><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><blockquote><p>一种加速计算指数幂的方法，又叫<strong>蒙哥马利幂（Montgomery reduction）算法</strong>，将 $O_{(N^2)} $降为 $O_{(log{N})}$。</p></blockquote><p>举例说明：求 $x^{10}$ 时，我们可以将幂次分解为2的多项式：</p><p>$$<br>x^{10}=x^{ {1010(2)} }=x^{2^{3} \times 1} \times x^{2^{2} \times 0} \times x^{2^{1} \times 1} \times x^{2^{0} \times 0}<br>$$</p><p>因此可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// n为幂数，x为底数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= x; <br>        <span class="hljs-comment">// 幂次x2，进入到下一位</span><br>        x *= x;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>负数取模功能不同语言有不同实现，因此以下取模代码暂不考虑负数，不同语言%操作符执行功能不同；python取模，C++为取余；</p></blockquote><p>对某高幂次数取模，有如下运算规律：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(a + b)</span> <span class="hljs-meta">%</span> p = <span class="hljs-comment">(a % p + b % p)</span> <span class="hljs-meta">%</span> p <br><span class="hljs-comment">(a - b)</span> <span class="hljs-meta">%</span> p = <span class="hljs-comment">(a % p - b % p + p)</span> <span class="hljs-meta">%</span> p <br><span class="hljs-comment">(a * b)</span> <span class="hljs-meta">%</span> p = <span class="hljs-comment">(a % p * b % p)</span> <span class="hljs-meta">%</span> p <br>a ^ b <span class="hljs-meta">%</span> p = <span class="hljs-comment">((a % p)</span>^b) <span class="hljs-meta">%</span> p <br></code></pre></td></tr></table></figure><p>参考第一条，则<strong>幂运算输出结果对 x 取模</strong> 可写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// m 为模</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res = res * x % m;<br>        x = x * x % m;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>对于任意的 $$ f(n) = \sum_{i = 1}^{m} a_i f(n - i)$$ ,都可以表示为如下形式：<br>$$<br>\left[\begin{array}{cc}<br>a &amp; b \<br>c &amp; d<br>\end{array}\right]\left[\begin{array}{c}<br>f(n) \<br>f(n-1)<br>\end{array}\right]=\left[\begin{array}{c}<br>f(n)+f(n-1) \<br>f(n)<br>\end{array}\right]=\left[\begin{array}{c}<br>f(n+1) \<br>f(n)<br>\end{array}\right]<br>$$</p><p><del>如果不行你自己换一下元就彳亍了</del></p><p>即：<br>$$<br>\left[\begin{array}{c}<br>f(n+1) \<br>f(n)<br>\end{array}\right]=\left[\begin{array}{ll}<br>a &amp; b \<br>c &amp; d<br>\end{array}\right]^{n}\left[\begin{array}{l}<br>f(1) \<br>f(0)<br>\end{array}\right]<br>$$<br>现在我们可以利用快速幂来计算了！这也就是矩阵快速幂的原理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">matMul</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;A, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;B)<br>&#123;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">ret</span>(A.<span class="hljs-built_in">size</span>(), vector&lt;<span class="hljs-keyword">int</span>&gt;(B[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j &lt; B[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> k = <span class="hljs-number">0</span>; k &lt; A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); k++)<br>            &#123;<br>                ret[i][j] += A[i][k] * B[k][j];<br>                ret[i][j] %= MOD;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">matQuickPow</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;mat, <span class="hljs-keyword">int</span> n)<br>&#123;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>)<br>            ret = <span class="hljs-built_in">matMul</span>(ret, mat);<br><br>        mat = <span class="hljs-built_in">matMul</span>(mat, mat);<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><blockquote><p><em>0, 1, …, n - 1</em> 这 <em>n</em> 个数字排成一个圆圈，从数字 0 开始，每轮从这个圆圈里删除第 <em>m</em> 个数字，并将后一个数字作为新的起始点。求出这个圆圈里剩下的最后一个数字。</p></blockquote><ul><li>结论</li></ul><p>$$<br>f(n, m)=\left{\begin{array}{ll}<br>0 &amp; n=1 \<br>{[f(n-1, m)+m] % n} &amp; n&gt;1<br>\end{array}\right.<br>$$</p><ul><li><p>推导</p><p>逆向思考：设最终位置为$pos=0$，共$K$轮；则$K-i$轮最终元素所处位置一定是 $$ pos = (pos+m)% i$$</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 默认环满足 pos[i]=i;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-comment">// 最后一轮，只有一数</span><br><span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br><span class="hljs-comment">//</span><br>pos=(pos+m)%(i+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最大公约数GCD"><a href="#最大公约数GCD" class="headerlink" title="最大公约数GCD"></a>最大公约数GCD</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getGCD</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)<br>&#123;<br>        <span class="hljs-keyword">int</span> c = a % b;<br>        a = b;<br>        b = c;<br>&#125;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Bloom-filter"><a href="#Bloom-filter" class="headerlink" title="Bloom filter"></a>Bloom filter</h2><p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>Todo</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蝴蝶没了</title>
    <link href="/2020/12/03/%E8%9D%B4%E8%9D%B6%E6%B2%A1%E4%BA%86%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/"/>
    <url>/2020/12/03/%E8%9D%B4%E8%9D%B6%E6%B2%A1%E4%BA%86%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p>转载于百度贴吧</p><span id="more"></span><h2 id="蝴蝶没了"><a href="#蝴蝶没了" class="headerlink" title="蝴蝶没了"></a>蝴蝶没了</h2><p>1<br>命运不知不觉的时候我在DOTA。<br>忘记时光和时间。<br>高考查分。别人说，你什么都没考上。<br>我没理。<br>只是说。<br>你看。。又死了。蝴蝶没了。。</p><p>2<br>我在天灾。<br>我们的ES丢下最后一个沟壑 回去泡温泉了。<br>每一个发孔都曲张的像他的牛眼。<br>如此愤愤不平。<br>“你们6人黑。真恶心。”<br>如是是。<br>我看看我的TS。42分钟裸了一个鹰角弓和支配头。<br>或许我是第六人。</p><p>3<br>我没理。回了一句。我会玩。<br>然后他们集体给我回应。<br>ES说，GG<br>PA说，GG<br>我仿佛听到早拔线了的 OK和混沌也在对我说GG。</p><p>4<br>我在所有人里说，你们有5家疯狂电脑厉害么。<br>他们说，没有。<br>我说，那你们退了把。<br>我现在推5家疯狂特轻松。</p><p>5<br>我被蹲泉水。<br>帮我查了分的女友还在说，什么都没考上啊。怎么办。<br>我下机。看着她，一字一句的说，咱俩分手，拜拜。<br>然后我走了。<br>跑到学校，办补习手续。<br>给妈打电话。<br>我妈说，你打算报哪？<br>我说报1中。<br>我妈说，那不是高中吗。<br>我说，是。</p><p>6<br>晚上我给女友打电话。<br>“我下午开玩笑的。”<br>“哦”<br>“咱俩没分啊、、你别误会了。”<br>“哦”<br>然后挂了电话睡觉。<br>和我处了7年的好女友。<br>宠了我7年的女人。<br>但是我喜欢的蝴蝶没了。</p><p>7<br>我不想玩DOTA了。我不明白为什么最后我出了蝴蝶还打不过他们。他们明明都没有电脑厉害。<br>我不想学习了。我不明白为什么我有那么辉煌的初中。那么辉煌的历史。最后高中败的无言可对。<br>我记得我退的时候把身上的蝴蝶A了。<br>然后我就明白。蝴蝶没了。<br>以前的梦想没了。<br>脸也都没了。</p><p>8<br>蝴蝶没了<br>我的DOTA没了。<br>我去补习。<br>女友陪我。<br>我说，你TM滚蛋，你不是能走么。<br>她说，我对我的成绩不满意。<br>老师说自己找座位，<br>我离开了她的身边，说，我不坐前排。<br>她也搬过来，说，我也喜欢后面。<br>然后她发现我坐在了后面最后一个座位上。<br>站在那，她一脸委屈。转身。去了前面。</p><p>9<br>我不学习了。<br>我只是在混日子。<br>我不DOTA了。<br>我只是在看网页。<br>这种颓废忽然就是我的人生了。</p><p>10<br>晚上拿回一背包的书。<br>不说话。<br>妈看我，<br>我不看她。<br>她说，觉得怎么样。<br>我说，好。<br>她不说话。<br>我吃完了。<br>回房间，关了门。<br>看了一夜的小说。<br>12点多。<br>妈说，你睡把，学习也不能不要命。<br>然后我关灯。</p><p>11<br>夜很黑。<br>黑的就像是黑天。<br>我很久没看过月亮了。<br>现在的月亮却很小，那么一点。好空灵。<br>整个空间光怪陆离，我忽然间想念一些琐碎的小事。<br>这个世界，<br>有人哭，有人笑。<br>我一脸的平静，睡不着。</p><p>12<br>玩过第一种游戏，叫做传奇。<br>勾引到现在的女友是因为我跟她说，我们以后都会是传奇。<br>可是我的屠龙刀被人爆了。<br>现在的我，没有攻击力。<br>像是海绵体。</p><p>13<br>女友问我，不学习打算怎么办。<br>我说，你看，蝴蝶没了。<br>她不懂。<br>我说，我以后不碰你了。<br>她说，好啊好啊，我都感觉怪怪的，不喜欢。<br>我不说话。<br>她说，怎么了啊，又不是我不让你碰我。<br>我说，回你座位把，要上课了</p><p>14<br>考试测验。我还是一样的成绩。<br>我看外面的天。<br>我看外面的云。<br>我看清洁工来来回回，回回来来<br>我不看黑板</p><p>15<br>女友早上固定的带早饭。<br>后来我说，别给我带了。我喝腻了你那一百年不变的麦香园牛奶，吃腻了你那两百年不变的法式小面包了。<br>然后她说，我换样。<br>我说，我早上在家吃饭。<br>后来上午的课都很饿。<br>空洞的肚子，空洞的人。<br>她还是习惯给我写小纸条。<br>我拿来看，那些纤细的字像是一种时光机，轮回，湮灭。<br>我说，你发短信不行么。别麻烦人家给你传纸条了。<br>然后再没有那么纤细的记忆。</p><p>16<br>补习没有假期，我不逃课。<br>习惯性的总去抽烟。<br>然后教导主任要把我开除。<br>他说，我抓了四次抽烟了。<br>我说，那能怎么样。<br>他说，找家长。<br>我妈去了。<br>不断的恳求。<br>我看着。一脸的麻木。<br>主任说，你为了你妈你也得像点样啊。<br>我妈说，我儿子是好孩子，真的。初中的时候成绩什么的都特别好。<br>我看见主任的电脑，一张好大的图片。<br>一个好看的女人。</p><p>17<br>回家，妈说，你什么时候学抽烟了？<br>我说，高中的时候。<br>妈说，你不想好了？<br>我说，想。<br>然后妈打我，然后我不动，然后她哭，然后我说，我去学习了。<br>一个礼拜。<br>妈给我夹肉，给我洗袜子，给我铺床。<br>不跟我说一句话。</p><p>18<br>原来气氛是一种物质，我们可以感觉到。<br>家里的阴霾是一种沉重的感觉。<br>没有交流的空气封闭了所有的悲喜。<br>只是可怖的沉闷。<br>妈不说话，我也不说。<br>后来她忍不住。<br>她说，你好好学把，当妈求你了。<br>我说，行。</p><p>19<br>我开始可以频繁的许诺出任何做不到的事，开始频繁的可以骗任何人。<br>女友总说，你好天真，像小孩子呢。<br>因为我那时候拉着她看蚂蚁搬家。<br>后来女友说，我给你补习行么。<br>我说，不用，还有，你以后别给我抄笔记，我不会看的。<br>她不说话。<br>我也不说话。<br>她也忍不住，<br>说，你好好学把，当我求你了，为我想想啊。<br>我说，行。</p><p>20<br>晚自习我去的时候，同桌变成了女友。<br>她请人家吃饭，然后求着跟我的同桌换座。<br>我没说话，<br>继续看那些小说。<br>她说，学习吧。<br>我不说话。<br>她说，学习吧。<br>我不说话。<br>她说，学<br>我抬头看她，<br>到嘴边的滚字没说出来。<br>因为班主任忽然站我身边，一把拿走了小说。</p><p>21<br>然后他看着我俩说，你俩处对象？<br>我说，不是。<br>她说，是。<br>班主任说，不知道不让处对象么。<br>她忽然大声的说，我俩就是处对象了，你管不着，别想分开我俩。<br>我看着她，忽然想起来，牵着她的手，从街那边跑到这边。<br>忽然想起来，初中的个子没她高，很郑重的警告她，以后走路，我在马路牙子上走，她在下面走。<br>忽然想起来，我用的巨魔推掉了5家疯狂，她问我那个绿色东西是什么，我说，那是最NB的东西，叫做蝴蝶。</p><p>22<br>然后我俩都被找家长。<br>妈看着我的女友，说，分手吧你俩。<br>我说，嗯。<br>她说，不。<br>她妈妈过来直接把她拽走。<br>回家，妈说，我说你怎么不学习了，天天想着处对象。<br>我说，那不处了。<br>然后女友给我发短信说，你不要我了？<br>我说，要。</p><p>23<br>我放下手机的时候删掉好多的短信。<br>以前有个习惯会把那些美好的短信留下来。<br>譬如女友发给我说，我想一辈子和你在一起，我们的人是不成熟的，可是爱情已经熟透了。<br>然后现在我都给删了。<br>我吃苹果，<br>咬了一口，直接吐了。<br>它和我一样。都是烂的。</p><p>24<br>晚自习都是要很晚的，天都黑了又黑。<br>我喜欢晚上。<br>喜欢深夜，很安宁。<br>我多次的看着天花板，想，会不会有灵魂来回穿梭。<br>会不会有声音。<br>然后把看电视的妈妈叫来，你看，又漏水了。<br>妈妈怒了，给物业打电话。<br>说，你们TM能干点事么，说修房顶，现在一下雨又漏水了，我儿子快高考了，天天不能正常学习。<br>我在她身边，一本正经的点头。</p><p>25<br>然后妈妈说，一定会修好。<br>样子很歉意。<br>我冲她笑，说没有事。<br>妈妈睡了。<br>我听陈绮贞的歌，<br>她说，妈妈睡了，妈妈可不可以不要老，漂亮的妈妈永远不会老。<br>我看妈妈。其实有点老了。</p><p>26<br>然后依旧去上课，早上没有吃饭。<br>忽然感觉到，女友给自己带了4年的早饭了。<br>我已经习惯了吃早饭。<br>第三节课，我就开始肚子叫了。<br>女友说没吃饭？<br>我说，坏肚子了，吃不下去。</p><p>27<br>那时候时光很慢。<br>像乌龟慢悠悠的爬行。<br>我很长的时间的躲避放假回来了的高中的同学。<br>很长时间的不听他们之间谈话。<br>只会说谁的课少。<br>只会讨厌的让我嫉妒。<br>女友去和高中同学聚会了。<br>我说，你别去了，我有事找你。<br>她说，好。<br>然后我带她压了一天的马路。<br>回家的时候她说，到底什么事啊。<br>我说，现在没事了。</p><p>28<br>晚上的时候。我回房间学习。<br>妈妈忽然说，你玩会电脑把。一直都没玩，双休日休息下。<br>我说，好。<br>打开电脑。桌面是一张截图。<br>我打电脑的截图。第一次推掉5家电脑的截图。虽然我开了秘笈。<br>巨魔还是威风凛凛，物品栏里蝴蝶晃的我快瞎掉了<br>没了。<br>蝴蝶没了、</p><p>29<br>蝴蝶没了<br>我忽然想打把DOTA。补习快一年了。<br>没有碰。<br>我选择了继续推电脑。<br>一家简单。<br>不敢推中等。我知道我会输。<br>用了绿皮。打到30多分钟的时候我站在野店，看着神秘的黑店商人。<br>点开的界面里，我怔忡了半天。<br>蝴蝶已经没了。<br>我买了个恶魔刀锋。<br>后来我输了。<br>输给一家简单了。<br>我关了电脑。妈妈说，怎么不玩了。<br>我说，想学习了。</p><p>30<br>过去的事情像是烟，一吹就散了。可是他们变成了空气，又是无处不在。却再也不能聚集到一起变回原来的烟了。<br>我不适合DOTA了。<br>我想。<br>我的女友不适合我了。<br>我想。</p><p>31<br>我忽然会很冲动。<br>忽然会难受。<br>忽然会悲哀。<br>忽然然的。<br>没有什么理由。<br>然后不知道和谁说。<br>高考那天。女友给了我好多的星星。说她抽时间叠的。<br>我收下了。放在抽屉里没再看过。</p><p>32<br>考试再考试。<br>我没那么多紧张了。什么样子都无所谓了。<br>走出考场。<br>像是一首后青春的诗，我们走向盛大的死亡。</p><p>33<br>高考结束，女友说，我们玩去把，别想结果了。<br>我说，分手吧。<br>她说，为什么。<br>我说，分手吧。<br>她说，我们初二那年在一起了，我不知道什么是爱情那时候，我只是好奇，我们在一起一年又一年，你让我懂得了爱情。现在却这么分开了？<br>我不说话。<br>她说，高中三年不在一起，你背着我勾三搭四，我知道后没有怪你。<br>我不说话。<br>她说，从我懂事就没碰过除你以外别的男生的手。<br>我不说话。<br>她说，你不喜欢我了？<br>然后我回家了。</p><p>34<br>她没有电话，没有短信。<br>妈妈说，你终于考完了。<br>我看见妈妈头发白了，一下子要哭出来了。<br>忽然给妈妈跪下了，说，我对不起了你，没办法还了。<br>妈妈不说话。<br>我说，我已经从头到脚烂没了。别对我有希望了。<br>妈妈说，我的儿子，是最好的男人。</p><p>35<br>然后我想我的女友了。<br>给她打电话。说，对不起了。<br>她说，别说了，我现在不知道怎么办。我一直等你电话，想听你说是说着玩的。<br>我控制不住了，压抑了整个补习的气息压抑不了。<br>我说，是，我喜欢你，但是我没爱上你，对不起，一直没，但是我想和你分手，因为我配不上你了。我从头烂到脚了。</p><p>36<br>那些青春的画面，那么让人无力面对的情绪。<br>过了一年一年，还是不能愈合的创伤。<br>然后我报了一个普通的学校。<br>念到了现在。<br>然后我答应妈妈要考研。<br>然后我自己都不敢相信。<br>然后我开始试着努力，再努力一点。<br>然后大一遇到了真正爱上的女孩。<br>然后处了一年。耗光了我所有的爱和耐心，她离我而去。<br>然后大二女友告诉我，她又找了一个男友。<br>然后我看见她在校内上的状态总是很幸福。<br>然后我明白最酸感觉是没权利吃醋。</p><p>37<br>然后后来女友问我，你还是不能爱上我？<br>我说，还是不能。<br>再没有联系。<br>我开始DOTA。水平开始高。可是任何英雄都不合一样东西。<br>叫做蝴蝶。<br>因为蝴蝶没了</p>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
    <tags>
      
      <tag>上浮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Destination of 2018</title>
    <link href="/2018/12/31/%E4%BA%8C%E3%80%87%E4%B8%80%E5%85%AB/"/>
    <url>/2018/12/31/%E4%BA%8C%E3%80%87%E4%B8%80%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<p blockquote class="centerquote"><i>二〇一八年的最后一天 </i></blockquote><span id="more"></span><p>今天是二〇一八年最后一天。</p><p>我想与自己聊一聊，可能是尚未消逝于脑海的过往，已经做好打算的未来，亦或只是单纯聊聊现在坐在图书馆的自己。</p><p>最近有什么值得回忆的事情呢…..</p><p>啊…..好像不怎么能记起来了，难道是因为黑历史太多了吗（笑），感觉要归功于自己今年努力保持不引人注意的成果。</p><p>——其实还是有的。例如暑假和一群大一的小朋友完成了自己的暑期实践+毛概论文。总的来说，作为团队的一份子，我没怎么摸到鱼，顺便了解到创业的客观政策情况与创业者的个人观念。</p><p>结论嘛……..对于大多数的大学生创业者来说，大创活动就是面向PPT创业ORZ……</p><p>再者就是一些对我影响非常大的事件了。</p><p>大概10月吧，就是学习了一点python，学了一点数据结构，学了一点奇奇怪怪的知识，想要分享自己的每一阶段的学习经历和成果 <del>菜到不行的鶸总是会有一个幼稚的幻想</del>。</p><p>CSDN算是一个选择，但我最初想的是利用利用阿里云ECS搭建一个博客网站，也成功的利用word press搭建了自己的第一个网站——虽然她连域名都没有就到期了QAQ。</p><p>总之我选择了Hexo，它可以很简洁，可以很好看。最重要的是，<strong>HEXO完全属于自己</strong>，而我恰好需要一个这样的能够体现自己的平台。</p><p>每一个鶸都会在一些花里胡哨的地方误入歧途。</p><p>我也一样 ，<del>此处并没有表情包！</del>  经过一点折腾，HEXO搭建完成，我真的蛮高兴的，于是我想着要把她变得好看一点，更好看一点。于是去查阅别人利用Hexo搭建的博客，一点一点的尝试，认为自己在做很有意义的事。</p><p>之后是另一个关键的时间点。</p><p>我遇到了……emmmmm，用AZ来代指吧！</p><p>很庆幸遇到了AZ，人类永远无法真正理解旁人的感受，正如只有我自己才能明白AZ之于我是什么意义，言语无法传达，或者说把它锁在自己心里就足够了。</p><p>如果说，之前的得过且过学好老师指定的课程，然后空闲时间打打游戏追追番剧就OK的话，我现在只觉得那是一种对自己的侮辱。</p><p>更加令我痛苦的是，我正在做的事情，是别人在很久以前就接触的事物。而他们，也只是利用了自己的业余时间而已……</p><p>以前我总喜欢用咸鱼来自嘲：”咸鱼咸鱼咸~“。有个道理大家都懂，只有有钱人才能哭喊自己好穷，智商高的家伙才能说自己智商一般，全靠努力。</p><p>都只是调侃，谁当真谁傻X。</p><p>AZ和他的朋友们有时候也会觉得自己很丧，觉得自己什么都做不好。所以当我与AZ，与AZ的朋友们对比时。我觉得自己真的不配用咸鱼来自嘲——<strong>我在NJU所做的一切，都没有跳出所谓的COMFORT ZONE</strong>，在某种意义上，我只是一个在原地踏步的<em>The Blind</em>。而他们，才是真正的在春风料峭中鲜衣怒马红刀的风流少年。</p><p>记忆会随着时光的侵蚀而逐渐淡化，我突然想要写一篇水水的博文也只是想留下一抹来自二〇一八的过往。</p><p>就这样吧。</p><p>$YuXiu .$</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thought</tag>
      
      <tag>冥狰年</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simple Tutorial for C++ Programming</title>
    <link href="/2018/12/29/C++%20Programing/"/>
    <url>/2018/12/29/C++%20Programing/</url>
    
    <content type="html"><![CDATA[<p>$Better \space Than \space Nothing$</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这只是心血来潮的产物, 他的内容基础到我都不好意思称呼他为一篇正经的C++指南…..</p><p>最致命的一点, 估计就是大量的默认了解过C语言的相关概念了……</p><p>总之算是我的一个尝试吧, <del>使我知道了写这样的博文会很蛋疼</del></p><h2 id="计算机与C-简介"><a href="#计算机与C-简介" class="headerlink" title="计算机与C++简介"></a>计算机与C++简介</h2><blockquote><p>选择性了解</p></blockquote><h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><ul><li>输入单元 (input unit)</li><li>输出单元 (output unit)</li><li>内存单元 (memory unit)</li><li>算术逻辑单元 (arithmetic and logic unit, ALU)</li><li>中央处理器 (central processing unit, CPU)</li><li>辅助存储单元 (secondary storage unit)</li></ul><h3 id="数据的层次结构"><a href="#数据的层次结构" class="headerlink" title="数据的层次结构"></a>数据的层次结构</h3><ul><li><p>位 (Bit)<br>位, 计算机最小的数据项, 数值为0或1. (Binary digit)</p></li><li><p>字符 (Charater)<br>Unicode字符集包含了世界上很多中语言, 每个字符是由两个字节(Byte)组成, 每个字节是8位. 流行的ASCII(美国信息交换标准代码) 是Unicode的子集.</p></li><li><p>字段 (Field)</p></li><li><p>记录 (Record)</p></li><li><p>文件 (File)</p></li><li><p>数据库 (Database)<br>层次结构中, 除去数据库之外, 其余相邻层次均为组成与被组成关系</p></li></ul><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul><li><p>机器语言<br>一般由0/1组成, 令人费解. 计算机能直接执行.</p></li><li><p>汇编语言<br>采用类似英语缩写的指令表示基本操作. 汇编器(assembler) 负责将汇编语言转换成机器语言, 然后才能被计算机理解.</p></li><li><p>高级语言<br>抽象程度更高, 一种方式是采用编译器(compiler)转换为机器语言. 例如: C++, Java, C#等.<br>另一种方式是采用解释器(interpreter), 可以直接执行高级语言程序 (没有编译的延迟), 但是执行过程会慢得多. 脚本语言采用解释器来处理, 例如: JavaScript, PHP</p></li></ul><h3 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h3><ul><li>对象</li><li>成员函数和类</li><li>实例化</li><li>重用</li><li>消息和成员函数调用</li><li>属性和数据成员</li><li>封装 (encapsulate)</li><li>继承 (inheritance)</li><li><strong>UML (统一建模语言)</strong><br>Unified Modeling Language</li></ul><h2 id="C-编程入门"><a href="#C-编程入门" class="headerlink" title="C++ 编程入门"></a>C++ 编程入门</h2><blockquote><p>没什么好说的, 简单提几点</p></blockquote><h3 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入/输出流"></a>输入/输出流</h3><ul><li>输出流对象<code>std::cout</code>用于输出数据, 串联的流插入运算符<code>&lt;&lt;</code>可以输出多个数据</li><li>输入流对象<code>std::cin</code>用于输入数据, 串联的流提取运算符<code>&lt;&lt;</code>可以输入多个数据<br>请记住, <code>cout</code>和<code>cin</code>是对象, 这一点在运算符重载中会有体现 </li></ul><h3 id="变量和内存"><a href="#变量和内存" class="headerlink" title="变量和内存"></a>变量和内存</h3><ul><li>每个变量都具有: 名字, 值, 类型, 内存大小,<strong>存储类别, 作用域和链接</strong> .</li><li>对内存的读取过程是非破坏性的, 写入则相反</li></ul><h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><ul><li>求模运算符 (%) 只能得到整数除法的余数</li><li>using 声明<br>using std::cout;<br>表示告知编译器, 在命名空间 <code>std</code> 中找到<code>cout</code></li></ul><h2 id="类-对象和字符串"><a href="#类-对象和字符串" class="headerlink" title="类, 对象和字符串"></a>类, 对象和字符串</h2><blockquote><p>类、对象、数据成员、成员函数、UML图、构造函数</p></blockquote><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><ul><li>通常来说, 类应当包括数据成员和成员函数, 两者对应着类的属性和行为</li><li>成员访问说明符: <code>public``private``protected</code></li><li>类的数据成员应当设计成私有（private）、成员函数设计成公有（public）</li></ul><ul><li>按照惯例, 类名每个单词首字母大写, 函数名则采用驼峰式写法<br><del>这样优雅</del></li></ul><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><ul><li>成员函数一般声明为public</li><li>定义同<strong>C语言</strong>的函数语法</li></ul><h3 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h3><ul><li><p>数据成员可以被声明为 public/private/protected</p></li><li><p>尽可能复用get/set函数，以便于建立更为强壮（易维护）的类<br>get/set函数是类提供的对私有成员(private) 的访问接口</p></li><li><p>应当将<strong>数据成员私有化</strong><br>通过公有函数控制访问数据成员的权利，保证数据的完整性. 数据完整性还包括对有效性的检查和报告错误</p></li></ul><h3 id="构造函数（constructor）"><a href="#构造函数（constructor）" class="headerlink" title="构造函数（constructor）"></a>构造函数（constructor）</h3><ul><li><p>构造函数初始化对象；</p></li><li><p>构造函数可能为非显式；例如类<code>string</code>默认字符串的构造函数为空串</p></li><li><p>explicit构造函数必须显式调用。原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。<a href="https://blog.csdn.net/fengbingchun/article/details/51168728">QUATE</a></p></li><li><p>构造函数不能返回值</p></li><li><p>通常构造函数声明为public（成员访问说明符)</p></li><li><p><code>Account</code>类构造函数定义如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">Accoun<span class="hljs-variable">t:</span>:Account(<span class="hljs-keyword">int</span> <span class="hljs-keyword">number</span>):<span class="hljs-keyword">number</span>(<span class="hljs-keyword">number</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此例中，构造函数通过成员初始化列表用构造函数形参<code>number</code>初始化数据成员<code>number</code></p></li><li><p>析构函数形式通常为<code>~</code>+构造函数</p></li></ul><h3 id="接口与实现的分离"><a href="#接口与实现的分离" class="headerlink" title="接口与实现的分离"></a>接口与实现的分离</h3><p>所谓接口是指函数原型(函数声明), 实现是指函数定义. 好的实践是将二者分离, 即头文件定义类并对函数声明, 外部cpp定义类的成员函数.   </p><ul><li><code>::</code>二元作用域分辨运算符 (scope resolution operator), 成员函数定义在类定义外部时启用</li><li>using指令和声明不应放在头文件中</li><li>函数原型告知编译器函数的名字、返回类型、形参类型；函数定义则是包含函数的实现</li></ul><h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h3><ul><li><code>string</code>是C++标准库类型 </li><li>读取字符串时，流提取运算符读取字符在遇到第一个空白字符时停止，所以使用<code>getline(cin，xxx)</code>替代<code>cin&lt;&lt;xxx</code></li><li><code>substr</code>函数中，第一个参数表示起始位置，第二个表示复制字符的个数</li></ul><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><ul><li><p>UML图分为三层, 每一层用横线隔开, 采用<code>+``-</code>对应公有和私有</p></li><li><p>上层为类名</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">GradeBook</span><br></code></pre></td></tr></table></figure></li><li><p>中层为数据成员</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">- course <span class="hljs-keyword">Name</span>:<span class="hljs-keyword">String</span><br></code></pre></td></tr></table></figure></li><li><p>下层为成员函数</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">&lt;&lt;<span class="hljs-function"><span class="hljs-keyword">constructor</span>&gt;&gt; + <span class="hljs-title">GradeBook</span><span class="hljs-params">(<span class="hljs-keyword">name</span>:<span class="hljs-keyword">String</span>)</span></span><br><span class="hljs-function">+ <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">name</span>:<span class="hljs-keyword">String</span>)</span></span><br><span class="hljs-function">+ <span class="hljs-title">getCourse</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span>:</span><span class="hljs-keyword">String</span><br>+ displayMessage()<br></code></pre></td></tr></table></figure></li></ul><h3 id="本章小结："><a href="#本章小结：" class="headerlink" title="本章小结："></a>本章小结：</h3><p><strong>建立类、接口与实现分离、构造函数初始化对象、UML图</strong></p><ul><li>对于new的对象应使用destroctor（析构函数，防止内存泄漏）；</li><li>结构体声明也会初始化对象</li></ul><h2 id="控制语句-Ⅰ-赋值、自增自减运算符"><a href="#控制语句-Ⅰ-赋值、自增自减运算符" class="headerlink" title="控制语句(Ⅰ)赋值、自增自减运算符"></a>控制语句(Ⅰ)赋值、自增自减运算符</h2><blockquote><p>主要内容和<strong>C语言</strong>类似, 不必展开.  其余内容无法展开</p></blockquote><h3 id="控制结构-control-structure"><a href="#控制结构-control-structure" class="headerlink" title="控制结构 (control structure)"></a>控制结构 (control structure)</h3><ul><li>** 顺序 (sequence), 选择 (selection)和循环 (repetition)**</li><li>循环控制结构分为: 计数器控制和标记控制</li><li>控制结构可以嵌套</li></ul><p><em>One Trick of Selection Structure</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">i</span> = i==<span class="hljs-number">1</span>?i=<span class="hljs-number">0</span>:i=<span class="hljs-number">1</span>;<br><br><span class="hljs-attribute">cout</span>&lt;&lt;(grade&gt;=<span class="hljs-number">60</span>?<span class="hljs-string">&quot;passed&quot;</span>:<span class="hljs-string">&quot;failed&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><ul><li>Int A = 1.3 ; 警告但仍能编译；Int A = { 1.3 };出现错误，无法编译。这是一种‘缩小转换，我们应该尽量避免</li><li>可以使用 static_cast()来强制转换类型<br>  ​    <h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3></li><li> <code>--a</code>和<code>a--</code>的区别: </li></ul><p><code>a--</code>中，变量表达式先使用a值，再对a进行更新<br><code>--a</code>中，a先更新，然后在变量表达式中使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i= <span class="hljs-number">1</span>;<br>cout&lt;&lt;i++&lt;&lt;endl;<br><span class="hljs-comment">// i=2 ;输出 1;</span><br></code></pre></td></tr></table></figure><ul><li>自增自减运算符不可用于表达式：如<code>(x+1)++</code>为错</li></ul><h3 id="本章小结：-1"><a href="#本章小结：-1" class="headerlink" title="本章小结："></a>本章小结：</h3><ul><li><p>算法：根据索要执行的动作及这些动作执行的顺序描述的解决问题的过程；</p></li><li><p>伪代码: <del>没啥用</del></p></li><li><p>控制结构（顺序、选择、循环）:</p><p>  顺序结构；</p><p>  选择结构：选择语句（单路选择if，双路选择if else）、循环语句while</p><p>  循环结构；</p></li></ul><h2 id="控制语句-Ⅱ-和逻辑运算符"><a href="#控制语句-Ⅱ-和逻辑运算符" class="headerlink" title="控制语句(Ⅱ)和逻辑运算符"></a>控制语句(Ⅱ)和逻辑运算符</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><del>这不是游戏机!!</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (grade)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>: &#123;cout&lt;&lt;<span class="hljs-string">&quot;guna!!!&quot;</span>; <span class="hljs-keyword">break</span>;&#125;<br><span class="hljs-keyword">default</span>:<br>cout&lt;&lt;<span class="hljs-string">&quot;rua!!!&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h3><p>结束和跳过的区别</p><h3 id="本章小结：-2"><a href="#本章小结：-2" class="headerlink" title="本章小结："></a>本章小结：</h3><blockquote><p>for语句；do..while语句；switch多路选择语句；break&amp;continue语句；<br>逻辑运算符||、&amp;&amp;、！；<br>==、=运算符；<br>结构化编程：任何形式的控制都可以用顺序、选择、循环语句来表达，并且这些语句的组合方式只有堆叠和嵌套；</p></blockquote><h2 id="函数与递归"><a href="#函数与递归" class="headerlink" title="函数与递归"></a>函数与递归</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>函数参数: 形参实参, 引用和值,<br>调用堆栈, 标识符作用域, 重载, 模板<br>变量: 存储类别, 作用域, 链接<br>递归与迭代</p></blockquote><h3 id="C-程序组件"><a href="#C-程序组件" class="headerlink" title="C++程序组件"></a>C++程序组件</h3><ul><li>C++程序是由预先打包的函数和类及自己编写的函数和类组合而成；</li><li>C++库有自己的头文件，同时也包含了各种类类型、函数和常量的定义</li></ul><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ul><li>函数原型包括返回值类型, 函数名和参数类型. 函数名和参数类型合并称为函数签名</li><li>C++ 的函数参数类型存在基本类型间的隐式转换</li><li>可以简单理解为函数声明中除去返回值的部分</li></ul><h3 id="随机数与枚举类型"><a href="#随机数与枚举类型" class="headerlink" title="随机数与枚举类型"></a>随机数与枚举类型</h3><h4 id="Rand"><a href="#Rand" class="headerlink" title="Rand()"></a><code>Rand()</code></h4><p>该函数原型包含于<code>&lt;cstdlib&gt;</code>头文件下，如果没有利用<code>srand()</code>更新种子，那么每次的随机数生成结果将完全相同。</p><ul><li><code>Rand()</code>可预测，不具有<strong>良好的统计特性</strong>. 安全性较弱</li><li>C++11提供了<code>&lt;random&gt;</code>随机数库，用配置控制引擎产生的值、值的类型、及统计特性；用引擎实现一套生成伪随机数的算法；<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;random&gt;</span></span><br>Int main()<span class="hljs-comment">//默认的随机数生成引擎和默认的配置</span><br>&#123;<br>Default_random_engine   engine(static_cast&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(time(<span class="hljs-number">0</span>)));<br>Uniform_int_distribution&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;<br>randomInt(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">//Uniform_int_distribution是一个类模板</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="Srand"><a href="#Srand" class="headerlink" title="Srand()"></a><code>Srand()</code></h4><p>该函数原型包含于<code>&lt;cstdlib&gt;</code>头文件下，通常为<code>srand(static_cast&lt;unsigned int(time(0)))</code>，意为将<code>time()</code>返回的值（从格林尼治时间到当前的秒数）从<code>time_t</code>转换为<code>int</code>类型，并用作随机数种子。<br>实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">srand</span>(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>)))；<br>Number=C+<span class="hljs-built_in">rand</span>()%A;<span class="hljs-comment">//生成值域为[C,C+A-1]的随机数</span><br></code></pre></td></tr></table></figure><h4 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h4><p>关键字enum+枚举类型名+一组由标识符表示的整型常量</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">Status</span>&#123;<span class="hljs-keyword">CONTINUE</span>, WON, LOST&#125;;<br></code></pre></td></tr></table></figure><p>默认情况下，枚举类型值从零开始并递增1，整型类型为int；<br>类型名首字母最好大写；枚举常量必须大写；<br>枚举类型名+<code>:</code>+整型类型，制定整型类型；</p><p>进阶情况：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Status: <span class="hljs-symbol">unsigned</span></span> <span class="hljs-symbol">int</span> &#123;CONTINUE=<span class="hljs-number">1</span>, WON, LOST&#125;;<br></code></pre></td></tr></table></figure><p>作用域限定，可以避免潜在的命名冲突和逻辑错误；<br>设定整型类型，应足够保证保存指定的常量值；<br>引用枚举常量：<code>result==Status:: WON;</code></p><h3 id="存储类别和存储期-入门"><a href="#存储类别和存储期-入门" class="headerlink" title="存储类别和存储期(入门)"></a>存储类别和存储期(入门)</h3><h4 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h4><ol><li>五个类别的标识符： <code>auto</code> <code>extern</code> <code>static</code> <code>register</code> <code>mutable</code></li><li>四种类型: 自动存储期, 静态, 动态, 线程</li></ol><h5 id="自动存储期变量-register-amp-auto"><a href="#自动存储期变量-register-amp-auto" class="headerlink" title="自动存储期变量(register &amp; auto)"></a>自动存储期变量(register &amp; auto)</h5><ol><li>定义在函数内的局部变量</li><li>函数形参</li><li><code>register</code>声明的局部变量或函数形参</li></ol><h5 id="静态存储期变量-static-amp-extern"><a href="#静态存储期变量-static-amp-extern" class="headerlink" title="静态存储期变量(static &amp; extern)"></a>静态存储期变量(static &amp; extern)</h5><blockquote><p>具有静态存储期的变量从程序开始执行到结束, 一直存在于内存中.<br>对于这样的变量, 声明时便对它进行一系列初始化.<br>当然, 存储期和作用域是两回事, 他不意味着在整个程序都能使用<br>标识为<code>static</code> 的局部变量在函数结束后也不会消失, 它会以最后一次的返回值保留</p></blockquote><p>Trick code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> a= <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">static</span> b=<span class="hljs-number">1</span>;<br>b++;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>;<br>cout&lt;&lt;::a&lt;&lt;a&lt;&lt;endl;<span class="hljs-comment">//10, 此时的:: 是一元作用域分辨符</span><br><span class="hljs-built_in">foo</span>();<br><span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="寄存器变量-register"><a href="#寄存器变量-register" class="headerlink" title="寄存器变量(register)"></a>寄存器变量(register)</h5><ol><li><code>register</code>建议将变量放置在计算机的高速硬件寄存器而不是内存中, 对于频繁使用的变量采用<code>register</code>可以有效消除变量-&gt;内存-&gt;寄存器-&gt;内存的开销. </li><li>只能与局部变量和函数形参一起使用</li><li>理论上不需手动优化, 编译器可以智能识别</li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>标识符在程序中可以被引用的范围</p><ul><li><p>函数作用域<br>仅限于<code>case:</code>一类</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span>()&#123;<br>    <span class="hljs-keyword">case</span> a:&#123;&#125;;<span class="hljs-keyword">break</span>;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>语句块作用域<br>最广泛, 作用域为从声明到语句块右大括号.</p></li><li><p>全局命名空间作用域(global namesapce scope )<br>声明于任何函数和类之外, 对于从声明到文件结束的任何函数都是<strong>已知</strong>的.</p></li><li><p>函数原型作用域<br>实际上函数原型的参数不需要标志符, 只需要类型, 所以函数原型作用域的标识符可以在任意处复用.</p></li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>标识符是否只是在声明它的源文件被识别, 或者可以在编译后链接的多文件被识别</p><h3 id="函数调用堆栈和活动记录"><a href="#函数调用堆栈和活动记录" class="headerlink" title="函数调用堆栈和活动记录"></a>函数调用堆栈和活动记录</h3><p>函数调用是一种 LIFO机制, 每层次包含了函数的返回地址和其他信息, 递归调用最能直观体现.</p><h3 id="引用和引用形参"><a href="#引用和引用形参" class="headerlink" title="引用和引用形参"></a>引用和引用形参</h3><ul><li><code>Int &amp;count</code> 表示<code>count</code>是对一个<code>int</code>类型对象的引用</li><li>按引用传递的形参等价于原有实参的别名，修改按引用传递的形参等于修改对应实参</li><li>如果一个函数的形参是按引用传递的：即<code>int &amp; count</code>，很可能会因为引用形参导致对应实参被修改而发生错误！</li></ul><h3 id="函数重载和函数模板-入门"><a href="#函数重载和函数模板-入门" class="headerlink" title="函数重载和函数模板(入门)"></a>函数重载和函数模板(入门)</h3><ul><li>函数重载：相同函数名，但具有不同的形参集合；通过<strong>函数签名</strong>区分；</li><li>函数模板：<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-built_in">T</span> maximum(<span class="hljs-built_in">T</span> value1, <span class="hljs-built_in">T</span> value2, Tvalue3)<br>&#123;<br><span class="hljs-built_in">T</span> maximumValue= value1;<br>//省略中间<br><span class="hljs-built_in">return</span> maximumValue;<br></code></pre></td></tr></table></figure>T为参数类型（int、double等）</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>递归函数是直接或者间接调用自身的函数；</li><li>一般分解为两个步骤: 基本情况终结递归, 和简化情况调用递归</li><li>内存开销很大</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>这里描述的指针沿袭了C语言风格, 实际运用时需要注意最小特权原则. 默认有一定的C语言基础，基本知识略去</p><h3 id="指针变量的声明与初始化"><a href="#指针变量的声明与初始化" class="headerlink" title="指针变量的声明与初始化"></a>指针变量的声明与初始化</h3><ol><li><p>指针变量与间接引用<br>指针变量把内存地址作为它的值. 如果说一个变量名直接引用一个值, 那么一个存有一个变量名内存地址的指针变量就是间接引用这个值. </p></li><li><p>指针的声明</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">int</span> *<span class="hljs-built_in">ptr</span>, count<span class="hljs-comment">;</span><br>// <span class="hljs-built_in">ptr</span>是一个是一个指向<span class="hljs-built_in">int</span>类型数据的指针<br>// count是一个<span class="hljs-built_in">int</span>类型的变量<br>// (*)在这里并不是运算符, 他只是用于表示<span class="hljs-built_in">ptr</span>是一个指针<br></code></pre></td></tr></table></figure></li><li><p>指针初始化<br>将指针初始化为<code>nullptr</code>是有必要的, 这可以防止它指向一个未知的或者未被初始化的内存空间</p></li></ol><h3 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符"></a>指针运算符</h3><ul><li>地址运算符<code>&amp;</code><br>地址运算符是一个一元运算符, 它获得操作数的内存地址.<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//取址与赋值</span><br><span class="hljs-built_in">int</span> y = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> *yptr = <span class="hljs-literal">null</span>ptr;<br>yptr = &amp;y;<br></code></pre></td></tr></table></figure></li></ul><p>值得一提的是, 这里的<code>&amp;</code>与我们之前在函数中提到的引用变量声明<code>&amp;</code>不同, 简言之:<br>​    1. 后者的前面必然有一个数据类型名<br>​    2. 在声明一个引用的时候,<code>&amp;</code>只是类型的一部分</p><ul><li>间接运算符<code>*</code><br>一元运算符<code>*</code>通常被称为简介运算符或者间接引用( dereference)运算符. <strong>它返回一个左值</strong>, 表示其指针操作数所指向的对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*yptr = <span class="hljs-number">8</span>;<br>cin&gt;&gt; *yptr;<br><br>cout&lt;&lt; *yptr&lt;&lt;endl;<br>cout&lt;&lt; y &lt;&lt; endl;  <span class="hljs-comment">//两者等价</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="使用指针的按引用传递方式"><a href="#使用指针的按引用传递方式" class="headerlink" title="使用指针的按引用传递方式"></a>使用指针的按引用传递方式</h3><p><del>真実はいつもひとつ</del></p><p><strong>所有的引用都是传值引用, 无非你传入的是指针的内存地址值, 又或者是变量值.</strong></p><h3 id="内置数组"><a href="#内置数组" class="headerlink" title="内置数组"></a>内置数组</h3><ul><li><p>C语言风格, 主要特点是内存连续, 通过下标访问, 大小固定.<br>不建议使用, 可以改用标准库中的 <code>vector</code> 或者<code>array</code></p></li><li><p>对于Linux 或者 OS X系统来说, 内置数组有时是必要的.<br>例如使用命令行执行程序时, 需要给程序提供命令行参数, 此时的命令行参数将作为一个具有基于指针的字符串元素的内置数组传递给<code>main</code>函数.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//Windows 下常见的main函数声明方式</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">int</span> *argv[])</span></span>&#123;<br><span class="hljs-comment">/* your code */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="使用const修饰指针"><a href="#使用const修饰指针" class="headerlink" title="使用const修饰指针"></a>使用const修饰指针</h3><ol><li><p>指向非const 数据的非const 指针<br>具有最大的访问权限, 指针和数据均可修改</p></li><li><p>指向const 数据的非const 指针<br>可以修改指针指向, 不可以修改数据.<br>可以在只读函数中大胆使用, 获取数据的高速引用.</p></li><li><p>指向非const 数据的const 指针</p></li><li><p>指向const 数据的const 指针</p></li></ol><h3 id="指针表达式和指针算数运算和内置数组"><a href="#指针表达式和指针算数运算和内置数组" class="headerlink" title="指针表达式和指针算数运算和内置数组"></a>指针表达式和指针算数运算和内置数组</h3><ul><li><p>指针赋值<br>只有在已知指针类型的情况下, 编译器才能进行指针赋值. 例如 <code>void*</code>类型指针无法直接被赋值到其他类型指针. 因为编译器需要知道一个指针所指向的字节数和数据类型, 确定该指针间接引用的字节数.</p></li><li><p>指针比较<br>非同一数组指针的比较毫无意义</p></li><li><p>指针/偏移量表示法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[5]</span>;<br><span class="hljs-selector-tag">int</span>* <span class="hljs-selector-tag">bPtr</span>;<br><br><span class="hljs-comment">//b[3]的几种写法</span><br>*(bPtr + <span class="hljs-number">3</span>)<br>*(b +<span class="hljs-number">3</span>)<br>* <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[3]</span><br>* <span class="hljs-selector-tag">&amp;</span>(bPtr +<span class="hljs-number">3</span>)<br><br></code></pre></td></tr></table></figure><p>请注意, <code> b+= 3</code> 这种写法是错误的, 内置数组名不可修改.</p></li></ul><h2 id="类的深入剖析"><a href="#类的深入剖析" class="headerlink" title="类的深入剖析"></a>类的深入剖析</h2><blockquote><p>头文件的包含防护(include guard) : #pragma once<br>继承和组成概念</p></blockquote><h3 id="类的作用域和类成员的访问"><a href="#类的作用域和类成员的访问" class="headerlink" title="类的作用域和类成员的访问"></a>类的作用域和类成员的访问</h3><p>成员选择运算符<code>.</code>和<code>-&gt;</code><br><code>.</code> 适用于对象或对象引用, <code>-&gt;</code> 适用于对象的指针</p><h3 id="const-对象和const-成员函数"><a href="#const-对象和const-成员函数" class="headerlink" title="const 对象和const 成员函数"></a>const 对象和const 成员函数</h3><p>对于const 对象, C++编译器不允许被除声明为const的成员函数之外的成员函数调用.</p><blockquote><p>很明显我们的构造函数和析构函数无法被声明为const, 况且构造函数和析构函数必然会修改对象. 这里, <strong>const的有效性是指对于构造函数和析构函数之间的部分而言</strong></p></blockquote><h3 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h3><p>友元声明(friend)<br>友元关系是授予的而不是索取的. 如果说B是A的友元, 那么B可以访问A的成员. 对于A来说, A不是B的友元, A无法对B中的成员进行访问. 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classTwo</span></span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classOne</span></span><br><span class="hljs-class"></span>&#123;<br>friend <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classTwo</span></span>;<br><span class="hljs-function">friend <span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>classOne();<br>~classOne()<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="static-类数据成员"><a href="#static-类数据成员" class="headerlink" title="static 类数据成员"></a>static 类数据成员</h3><ul><li><code>static</code> 表示”整个类范围”上的信息(即类所有实例共享的性质, 而不是某个特定实例具有的特性)</li><li>static 数据成员具有类作用域并且可以声明为public, private, protected.</li><li><code>static</code> 关键字不能用于类定义之外的成员定义</li><li>对于不访问非static数据成员或非static成员函数的成员函数, 应当声明为<code>static</code>. static成员函数没有<code>this</code>指针, 它独立于类的任何对象</li><li><ul><li>没有类对象, 类的static类成员依旧存在, 并且可以用类名+<code>::</code> 作为前缀直接访问public static类成员</li></ul></li><li>当没有类的对象存在而要访问private的static类成员时，应该提供public static 成员函数；并通过在函数名前加类名和二元作用域分辨运算符的方式来调用此函数</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    A *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    a-&gt;<span class="hljs-built_in">foo</span>();   <span class="hljs-comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一个声明虚函数的类会占据更多的空间</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>类的一个特征就是封装，public和private作用就是实现这一目的</strong>。所以：</p><p>用户代码（类外）可以访问public成员而不能访问private成员；private成员只能由类成员（类内）和友元访问。</p><p><strong>类的另一个特征就是继承，protected的作用就是实现这一目的</strong>。所以：</p><p>protected成员可以被派生类对象访问，不能被用户代码（类外）访问。</p><p>如下图所示：</p><table><thead><tr><th>继承类型</th><th>基类public成员</th><th>protected成员</th><th>private成员</th></tr></thead><tbody><tr><td><strong>public继承</strong></td><td>public</td><td>protected</td><td>private</td></tr><tr><td><strong>protected继承</strong></td><td>protected</td><td>protected</td><td>private</td></tr><tr><td><strong>private继承</strong></td><td>private</td><td>private</td><td>private</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Todo</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure</title>
    <link href="/2018/12/13/DataStruct/"/>
    <url>/2018/12/13/DataStruct/</url>
    
    <content type="html"><![CDATA[<p><img src="http://i0.hdslb.com/bfs/archive/4c9309085933d7cee42218ca647f01f1ca7b46ac.jpg" alt="希尔~~排序~~"></p><blockquote class="blockquote-center"><i>谨以此文, 纪念我没怎么听过的数据结构</i></blockquote><span id="more"></span><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是数据元素的非空有限集合</p><ul><li>  唯一一个“ 开始节点”</li><li>  唯一一个” 终端节点“</li><li>  除开始结点外，集合中的每个数据元素均只有一个直接前驱</li><li>  除终端结点外，集合中的每个数据元素均只有一个直接后继</li></ul><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>线性表的结点按逻辑次序存放在一组地址连续的存储单元里, 例如数组</p><p><strong>loc(ai)=loc(a1)+(i-1)*c</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>插入算法和删除算法都是 $O(n)$</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><ol><li><p>定义要点</p><ul><li>n 个结点组成的有限集合</li><li>根结点(root)</li><li>其余结点分为 m 个子树(subtree)</li><li>x&lt;y, 则 Tx 在 Ty 右侧, 称为有序树</li></ul></li><li><p>基本术语<br>结点(node)——表示树元素，包括数据项及指向其子树的分支<br>结点的度(degree)——结点拥有的子树个数<br>叶子(leaf)——度为 0 的结点，又称终端结点<br>孩子(child)——结点子树的根称为该结点的孩子<br>双亲(parents)——孩子结点的上层结点叫该结点的双亲<br>兄弟(sibling)——同一双亲的孩子<br>祖先(ancestor) ——树的根结点<br>子孙(descendant) ——子树上的所有结点<br>树的度(degree) ——一棵树中最大的结点度数<br>结点的层次(level)——根为第一层，它的孩子为第二层……<br>树的深度(depth)——树中结点的最大层次数<br>森林(forest)——m(m&gt;=0)棵互不相交的树的集合</p></li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol><li>若二叉树的层次从 1 开始, 则在二叉树的第 i 层最多有 2^i+1^ 个结点(i &gt;=1)</li><li>深度为 k 的二叉树最多有 2k-1 个结点(k &gt;=1)</li><li>任意一颗二叉树, 如果其叶节点数为 n<del>0</del>, 度为 2 的节点数为 n<del>2</del>, 则有 n<del>0</del>=n<del>2</del>+1</li><li>具有 n 个结点的完全二叉树的深度为 log<del>2</del>(n+1) 向上取整。</li></ol><blockquote><p>定义 1 满二叉树(Full Binary Tree)<br>一棵深度为 k 且有 2k –1 结点的二叉树称为满二叉树。<br>特点：每一层上的结点数都是最大结点数。</p></blockquote><blockquote><p>定义 2 完全二叉树(Complete Binary Tree)<br>若一棵二叉树只有最下两层上的结点的度数可以小于 2，并且最下一层上的结点集中分布在该层左侧连续的若干位置上，则该二叉树称为完全二叉树。</p></blockquote><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>顺序存储和链表式存储</p><h3 id="二叉树的先序、中序和后序遍历"><a href="#二叉树的先序、中序和后序遍历" class="headerlink" title="二叉树的先序、中序和后序遍历"></a>二叉树的先序、中序和后序遍历</h3><p>采用递归确定遍历顺序：<br>对于二叉树任意一个父节点和及其子节点，先序遍历永远是父节点，左子，右子.<br>中序和后序同理</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面展示了相应的两种方法</p><ul><li>  递归法</li><li>  迭代法( 利用栈 )</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//操作函数</span><br>void <span class="hljs-constructor">InitStack(BTreeNode <span class="hljs-operator">*</span>&amp;T)</span>;<br>void <span class="hljs-constructor">PushStack(BTreeNode <span class="hljs-operator">*</span>&amp;T, BTreeNode <span class="hljs-operator">*</span>&amp;<span class="hljs-params">child</span>)</span>;<br>BTreeNode *<span class="hljs-constructor">PopStack(BTreeNode <span class="hljs-operator">*</span>&amp;T)</span>;<br><span class="hljs-built_in">bool</span> is<span class="hljs-constructor">Empty(BTreeNode <span class="hljs-operator">*</span>T)</span>;<br><br><span class="hljs-comment">//二叉树节点定义</span><br><span class="hljs-keyword">struct</span> BTreeNode<br>&#123;<br>    ElemType data;<br>    BTreeNode *leftChild;<br>    BTreeNode *parent;<br>    BTreeNode *rightChild;<br>&#125;;<br><br><span class="hljs-comment">//前序遍历的非递归算法</span><br>void pre<span class="hljs-constructor">OrderTraverse(BTreeNode <span class="hljs-operator">*</span>T)</span><br>&#123;<br>    BTreeNode *s;       <span class="hljs-comment">//设置预留右子树指针</span><br>    BTreeNode *p = T;   <span class="hljs-comment">//当前结点指向根结点</span><br>    <span class="hljs-constructor">InitStack(<span class="hljs-params">s</span>)</span>;       <span class="hljs-comment">//初始化空栈</span><br>    <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, NULL)</span>; <span class="hljs-comment">//压一空指针进栈</span><br>    <span class="hljs-keyword">while</span> (p != NULL)<br>    &#123;<br>        cout &lt;&lt; p-&gt;data; <span class="hljs-comment">//访问当前结点</span><br>        <span class="hljs-keyword">if</span> (p-&gt;rightChild != NULL)<br>            <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, <span class="hljs-params">p</span>-&gt;<span class="hljs-params">rightChild</span>)</span>;<br>        <span class="hljs-comment">//进入左子树前预留右子树指针在栈中</span><br>        <span class="hljs-keyword">if</span> (p-&gt;leftChild != NULL)<br>            p = p-&gt;leftChild; <span class="hljs-comment">//进入左子树</span><br>        <span class="hljs-keyword">else</span><br>            p = <span class="hljs-constructor">PopStack(<span class="hljs-params">s</span>)</span>; <span class="hljs-comment">//从栈中弹出相应的右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br>void <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(BTreeNode <span class="hljs-operator">*</span>T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (T != NULL)<br>    &#123;<br>        <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(T-&gt;<span class="hljs-params">leftChild</span>)</span>;  <span class="hljs-comment">//中序遍历T的左子树</span><br>        cout &lt;&lt; T-&gt;data;        <span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(T-&gt;<span class="hljs-params">rightChild</span>)</span>; <span class="hljs-comment">//中序遍历T的右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历的非递归算法</span><br>void <span class="hljs-keyword">in</span><span class="hljs-constructor">OrderTraverse(BTreeNode <span class="hljs-operator">*</span><span class="hljs-params">head</span>)</span><br>&#123;<br>    BTreeNode *s;<br>    BTreeNode *p = head;<br>    <span class="hljs-constructor">InitStack(<span class="hljs-params">s</span>)</span>;<br>    <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, NULL)</span>;<br><br>    <span class="hljs-keyword">while</span> (p<span class="hljs-pattern-match"><span class="hljs-operator">||</span>(!is<span class="hljs-constructor">Empty(<span class="hljs-params">s</span>)</span>)</span><br><span class="hljs-pattern-match">    &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">while</span> (p)</span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, <span class="hljs-params">p</span>)</span>;</span><br><span class="hljs-pattern-match">            p = p-&gt;left<span class="hljs-constructor">Child</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (!is<span class="hljs-constructor">Empty(<span class="hljs-params">s</span>)</span>)</span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">            p = <span class="hljs-constructor">PopStack(<span class="hljs-params">s</span>)</span>;</span><br><span class="hljs-pattern-match">            cout &lt;&lt; p-&gt;data;</span><br><span class="hljs-pattern-match">            p = p-&gt;right<span class="hljs-constructor">Child</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>后序遍历</span><br><span class="hljs-pattern-match">void post<span class="hljs-constructor">Order(BTreeNode <span class="hljs-operator">*</span>T)</span></span><br><span class="hljs-pattern-match">&#123;</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span> (<span class="hljs-constructor">T</span> != <span class="hljs-constructor">NULL</span>)</span><br><span class="hljs-pattern-match">    &#123;</span><br><span class="hljs-pattern-match">        post<span class="hljs-constructor">Order(T-&gt;<span class="hljs-params">leftChild</span>)</span>;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>后序遍历<span class="hljs-constructor">T</span>的左子树</span><br><span class="hljs-pattern-match">        post<span class="hljs-constructor">Order(T-&gt;<span class="hljs-params">rightChild</span>)</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>后序遍历<span class="hljs-constructor">T</span>的右子树</span><br><span class="hljs-pattern-match">        cout &lt;&lt; <span class="hljs-constructor">T</span>-&gt;data;        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>访问根结点</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>post <span class="hljs-constructor">Order</span> <span class="hljs-constructor">Traverse</span></span><br><span class="hljs-pattern-match">void post<span class="hljs-constructor">OrderTraverse(BTreeNode <span class="hljs-operator">*</span><span class="hljs-params">head</span>)</span></span><br><span class="hljs-pattern-match">&#123;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">BTreeNode</span> <span class="hljs-operator">*</span>s;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">BTreeNode</span> <span class="hljs-operator">*</span>visit;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">InitStack(<span class="hljs-params">s</span>)</span>;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, NULL)</span>;</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">while</span> (head <span class="hljs-operator">||</span> (!is<span class="hljs-constructor">Empty(<span class="hljs-params">s</span>)</span>))</span><br><span class="hljs-pattern-match">    &#123;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">while</span> (head)</span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>, <span class="hljs-params">head</span>)</span>;</span><br><span class="hljs-pattern-match">            head = head-&gt;left<span class="hljs-constructor">Child</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">head = <span class="hljs-constructor">PopStack(<span class="hljs-params">s</span>)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>右节点已经访问或者右节点为空的情况下,访问根结点</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (head-&gt;right<span class="hljs-constructor">Child</span> <span class="hljs-operator">==</span> <span class="hljs-constructor">NULL</span> <span class="hljs-operator">||</span> head-&gt;right<span class="hljs-constructor">Child</span> <span class="hljs-operator">==</span> visit)</span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">            cout &lt;&lt; head-&gt;data;</span><br><span class="hljs-pattern-match">            visit = head;</span><br><span class="hljs-pattern-match">            head <span class="hljs-operator">==</span> <span class="hljs-constructor">NULL</span>;</span><br><span class="hljs-pattern-match">        &#125;<span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>右节点尚未访问时,重新压入栈</span><br><span class="hljs-pattern-match">        <span class="hljs-constructor">PushStack(<span class="hljs-params">s</span>,<span class="hljs-params">head</span>)</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>访问右节点</span><br><span class="hljs-pattern-match">            head = head-&gt;right<span class="hljs-constructor">Child</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure><blockquote><p>参考:</p><ul><li>  <a href="https://segmentfault.com/a/1190000016674584#articleHeader9">二叉树的遍历方法</a></li></ul></blockquote><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><blockquote><p>由于具有 n 个结点二叉树中， 共有 n+1 个指针域空置不用。为此，A.j.Parlis 和 C.Thornton 提出利用二叉数中这些空的链域来存储结点前驱或后继的地址信息的方法：<br>若某个结点的 left 指针为空， 则使该 left 指针指向该结点的前驱结点；若某个结点的 right 指针为空，则使该 right 指针指向该结点的后继结点。为了区别两个指针域的含义， 每个结点的存储结构中增加两个布尔型的线索标志字段 Lthread 和 Rthread。<br>指向前驱结点和后继结点的指针为线索(thread)， 带有线索的二叉树称为**线索二叉树(Threaded Binary Tree) **。</p></blockquote><h3 id="中序线索化二叉树的递归算法"><a href="#中序线索化二叉树的递归算法" class="headerlink" title="中序线索化二叉树的递归算法"></a>中序线索化二叉树的递归算法</h3><h4 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h4><ol><li>由于线索二叉树首先是二叉树，所以对它的任何算法可以是递归的。</li><li>按照中序遍历次序对二叉树进行线索化，对遍历到的每一个结点，先线索化其左子树，再线索化当前结点，最后线索化其右子树。</li><li>设置两个结点指针，分别指向遍历过程中的当前结点和它的前驱结点。</li><li>当前结点的左线索化和其前驱结点的右线索化同时进行.</li><li>若当前结点无左子树，构造其左线索(Lthread= true)及标志，若其前驱无右子树，则构造其前驱的右线索(Rthread= true)及标志。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs php">struct TBTreeNode    <span class="hljs-comment">//线索二叉树类型定义</span><br>&#123;<br><span class="hljs-keyword">bool</span> Lthread, Rthread;<br>    ElemType data;<br>    TBTreeNode *leftChild;<br>    TBTreeNode *rightChild;<br>&#125;;<br><br><br><span class="hljs-keyword">void</span> Threaded(TBTreeNode *t, <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">static</span> TBTreeNode *prenode; <span class="hljs-comment">//当前结点t的前驱指针</span><br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>        prenode = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// prenode初值为空</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">NULL</span>)      <span class="hljs-comment">//t树存在</span><br>    &#123;<br>        Threaded(t-&gt;leftChild, <span class="hljs-number">1</span>); <span class="hljs-comment">//对左子树线索化</span><br>         t-&gt;Lthread=t-&gt;leftChild==<span class="hljs-literal">NULL</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<span class="hljs-comment">//置左线索标志值</span><br>        t-&gt;Rthread=t-&gt;rightChild==<span class="hljs-literal">NULL</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<span class="hljs-comment">//置右线索标志值</span><br>        <span class="hljs-keyword">if</span> (prenode != <span class="hljs-literal">NULL</span>)    <span class="hljs-comment">//当前结点的前驱存在</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (prenode-&gt;Rthread)<br>                prenode-&gt;rightChild = t; <span class="hljs-comment">//互指</span><br>            <span class="hljs-keyword">if</span> (t-&gt;Lthread)<br>                t-&gt;leftChild = prenode;<br>        &#125;<br>        prenode = t;                <span class="hljs-comment">//t作为中序遍历后继结点的前驱</span><br>        Threaded(t-&gt;rightChild, <span class="hljs-number">1</span>); <span class="hljs-comment">//对右子树线索化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序线索二叉树的节点插入"><a href="#中序线索二叉树的节点插入" class="headerlink" title="中序线索二叉树的节点插入"></a>中序线索二叉树的节点插入</h3><p>在 p 所指结点与它的右子树之间插入 q 所指新结点，可以分两种情形考虑。</p><ul><li><p>P 结点存在右子树：<br>  此时将 q 结点作为 p 结点的右孩子点，p 结点原来的右子树作为 q 结点的右子树，使 q 结点作为 p 结点的后继结点，p 结点的原后继结点作为 q 结点的后继结点（将 p 结点右线索标志及右孩子指针拷贝到 q 结点），需对有关结点的线索进行赋值或修正。</p></li><li><p>P 结点不存在右子树：<br>  此时无论 p 结点是其父结点的左孩子或右孩子，将 q 结点作为 p 结点的右孩子结点前，将 p 结点右线索及标志拷贝到 q 结点即可。</p></li></ul><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xl">void InsertRight(TBTreeNode *p, TBTreeNode *q)<br>&#123;<br>    TBTreeNode *s;<br>    s = InOrderSuc(p);             <span class="hljs-comment">//s指向结点p的后继</span><br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span>Lthread = <span class="hljs-literal">true</span>;             <span class="hljs-comment">//置插入结点左线索标志</span><br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span>leftChild = p;              <span class="hljs-comment">//插入点的左线索指向p结点</span><br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span>R<span class="hljs-function"><span class="hljs-title">thread</span> = p-&gt;</span>Rthread;       <span class="hljs-comment">//复制p结点的右线索标志</span><br>    <span class="hljs-function"><span class="hljs-title">q</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">rightChild</span> = p-&gt;</span>rightChild; <span class="hljs-comment">//复制p结点的右孩子指针</span><br>    <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>Rthread = <span class="hljs-literal">false</span>;            <span class="hljs-comment">//置p结点的右线索标志为假</span><br>    <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>rightChild = q;             <span class="hljs-comment">//p结点的右指针指向新插入q结点</span><br><br>    <span class="hljs-function"><span class="hljs-title">if</span> (s != NULL &amp;&amp; s-&gt;</span>Lthread)   <span class="hljs-comment">//结点p的后继存在且有左线索</span><br>        <span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span>leftChild = q;          <span class="hljs-comment">//修正使其指向q</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p><strong>二叉排序树(Binary Sort Tree)</strong> 具有以下性质：</p><ol><li>二叉排序树可以是棵空树；</li><li>若它的左子树非空，则<strong>左子树的所有结点的关键字均小于根结点的关键字</strong>；</li><li>若它的右子树非空，则<strong>右子树的所有结点的关键字均大于等于根结点的关键字</strong>；</li><li>左子树、右子树本身也是二叉排序树。</li></ol><h2 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树(AVL 树)"></a>平衡二叉树(AVL 树)</h2><p>一棵平衡二叉排序树或者是空树，或者是具有下列性质的二叉排序树：</p><ol><li>左子树与右子树的高度之差的绝对值小于等于 1</li><li>左子树和右子树也是平衡二叉排序树</li></ol><p>平衡二叉排序树的平均查找长度为 $O(log<del>2</del>n)$<br>平衡因子：结点的左子树深度与右子树深度之差(-1，0，1)</p><h3 id="平衡二叉树的调整-Todo"><a href="#平衡二叉树的调整-Todo" class="headerlink" title="平衡二叉树的调整[Todo]"></a>平衡二叉树的调整[Todo]</h3><blockquote><p>旋转操作分为左旋和右旋，左旋是将某个节点旋转为其右孩子的左孩子，而右旋是节点旋转为其左孩子的右孩子</p></blockquote><ul><li>  L 和 R 的自由排列组合: LR, LL, RL, RR</li><li>  四种组合没有什么特殊性, 只要注意超出的深度在那个子树上即可.</li><li>  调整原则: <strong>所有左子树节点关键字均小于其相应的根节点关键字, 右子树的所有结点的关键字均大于等于根结点的关键字</strong>.</li></ul><p>例如根节点左子树的右子树失去平衡, 就是 LR 型</p><h2 id="红黑树-Red-Black-tree"><a href="#红黑树-Red-Black-tree" class="headerlink" title="红黑树(Red-Black tree)"></a>红黑树(Red-Black tree)</h2><blockquote><p>红黑树是在AVL树的基础上发展而来的，是AVL树的一个变种<br>参考博客：<a href="https://segmentfault.com/a/1190000012728513">红黑树详细分析，看了都说好 - coolblog.SegmentFault</a></p></blockquote><h3 id="红黑树性质"><a href="#红黑树性质" class="headerlink" title="红黑树性质"></a>红黑树性质</h3><ol><li><p>每个节点非红即黑</p></li><li><p>根节点是黑的;</p></li><li><p>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</p></li><li><p>如果一个节点是红色的，则它的子节点必须是黑色的。</p></li><li><p>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</p></li></ol><h3 id="实现-Todo"><a href="#实现-Todo" class="headerlink" title="实现[Todo]"></a>实现[Todo]</h3><p>插入在叶结点，并且颜色设置为红色（参考第5条规则）</p><h3 id="调整操作"><a href="#调整操作" class="headerlink" title="调整操作"></a>调整操作</h3><p>主要难点在于调整，调整分为结构调整和颜色调整，颜色调整参考4</p><p>结构调整，左旋和右旋，和AVL树一致</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>AVL 树是高度平衡的，频繁的插入和删除，会引起<strong>频繁的rebalance</strong>，导致效率下降；<br>红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p><p>所以红黑树在查找，插入删除的性能都是 $O(logn)$，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p><h2 id="偏序树-堆"><a href="#偏序树-堆" class="headerlink" title="偏序树/堆"></a>偏序树/堆</h2><p><strong>优先队列(Priority queue)</strong> 中每个元素都有一个优先数，删除时，总是删除优先数最大的元素。实现优先队列的一种有效方法是将优先队列的元素组成完全二叉树，二叉树中任何结点的优先数(关键码)不小于它的子女结点的优先数(关键码)，具有这一性质的完全二叉树称为偏序树(Partially order tree)，又称最大堆。如果完全二叉树中任何结点的优先数(关键码)不大于它的子女结点的优先数(关键码)，则定义为最小堆。</p><h3 id="偏序树插入和删除算法"><a href="#偏序树插入和删除算法" class="headerlink" title="偏序树插入和删除算法"></a>偏序树插入和删除算法</h3><p><strong>最大堆调整示例</strong></p><ul><li><p>插入操作</p><ol><li> 元素放置到队尾( 队尾插入 )</li><li> 与父节点比较. 如果大于父节点, 则两者交换, 否则插入完成</li><li> 重复第 2 步, 父节点为空时, 插入完成</li></ol></li><li><p>删除操作</p><ol><li> 交换根节点和尾节点后, 删除尾节点</li><li> 调整偏序树: 从根节点作为父节点开始. 如果父节点小于子节点, 将父节点与子节点中最大的一个交换.</li><li> 父节点设为交换后的子节点, 重复第 2 步. 如果子节点为空, 或者子节点均小于父节点, 调整完成.</li></ol></li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>略</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>最小权值</p><h3 id="构造哈夫曼树的哈夫曼算法"><a href="#构造哈夫曼树的哈夫曼算法" class="headerlink" title="构造哈夫曼树的哈夫曼算法"></a>构造哈夫曼树的哈夫曼算法</h3><ol><li>根据给定的 n 个权值 ${w_1,w2,\cdots,wn}$, 构成 n 棵二叉树的集合(森林）$F={T_1,T_2,\cdots,T_n }$, 其中每棵二叉树 $T_i$ 中只有带权为 $w_i$ 的根结点, 其左右子树均空。</li><li>在 $F$ 中选取两棵根结点的权值最小的树作为左右子树(左小右大)构造一棵新的二叉树,且置新的二叉树的根结点的权值为其左、右子树根结点的权值之和。</li><li>在 $F$ 中删除这两棵树,同时将新的二叉树加入 $F$ 中。</li><li>重复步骤 2 和 3 , 直到 $F$ 只含一棵树为止.这棵树便是哈夫曼树。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>略</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是由顶点集合(vertex)及顶点间的关系集合组成的一种数据结构：<br>$$<br>G＝( V, E )<br>$$<br>其中 V = { x | x ∈ 某个数据对象}是顶点的有穷非空集合}；<br>无向图:<br>$$<br>    E = {(x, y) | x, y ∈  V }<br>$$<br>或有向图:<br>$$<br>E = {&lt;x, y&gt; | x, y ∈  V,  Path (x, y)}<br>$$<br>顶点之间关系的有穷集合(可以为空)，也叫做边(edge)集合。$$Path (x, y)$$表示从 x 到 y 的一条单向通路, 它是有方向的。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>有向图(directed graph)</p><p>  有向图(Directed graph)G 是由两个集合 $V(G)$ 和 $E(G)$ 组成。<br>  其中：$V(G)$ 是顶点的非空有限集，$E(G)$ 是有向边(也称弧)的有限集合，弧是顶点的有序对，记为 $&lt;v,w&gt;$， v 为弧的起点，w 为弧头的终点, 注意 $&lt;v,w&gt;≠&lt;w,v&gt;$。</p></li><li><p>无向图(undirected graph)</p><p>  无向图(undirected graph) G 是由两个集合 $V(G)$ 和 $E(G)$ 组成</p></li><li><p>完全图<br>  n 个顶点的无向图拥有 n(n-1)/2 个节点, 即为完全图</p></li></ul><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul><li>  对由 n 个记录组成的表(或文件)L=(r1,r2,……,rn)，依据记录中某个数据项的值重新进行排列的过程称之为<strong>排序（sorting）</strong>，该数据项称为排序码，一般情况下， 总是选择记录的关键码(字)作为排序码。</li><li>  如果待排序的表中含有多个排序码值相等的记录，用某种排序方法排序后，这些记录的相对次序不变，则说这种排序方法为稳定的（stable），否则是不稳定的。</li><li>按照待排序数据驻留的介质不同排序问题可分为内部排序(Internal sorting)和外部排序(External sorting)两类：<ol><li> 内排序: 待排序的表中记录可存放内存，整个排序过程都在内存进行，只涉及对内存的访问。</li><li> 外排序: 待排序的表中含有巨量记录，无法存放到内存，整个排序过程都在外存进行，涉及对外存的访问。</li></ol></li><li>  按照排序的依据原则内部排序可分为：插入排序、交换排序、选择排序、归并排序和分配排序等五类。</li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>顾名思义,最好的情况是已经排好序: $O(n)$, 最坏的情况是:$O(n^2)$<br>该排序是<strong>稳定排序</strong></p><p>请注意, 插入排序有大量的插入操作, 使用链表较为适宜</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>循环将数插入到已经排序的序列中, 知道未排序数组为空</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> LMAX = <span class="hljs-number">10</span>; <span class="hljs-comment">//顺序表最大长度</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rectype</span>        //记录类型定义</span><br><span class="hljs-class">&#123;</span><br>    keytype key;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SqList</span> //顺序表类型定义</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> length;<br>    rectype r[LMAX];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(SqList &amp;L)</span> <span class="hljs-comment">//直接插入排序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= L.length; i++)<br>    &#123;<br>        L.r[<span class="hljs-number">0</span>] = L.r[i]; <span class="hljs-comment">//将第i个记录复制到L.r[0]中</span><br>        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//依次后移</span><br>        <span class="hljs-keyword">while</span> (L.r[<span class="hljs-number">0</span>].key &lt; L.r[j].key)<br>        &#123;<br>            L.r[j + <span class="hljs-number">1</span>] = L.r[j];<br>            j = j - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//插入待排序数</span><br>        L.r[j + <span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>复杂度为$O(n^2)$, 如果已经有序, 则复杂度为 $O(1)$<br>该排序是<strong>稳定排序</strong></p><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>对于具有 n 个元素的数组, 进行 n-1 次遍历<br>第 k 次遍历过程, 如果发现某元素小于元素[k-1], 交换两者.<br>最终实现: 最小的数放在队头, 第二小的数放在第二个……..</p><p>排序完成</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>又叫递减增量排序</p><blockquote><p><del>希尔排序听起来总让我想起崩坏学园</del> &gt; <del>所以我钦点了<em>希尔 · 爱乐芙</em> 作为本篇博文置顶图 23333</del></p></blockquote><p>希尔排序的性能大约为:O(n^3/2^), 这主要是因为他的递减增量<br>希尔排序是<strong>不稳定的</strong></p><h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>取某一增量 d; 将数列按照增量 d 分成若干组;</li><li>对若干组进行插入排序</li><li>降低增量 d, 重复 1, 2 步骤直到 d 为 1;</li></ol><h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> increment = L.length;<br><span class="hljs-keyword">do</span><br>&#123;<br>increment /= <span class="hljs-number">2</span><br><span class="hljs-comment">//执行插入排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = increment; i &lt; L.length; i++)<br>&#123;<br>rectype extra = L.r[i];<br><span class="hljs-keyword">int</span> j = i - increment;<br><br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; (extra.key &lt; L.r[j].key))<br>&#123;<br>L.r[j + increment] = L.r[j];<br>j = j - increment;<br>&#125;<br>L.r[j + increment] = extra;<br>&#125;<br><br>&#125; <span class="hljs-keyword">while</span> (increment &gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序(Quick sort)</strong> 的基本思想是选取被排序表中某个关键码作为基准(pivot)，将表划分成左右两个子表： 左子表中各记录的关键码均小于或等于基准值，而右子表中各记录的关键码均大于或等于基准值。然后以同样的方法递归地处理这两个子表，直到完成全部记录的排序。<br>该排序是<strong>不稳定排序</strong></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>对含有 n 个记录的表，若算法总是以子表中间记录的关键码作为基准划分,最坏的情况(基准为最小或最大)是每次将将表分为含 1 个记录的子表和含 n-1 个记录的子表。需划分 n 次，比较次数为：<br><strong>n*(n-1)/2=O(n^2^)</strong></p><p>若总是以子表的第一个记录的关键码作为基准划分, 当被排序的表是按关键码有序或逆序，将出现最坏的情况。设 c(n)为用 QuickSort 算法对含有 n 个记录的表进行排序所作的比较次数, s(n)为交换次数，显然 c(1)=0 和 s(1)=0。 算法将 n 个记录的表划分为 r 记录和 n-r 记录两个子表需比较 n 次。所以<br>​ c(n)=n+c(r)+c(n-r)<br>对于最坏情形:每次划分时 r=1, n-r=n-1, 则有:<br>​ c(n)=n+c(1)+c(n-1)=n+c(n-1)<br>于是下列诸式成立:<br>​ c(1)=0<br>​ c(2)=2+c(1)=2<br>​ c(3)=3+c(2)=3+2=5<br>​ c(4)=4+c(3)=4+3+2=9<br>​ ……..<br>​ c(n)=n+c(n-1)=n+(n-1)+(n-2)+….+3+2=(n+2)(n-1)/2<br>​ =(n^2^+n-2)/2=O(n^2^)</p><p>若 QuickSort 算法总是以表中关键码的中值作为基准划分,将出现最好的情况：每次将表分为两个长度大致相等的子表。<br>​ c(n)≤n+2c(n/2)<br>​ ≤n+2[n/2+2c(n/22)]=2n+4c(n/22)<br>​ ≤2n+4[n/4+2c(n/23)]=3n+8c(n/23)<br>​ ≤……..<br>​ ≤kn+2kc(n/2k)=nlog2n+nc(1)=O(nlog2n)<br>​ (这里：k=log<del>2</del>n )<br>对于交换次数, 有<br>$$ s(n)&lt;=O(nlog_2n) $$</p><p>快速排序是<strong>不稳定的</strong></p><h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs maxima">void Qsort(int a[], int low, int high)<br>&#123;<br>    <span class="hljs-keyword">if</span>(low &gt;= high)<br>    &#123;<br>        <span class="hljs-built_in">return</span>;<br>    &#125;<br>    int <span class="hljs-built_in">first</span> = low;<br>    int <span class="hljs-built_in">last</span> = high;<br>    int <span class="hljs-built_in">key</span> = a[<span class="hljs-built_in">first</span>];<span class="hljs-comment">/*用字表的第一个记录作为枢轴*/</span><br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">first</span> &lt; <span class="hljs-built_in">last</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">first</span> &lt; <span class="hljs-built_in">last</span> &amp;&amp; a[<span class="hljs-built_in">last</span>] &gt;= <span class="hljs-built_in">key</span>)<br>        &#123;<br>            --<span class="hljs-built_in">last</span>;<br>        &#125;<br><br>        a[<span class="hljs-built_in">first</span>] = a[<span class="hljs-built_in">last</span>];<span class="hljs-comment">/*将比第一个小的移到低端*/</span><br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">first</span> &lt; <span class="hljs-built_in">last</span> &amp;&amp; a[<span class="hljs-built_in">first</span>] &lt;= <span class="hljs-built_in">key</span>)<br>        &#123;<br>            ++<span class="hljs-built_in">first</span>;<br>        &#125;<br><br>        a[<span class="hljs-built_in">last</span>] = a[<span class="hljs-built_in">first</span>];<br><span class="hljs-comment">/*将比第一个大的移到高端*/</span><br>    &#125;<br>    a[<span class="hljs-built_in">first</span>] = <span class="hljs-built_in">key</span>;<span class="hljs-comment">/*枢轴记录到位*/</span><br>    Qsort(a, low, <span class="hljs-built_in">first</span>-<span class="hljs-number">1</span>);<br>    Qsort(a, <span class="hljs-built_in">first</span>+<span class="hljs-number">1</span>, high);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>归并排序(merge sort)</strong> 是归并操作上的一种有效的排序算法<br>归并排序每次都是在相邻的数据中进行操作，在 $O(NlogN)$ 的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。</p><blockquote><p>设数列长为 $N$ ，将数列分开成小数列一共要 $logN$ 步，每步都是一个合并有序数列的过程，时间复杂度可以记为$O(N)$ ，故一共为 $O(NlogN)$ 。</p></blockquote><h3 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h3><p>对于整体无序的数列</p><ol><li>递归(recursion)分割数列为左右两部分, 直至数列不可再分</li><li>对当前不可再分的左右数列进行归并</li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//归并排序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> rear, <span class="hljs-keyword">int</span> temp[])</span> </span>&#123;<br><br><span class="hljs-keyword">int</span> i = front, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= rear)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[i] &lt; arr[j])<br>&#123;<br>temp[k++] = arr[j++];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>temp[k++] = arr[i++];<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (i &lt;= mid)<br>&#123;<br>temp[k++] = arr[i++];<br>&#125;<br><span class="hljs-keyword">while</span> (j &lt;= rear)<br>&#123;<br>temp[k++] = arr[j++];<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>&#123;<br>arr[front + i] = temp[i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recursive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[],<span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> rear, <span class="hljs-keyword">int</span> temp[])</span> </span>&#123;<br><span class="hljs-keyword">if</span> (front&lt;rear)<br>&#123;<br><span class="hljs-keyword">int</span> mid = (front + rear) / <span class="hljs-number">2</span>;<br><span class="hljs-built_in">recursive</span>(arr, front, mid, temp);<br><span class="hljs-built_in">recursive</span>(arr, mid + <span class="hljs-number">1</span>, rear, temp);<br><span class="hljs-built_in">merge</span>(arr, front, mid, rear, temp);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">//辅助表空间, 避免数列数组被覆写, 省去临时声明空间的时间开销</span><br><span class="hljs-keyword">int</span>* temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n];<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-built_in">recursive</span>(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, temp);<br><span class="hljs-keyword">delete</span>[] temp;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">123</span>,<span class="hljs-number">45</span>,<span class="hljs-number">654</span>,<span class="hljs-number">78</span>,<span class="hljs-number">96</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">mergeSort</span>(arr, <span class="hljs-number">8</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是利用堆这种数据结构而设计的一种排序算法，它是一种<strong>选择排序</strong>.<br>它的最坏，最好，平均时间复杂度均为$O(nlogn)$，它也是<strong>不稳定排序</strong>.</p><h3 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路 5"></a>算法思路 5</h3><ol><li><p>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p></li><li><p>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</p></li><li><p>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p></li></ol><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> rear)</span> </span>&#123;<br><span class="hljs-keyword">int</span>tmp = arr[front];<br>arr[front] = arr[rear];<br>arr[rear] = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">int</span> temp = arr[i];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; k &lt; len; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> ((k + <span class="hljs-number">1</span>) &lt; len&amp;&amp;arr[k] &lt; arr[k + <span class="hljs-number">1</span>])<br>&#123;<br>k++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (arr[k] &gt; temp)<br>&#123;<br>arr[i] = arr[k];<br>i = k;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>arr[i] = temp;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br><span class="hljs-comment">//1. 构建大顶堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-built_in">adjustHeap</span>(arr, i, len);<br>&#125;<br><br><span class="hljs-comment">//2. 交换堆顶元素和末尾元素, 调整堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-built_in">swap</span>(arr, <span class="hljs-number">0</span>, i);<br><span class="hljs-built_in">adjustHeap</span>(arr, <span class="hljs-number">0</span>, i);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">45</span>,<span class="hljs-number">65</span>,<span class="hljs-number">78</span>,<span class="hljs-number">98</span>,<span class="hljs-number">45</span>,<span class="hljs-number">32</span> &#125;;<br><span class="hljs-built_in">sort</span>(arr, <span class="hljs-number">8</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><strong>基数排序 (radix sort)</strong> 属于”分配式排序” (distribution sort) , 重点在于对关键字进行 “分配” 和 “收集” , 而不是对关键字的比较.<br>基数排序算法是<strong>稳定</strong>的, 时间复杂度是 $O(d*(n＋r))$</p><blockquote><p>将表中 n 个记录分配到 r 个队列中去的时间为$O(n)$, 收集时将 r 个队列连成一个表的时间$O(r)$, 一次分配和收集的时间为$O(n＋r)$, 由于算法对 n 个记录共进行了 d 遍分配和收集,所以共花费的时间为$O(d*(n＋r))$.</p></blockquote><h3 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>将关键码按照位数最小/最大值分配入箱</li><li>按照箱子的顺序收集关键码</li><li>重复 1，2 步骤直到位数到达最大/最小值</li></ol><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>最高位优先(Most Significant Digit first)，简称 MSD<br>最低位优先(Least Significant Digit first)，简称 LSD<br>下面采用 LSD 法，值得一提的是，这种实现比较耗费内存, 从理论上来说, 申请的数组空间利用率只有 10%.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*顺序数组实现*/</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> RADIX = <span class="hljs-number">10</span>;<span class="hljs-comment">//桶数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Max = <span class="hljs-number">10</span>;<span class="hljs-comment">//桶容量</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> pos)</span> </span>&#123;<br><span class="hljs-keyword">int</span> temp = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pos - <span class="hljs-number">1</span>; ++i) &#123;<br>temp *= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> (src / temp) % <span class="hljs-number">10</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radixSort_Array</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *src, <span class="hljs-keyword">int</span> digits)</span> </span>&#123;<br><span class="hljs-keyword">int</span>* tempArray[RADIX];<span class="hljs-comment">//定义桶数 RADIX</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; RADIX; ++i)<span class="hljs-comment">//定义桶容量</span><br>&#123;<br>tempArray[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [Max + <span class="hljs-number">1</span>];<br>tempArray[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化为0</span><br>&#125;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pos = <span class="hljs-number">1</span>; pos &lt;= digits; ++pos)<br>&#123;<br><span class="hljs-keyword">int</span> tmp;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Max; ++i)<span class="hljs-comment">//分配进桶</span><br>&#123;<br>tmp = <span class="hljs-built_in">getDigit</span>(src[i], pos);<span class="hljs-comment">//获取指定位的数字</span><br>++tempArray[tmp][<span class="hljs-number">0</span>];<br>tempArray[tmp][tempArray[tmp][<span class="hljs-number">0</span>]] = src[i];<br>&#125;<br><br><br><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;RADIX; ++i)<span class="hljs-comment">//收集</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;=tempArray[i][<span class="hljs-number">0</span>]; ++j )<br>&#123;<br>src[index++] = tempArray[i][j];<br>&#125;<br>tempArray[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//重置</span><br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Max; i++) &#123;<br>cout &lt;&lt; src[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> src[Max] = &#123; <span class="hljs-number">12</span>,<span class="hljs-number">123</span>,<span class="hljs-number">123</span>,<span class="hljs-number">14</span>,<span class="hljs-number">56</span>,<span class="hljs-number">78</span>,<span class="hljs-number">56</span>,<span class="hljs-number">12</span>,<span class="hljs-number">456</span>,<span class="hljs-number">789</span> &#125;;<br><span class="hljs-comment">/*std::cout &lt;&lt; &quot;最大三位数&quot; &lt;&lt; std::endl;</span><br><span class="hljs-comment">for (RADIX_t i = 0; i &lt; Max; i++)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">std::cin &gt;&gt; src[i];</span><br><span class="hljs-comment">cout &lt;&lt; endl;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Max; i++) &#123;<br>cout &lt;&lt; src[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>&#125;<br><br><span class="hljs-built_in">radixSort_Array</span>(src, <span class="hljs-number">3</span>);<br><br>cout &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Max; i++) &#123;<br>cout &lt;&lt; src[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基数排序、计数排序、桶排序"><a href="#基数排序、计数排序、桶排序" class="headerlink" title="基数排序、计数排序、桶排序"></a>基数排序、计数排序、桶排序</h3><blockquote><p>三者还是比较容易搞混的</p></blockquote><p><strong>桶排序(Bucket Sort)</strong></p><ol><li><p>将待排序元素划分到不同的痛。先扫描一遍序列求出最大值 $maxV$ 和最小值 $minV$ ，设桶的个数为 $k$ ，则把区间 $[minV, maxV]$ 均匀划分成 $k$ 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</p></li><li><p>对每个桶内的元素进行排序。可以选择任意一种排序算法。</p></li><li><p>各桶进行归并排序</p></li></ol><p><strong>计数排序</strong><br>桶排序中令 $k= maxV-minV+1$</p><h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><p>查找操作的性能主要考虑时间复杂度, 整个查找过程主要是在关键字和查找表的数据上. 即平均查找长度.<br>**平均查找长度 ASL(Average Search Length)**：为确定记录在表中的位置，需和给定值进行比较的记录个数的期望值叫查找算法的平均查找长度。</p><p>$$<br>ASL=\sum_{n}^{i=1}p_{i}c_{i}<br>$$</p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul><li>  对于每次查找均成功的情况下</li></ul><p>$$<br>ASL=\frac{n+1}{2}​<br>$$</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>通过建立一个二叉查找树, 我们能很清晰的看到</p><p>$$<br>ASL=log<del>2</del>(n+1)-1<br>$$</p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>分块查找，也叫索引顺序查找，算法实现除了需要查找表本身之外，还需要根据查找表建立一个索引表<br>建立的索引表要求按照关键字进行升序排序，查找表要么整体有序，要么分块有序</p><blockquote><p>分块有序指的是第二个子表中所有关键字都要大于第一个子表中的最大关键字，第三个子表的所有关键字都要大于第二个子表中的最大关键字，依次类推。</p></blockquote><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>分块查找分为两个过程:</p><ol><li>查找块<br>可以采用顺序查找, 也可以采用折半查找</li><li>块内查找<br>采用顺序查找</li></ol><blockquote><p>总体而言, 分块查找效率介于顺序查找和折半查找之间</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Todo</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simple tutorial for Hexo</title>
    <link href="/2018/12/12/Simple-tutorial-for-hexo/"/>
    <url>/2018/12/12/Simple-tutorial-for-hexo/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。Hexo同时也是GitHub上的开源项目，如果想要更加全面的了解Hexo，可以到其官网 <a href="https://hexo.io/">Hexo</a> 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，你可以查阅到优质的中文文档.</p></blockquote><span id="more"></span><h2 id="Hexo基础"><a href="#Hexo基础" class="headerlink" title="Hexo基础"></a>Hexo基础</h2><p>基于Github pages 的静态博客所必须的步骤</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p><a href="https://github.com/">GitHub</a>提供了一个免费账户, 这对于我们来说可以很方便的搭建静态博客, 当然, 这也是本篇的目标. </p><ol><li>登录到GitHub, 如果没有GitHub帐号，使用你的邮箱注册GitHub帐号. </li><li>点击GitHub中的New repository创建新仓库，仓库名应该为：</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">用户名<span class="hljs-string">.github.io</span><br></code></pre></td></tr></table></figure><p>用户名请使用你的GitHub帐号名称代替. 这是固定写法，比如我的仓库名为:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">mag<span class="hljs-symbol">nesium12</span>.github.io<br></code></pre></td></tr></table></figure><h3 id="安装Git-amp-Node-js"><a href="#安装Git-amp-Node-js" class="headerlink" title="安装Git&amp;Node.js"></a>安装Git&amp;Node.js</h3><p>在安装前，你必须检查电脑中是否已安装下列应用程序：</p><ul><li>Node.js</li><li>Git  </li></ul><blockquote><p><strong>Windows 用户</strong></p><p>如果你的电脑中尚未安装所需要的程序，请到官网下载Node.js &amp; Git的安装程序进行安装.<br>注意安装Node.js时注意勾选<strong>Add to PATH</strong>选项, 这将使得Node.js添加到你的计算机环境变量中.<br>Git安装完成后，右键菜单会出现git bash, 我们所有的命令都需要在git bash中执行,.</p></blockquote><p>下载Git可能会有些慢, 请耐心等待或者自行寻找过其他源. </p><h3 id="配置SSH免密访问"><a href="#配置SSH免密访问" class="headerlink" title="配置SSH免密访问"></a>配置SSH免密访问</h3><ol><li>本地安装 Git</li></ol><p>我本地是Windows，采用 git-bash. 如果你是新手的话, 在安装过程中只要一路next就OK</p><ol start="2"><li>配置本地免密ssh远程登陆</li></ol><p>在本地写作的机器上，搜索Git Bash，设置user.name和user.email配置信息：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;你的GitHub用户名&quot;</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>生成ssh密钥文件</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;你的GitHub注册邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>一路回车，<code>~/.ssh/</code>目录下会生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件。</p><ol><li>打开GitHub_Settings_keys 页面，新建new SSH Key</li></ol><p>Title为标题，任意填即可，将刚刚复制的<code>id_rsa.pub</code>内容粘贴进去，最后点击Add SSH key.<br>在Git Bash中检测GitHub公钥设置是否成功，输入 </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">​ssh <span class="hljs-symbol">git@</span>github.com<br></code></pre></td></tr></table></figure><ul><li>如果是第一次链接的话, 可能会询问是否创建<code>known_hosts</code>文件, 这当然是<code>yes</code></li></ul><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>如果你的电脑中已经安装上述必备程序，那么恭喜你！接下来只需使用 npm 即可完成 Hexo 的安装。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>Hexo安装完成后, 输入以下命令并执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>请注意, <code>&lt;folder&gt;</code>是你指定的文件夹路径, 并且该文件夹必须为空. <code>&lt;``&gt;</code>是特殊字符, 命令端输入时应当去除, 例如</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">hexo init <span class="hljs-regexp">/d/</span><span class="hljs-keyword">Project</span>/Hexo<br>cd <span class="hljs-regexp">/d/</span><span class="hljs-keyword">Project</span>/Hexo<br>npm install<br></code></pre></td></tr></table></figure><p>或者直接打开Hexo文件夹, 右键git bash, 输入</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>如果你看到 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">INFO</span> <span class="hljs-keyword">Start</span> blogging <span class="hljs-keyword">with</span> Hexo!`<br></code></pre></td></tr></table></figure><p>这意味着本地建站已完成, congratulations!你已经到达新手村. </p><h3 id="站点结构"><a href="#站点结构" class="headerlink" title="站点结构"></a>站点结构</h3><p>新建完成后, 本地hexo站点结构如下</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的配置信息, 你可以在这里选择配置大部分参数, 我们称为<code>站点配置文件</code>.</p><ul><li>可以设定主题, 网站标题, 副标题, author etc. 详情请阅读.md文档</li></ul><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>应用程序的信息. </p><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p>模板文件夹, Hexo会根据<code>scaffolds</code>来建立文件. Hexo的模板是指在新建的markdown文件中默认填充的内容. 例如, 如果您修改scaffold/post.md中的Front-matter内容, 那么每次新建一篇文章时都会包含这个修改.</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方. 除<code>_posts</code> 文件夹之外, 开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略. Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹, 而其他文件会被拷贝过去. </p><blockquote><p>发布的博文存储在../public/</p></blockquote><h4 id="theme"><a href="#theme" class="headerlink" title="theme"></a>theme</h4><p>主题 文件夹。Hexo 会根据主题来生成静态页面</p><ul><li>存在默认主题, 但还是请选择一个你喜欢的主题, it does matter.</li><li>主题文件夹内会有<code>_config.yml</code>配置文件, 我们称为<strong>主题配置文件</strong></li></ul><h3 id="Hexo常用指令"><a href="#Hexo常用指令" class="headerlink" title="Hexo常用指令"></a>Hexo常用指令</h3><p>**请注意, 这些操作必须在<code>../hexo/</code>目录下进行</p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ hexo <span class="hljs-keyword">init</span> [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 folder , Hexo 默认在目前的文件夹建立网站. </p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo new [layout] &lt;title&gt;<br><span class="hljs-variable">$ </span>hexo n <span class="hljs-string">&quot;article&quot;</span><br></code></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br>$ hexo g<br></code></pre></td></tr></table></figure><p>生成静态文件</p><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><p>文件生成后立即部署网站</p><h4 id="generate-1"><a href="#generate-1" class="headerlink" title="generate"></a>generate</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo gengerate<br><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo server<br><span class="hljs-variable">$ </span>hexo s<br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a> . 如果需要修改, </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo sever -p <span class="hljs-number">5000</span> <span class="hljs-comment">#更改端口至5000</span><br></code></pre></td></tr></table></figure><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后）, 如果发现您对站点的更改无论如何也不生效, 您可能需要运行该命令.</p><h3 id="发布网站"><a href="#发布网站" class="headerlink" title="发布网站"></a>发布网站</h3><p>如果你已经迫不及待地打开在hexo 目录下打开Git bash</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>在<a href="http://localhost:4000/">http://localhost:4000</a> 你将预览到自己的博客, 但是别人是看不到的, 毕竟一般情况下别人不能看到你的计算机的本地内容. <strong>Github pages</strong>可以帮助我们解决这个问题. </p><p>下一步把GitHub和我们的Hexo关联起来, 打开站点的_config.yml, 找到</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span> <br><span class="hljs-symbol">  type:</span> <br><span class="hljs-symbol">  repo:</span> <br><span class="hljs-symbol">  branch:</span> <br></code></pre></td></tr></table></figure><p>修改如下: </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br>  <span class="hljs-meta">#创建仓库的完整路径, 末尾记得加.git</span><br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/Magnesium12/magnesium12.github.io.git </span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><blockquote><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。<br>最后安装Git部署插件, 输入命令:</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>现在我们输入:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>在浏览器中输入: xxxx. github.io</p><p>你会发现这时你的博客已经上线,</p><p>Congratulations! </p><p><strong>Now. Sharing  the fantasy of your own to the world.</strong></p><h2 id="Hexo进阶"><a href="#Hexo进阶" class="headerlink" title="Hexo进阶"></a>Hexo进阶</h2><h3 id="NexT相关"><a href="#NexT相关" class="headerlink" title="NexT相关"></a>NexT相关</h3><p>注意到6.x版本next仓库的变动, 需要下载最新版本的同学请选择</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd hexo<br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/theme-next/</span>hexo-theme-<span class="hljs-keyword">next</span> themes/<span class="hljs-keyword">next</span><br></code></pre></td></tr></table></figure><p>之后跟进更新</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> theme/<span class="hljs-keyword">next</span><br>git pull<br></code></pre></td></tr></table></figure><p>如果是从v5.x升级到v6.x, 请另行参阅<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md">这篇文档</a></p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><ul><li><p>打开_config.yml 文件</p></li><li><p>阅读 README.md</p></li><li><p>依照字面意思来配置</p></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><em>眼睛不需要的话, 可以捐给其他人.    by 鲁迅</em></p><h3 id="swig"><a href="#swig" class="headerlink" title=".swig"></a>.swig</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">Unhandled rejection Error: ENOENT: no such file or directory, open &#x27;D:<span class="hljs-symbol">\P</span>roject<span class="hljs-symbol">\H</span>exo<span class="hljs-symbol">\t</span>hemes<span class="hljs-symbol">\n</span>ext<span class="hljs-symbol">\l</span>ayout<span class="hljs-symbol">\_</span>scripts<span class="hljs-symbol">\s</span>chemes<span class="hljs-symbol">\.</span>swig&#x27;<br></code></pre></td></tr></table></figure><p>NexT使用版本:  5.1.4<br>原因：social加入链接时, #social: 这一行没有把注释打开…..</p><h3 id="怎么写博客"><a href="#怎么写博客" class="headerlink" title="怎么写博客"></a>怎么写博客</h3><ul><li>请bing一下markdown.</li><li>此外, 推荐<strong>VS Code</strong>作为你的博客项目管理工具.</li><li>推荐<strong>Typora</strong>作为你写markdown的书写工具.</li></ul><h3 id="语言设定"><a href="#语言设定" class="headerlink" title="语言设定"></a>语言设定</h3><p>请修改站点文件, zh-CN意味着站点语言默认为中文</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN<br></code></pre></td></tr></table></figure><h3 id="标签-amp-分类"><a href="#标签-amp-分类" class="headerlink" title="标签&amp;分类"></a>标签&amp;分类</h3><p>进入hexo文件夹</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> <span class="hljs-string">&quot;tags&quot;</span><br></code></pre></td></tr></table></figure><p>注意已生成source/tags/index.md,  index.md中修改如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2016-11-15 19:11:13</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">&quot;tags&quot;</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>当你试图为你的文章添加标签时, 请在文章头部添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">基于Hexo和Github搭建博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2018-12-14</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">npm</span>, <span class="hljs-string">hexo</span>, <span class="hljs-string">github</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>categories 分类 如上</p><h3 id="hexo-d-出错"><a href="#hexo-d-出错" class="headerlink" title="hexo d 出错"></a>hexo d 出错</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">$ hexo d <br><span class="hljs-keyword">ERROR </span>Deployer not found: git<br></code></pre></td></tr></table></figure><p>解决方案: 最新的hexo版本，必须执行 </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-deployer-git</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Trick</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows10 APP Recemented</title>
    <link href="/2018/12/12/WIN10-app-recemented/"/>
    <url>/2018/12/12/WIN10-app-recemented/</url>
    
    <content type="html"><![CDATA[<p>是我所用到的</p><span id="more"></span><h2 id="Win10-APP-Recemented"><a href="#Win10-APP-Recemented" class="headerlink" title="Win10 APP Recemented"></a>Win10 APP Recemented</h2><p>win会根据硬盘分区. 安装软件, 我认为将大型软件安装在固态盘上会明显提升体验. 选择安装目录时可以考虑安装在对应盘的Program Files文件夹中. 便于管理. 下面是建议安装的软件</p><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>优质的浏览器, 配合插件食用更佳</p><blockquote><p>建议使用edge下载<br>不能翻墙的情况下, 请将bing.com设置为主页, 地址栏搜索设置为bing<br>替代品: Edge, Firefox</p></blockquote><h3 id="Microsoft-Edge-for-Chromium"><a href="#Microsoft-Edge-for-Chromium" class="headerlink" title="Microsoft Edge for Chromium"></a>Microsoft Edge for Chromium</h3><p>与楼上各有千秋（谦辞）</p><blockquote><p>建议使用 Chrome 下载（逃<br>支持Chrome所有操作，但它更快<br>支持数据单向迁移，所以……大概需要一个微软账号？</p></blockquote><h3 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h3><p>windows 文件浏览增强工具</p><blockquote><p>替代选择： WIN 自带文件搜索, 如果你不嫌烦的话, 可以为当前电脑建立索引(第一次通常要花很长时间). </p></blockquote><h3 id="Bandizip"><a href="#Bandizip" class="headerlink" title="Bandizip"></a>Bandizip</h3><p>便携轻巧的解压缩工具, 优点是美观和人性化</p><h3 id="Potplayer"><a href="#Potplayer" class="headerlink" title="Potplayer"></a><del>Potplayer</del></h3><blockquote><p>有广告，并且软件开发者态度非常恶劣地剽窃开源成果，不建议使用</p></blockquote><h3 id="VLC"><a href="#VLC" class="headerlink" title="VLC"></a>VLC</h3><p>强大的视频播放工具,支持 h.265等编码格式，支持各种花里胡哨功能<br>比XX影音<del>以及Potplayer</del>不知道高到哪里去了. 优点是(可以变得)美观和友好</p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>实用的markdown书写工具, 重点是美观</p><p><del>2021年4月20日摒弃，内容即时保存功能太弱，目前已发生数次数据丢失。</del><br>2021年4月24日重新下载，是我人菜怪刀钝，Typora！永远滴神！超好用的 <em>mermaid</em> 语法支持，超好用的 <em>yaml</em> ，超好用的 <em>custom theme</em> ，还有超好用的界面！配合 <em>ondrive</em> 真是太香辣太香辣！</p><h3 id="微软输入法"><a href="#微软输入法" class="headerlink" title="微软输入法"></a>微软输入法</h3><p>简单好用的输入法, 优点是美观、简洁, 支持各种语言和自定义词库 </p><h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><p>神之编辑器 VS 编辑器之神, 它是近几年来最流行的编辑器. 只要装几个扩展, 你可以在上面流畅的编程: C,/C++, Python, Golang甚至Java =.= ……<br>也可以用来写markdown√.<br>缺点是<del>啥都要自定义, 很烦</del>没有缺点，点点点完事</p><h3 id="Steam"><a href="#Steam" class="headerlink" title="Steam"></a>Steam</h3><p>最大的学习平台(误)</p><h3 id="Wallpaper-engine"><a href="#Wallpaper-engine" class="headerlink" title="Wallpaper engine"></a>Wallpaper engine</h3><p>动态壁纸软件</p><blockquote><p>内存占用根据设置而不同<br>最大的槽点是, 桌面永远不可能长时间展示出来. </p></blockquote><h3 id="火绒安全实验室"><a href="#火绒安全实验室" class="headerlink" title="火绒安全实验室"></a>火绒安全实验室</h3><p>看起来很安静的系统防护软件, 重点是安静和人性化. </p><blockquote><p>WIN defender 可以作为替代, 只是有时defender 会把一些软件的破解程序识别为病毒秒删..<br>更严重的是, 它在之前版本中会时不时进行磁盘的全盘扫描, 非常蛋疼…<br>各路安全管家也能替代. 需要提醒的是, 他们通常会携家带口.</p></blockquote><h3 id="utorrent"><a href="#utorrent" class="headerlink" title="utorrent"></a>utorrent</h3><p>安装就完事了, 紫荆是个好同志</p><h3 id="Office-2019"><a href="#Office-2019" class="headerlink" title="Office 2019"></a>Office 2019</h3><p>安装就完事了, 紫荆是个好榜样</p><h3 id="Onenote"><a href="#Onenote" class="headerlink" title="Onenote"></a>Onenote</h3><p>笔记软件</p><blockquote><p>优点是Onenote uwp简洁美观, Onenote 2016功能强大(他们数据互通)<br>缺点: zz一样的富文本编辑,花里胡哨的又用不到，替代品很多</p></blockquote><p>譬如可以使用博客来代替 </p><h3 id="V2ray"><a href="#V2ray" class="headerlink" title="V2ray"></a>V2ray</h3><p>一个代理软件，较为好用</p><h3 id="Microsoft-ToDo"><a href="#Microsoft-ToDo" class="headerlink" title="Microsoft ToDo"></a>Microsoft ToDo</h3><p>Todo list型软件，优点是界面美观，操作友好，支持多端同步</p><h3 id="Bicoment"><a href="#Bicoment" class="headerlink" title="Bicoment"></a>Bicoment</h3><p>Bt 软件，用于替代μtorrent</p><h2 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h2><p>有点强迫症</p><ol><li><p>清除图标, 一个不留<br><code>WIN+E</code>, <code>listary</code>,可以完美替代查找文档<br><code>delete</code>  替代删除操作, 记得清理回收站</p></li><li><p>常用应用图标迁移<br>将常用应用贴到磁贴, 敲击<code>WIN</code>键, 即可食用</p></li></ol><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ol><li><p>win+你想输入的内容<br>优点一目了然. 缺点: 本地搜索不如listary, 网页搜索不如chrome, 吔屎啦</p></li><li><p>win+ctrl+d<br>新建桌面, 没有双屏幕情况下的替代品</p></li><li><p>win+d<br>显示桌面</p></li><li><p>win+e<br>打开资源管理器</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Trick</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Win10</tag>
      
      <tag>toolkit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推歌：A LETTER</title>
    <link href="/2018/12/03/%E6%AD%8C%E6%9B%B2%E6%8E%A8%E8%8D%90The-Song-For-You/"/>
    <url>/2018/12/03/%E6%AD%8C%E6%9B%B2%E6%8E%A8%E8%8D%90The-Song-For-You/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/12/03/5c05272799b4b.jpg" alt="午夜"></p><blockquote class="blockquote-center"><i> You don't have to throw your life away </i></blockquote><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=499027&auto=1&height=66"></iframe><p><em>本来也不想写文字，但是不写一点文字,又怎么知道当时所思所想是什么，自己又是为什么要去写这篇博文呢?</em></p><p>……</p><p> <em>A LETTER</em> 是由<a href="https://zh.moegirl.org/%E6%B3%BD%E9%87%8E%E5%BC%98%E4%B9%8B">泽野弘之</a><br>创作的插曲——也许提及<em>高达UC</em>会让他更容易被想起.</p><p>歌姬Cyua确实很适合去唱这首歌, 她的声线与舒缓空旷的乐音彼此交融, 编织出这首弥漫着伤感, 空灵以及希望的歌曲. 倘若你愿意闭上双眸, 浮现出的场景大概会是独角兽在孤独地进行着只属于自己的宇宙漫途, 但或许你需要知道的是, 这首歌曲更多在表达的是对自己的鼓励和对未来的希冀.</p><p>每个人都是宇宙中的独角兽, 命运指定的航线终将我们彼此分离, 忙碌追赶又有什么意义呢？命运的轨迹充满了错误,  等待我们的会是痛苦, 遗憾, 还是……希望?</p><p>指向正确的道路或许很艰辛, 可是总有一天能够到达尽头. </p><p><em>Now you see light in pain.</em></p><p>$YuXiu .$</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旧日</tag>
      
      <tag>个人推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>似有若无</title>
    <link href="/2018/12/03/%E9%97%B2%E8%B0%88/"/>
    <url>/2018/12/03/%E9%97%B2%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>那是中学的时候，源于一次稀里糊涂的座位更替</p><span id="more"></span><p>她坐在我旁边的时候，其实我还在纠结灵魂守卫和敌法师是不是有个叫伊利丹的亲戚——“你好，········”，伴随着笑意的声音把我从DotA大陆扯回了教室。与此同时，脑子里突然出现了保大救她随母姓——哦不应该是：</p><p><em>“After all this ages spent in darkness , your voice is like the pure light of moon upon my mind.”</em></p><p>用我当时最心爱的WARⅢ/DotA来打比方，那一幕就像是守望者监牢里伊利丹与泰兰德的经典再现</p><p>其实我这只懒狗暗恋她很久了，但是有一说一，这次我想做点什么</p><p>第一件事，我不玩TB了<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="TB：Terrorblade，灵魂守卫，模型源于WARⅢ伊利丹">[1]</span></a></sup></p><p>我开始小心翼翼地挖空心思逗她开心，她的要求我从来不会拒绝，虽然有时候班级女生们看我的眼光有点奇怪，朋友们也一副欲言又止止言又欲的样子，超出能力的请求也让我有些劳累，但我想这都是值得的，风雨过后一定是彩虹！呜呜呜，精诚所至金石为开，我继续努力的话，就像farm出圣者遗物的UG往往迎来autowin的结局，总有一天女神会微笑着对我说，笨蛋，你对我这么好，我怎么可能注意不到呢，我们立刻开始这段感情吧~</p><p>呜呜呜，想想还有点小激动呢</p><p>蛤？你问我女神到底是怎样一个女生？怎么说呢，她就是很好一女孩，哪里都好，至于怎么个好法我现在也形容不出来——当然这是因为我表述不出来，阿sir，我语文真的不行。哦不对，女神好像也有个无伤大雅的小缺点，就她听力好像有点问题，我每次精心准备好的表白开场词，她好像都听不太清。害，不过这也不是什么事儿，只要她愿意，我可以当她一辈子的助听器呜呜呜</p><p>台历一页一页的翻过，甜蜜滋养出的勇气，也随之一层一层的盘旋堆叠。终于有一天，我觉得是时候表白了，咱虽然没去过她家，但至少还是知道她大概路线，咱还提前查了天气预报，Nice！晴转多云，反正别下雨就OK。那天，我骑着自己心爱的小毛驴<del>，心中多欢喜</del>太阳对我…….哎卧槽，怎么感觉小毛驴怎么这么慢，明明女神是步行，路程却显得如此的漫长。哦，原来是我腿在颤抖啊，那没事了</p><p>其实那天对话到底说了啥我也有点忘了，只依稀记得有什么「好人」「哥哥」「读书」的字眼，倒是清楚地记得那天的天气其实不算好，突然就晴转阴，雾蒙蒙的搞得我视野有点模糊，差点都看不清路。害，要是出了事第二天不就见不到女神了嘛，早知道应该好好选择一个更好一点的好日子，都怪我，都怪我自己太相信天气预报了</p><p>害</p><p>那天晚上我打了好多把dota，玩了好久的UG和PA。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="UG/PA：幽鬼和幻影刺客，模型源于WARⅢ玛维·影之歌">[2]</span></a></sup></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>TB：Terrorblade，灵魂守卫，模型源于WARⅢ伊利丹<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>UG/PA：幽鬼和幻影刺客，模型源于WARⅢ玛维·影之歌<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旧日</tag>
      
      <tag>上浮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载-两年研发经验分享</title>
    <link href="/2018/12/03/%E7%A0%94%E5%8F%91%E5%B7%A5%E4%BD%9C%E5%88%86%E4%BA%AB/"/>
    <url>/2018/12/03/%E7%A0%94%E5%8F%91%E5%B7%A5%E4%BD%9C%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：syntax_error<br>链接：<a href="https://www.nowcoder.com/discuss/351805">https://www.nowcoder.com/discuss/351805</a><br>来源：牛客网</p></blockquote><span id="more"></span><p>最近逛牛客发现一个分享工作经验的专题，貌似还有礼品可拿，OK，我们的故事开始了。‌ </p><p>先简单交代一下背景吧，某不知名985的本硕，17年毕业加入滴滴，当时找工作时候也是在牛客这里跟大家一起奋战的。今年下半年跳槽到了头条，一直从事后端研发相关的工作。之前没有实习经历，算是两年半的工作经验吧。这两年半之间完成了一次晋升，换了一家公司，有过开心满足的时光，也有过迷茫挣扎的日子，不过还算顺利地从一只职场小菜鸟转变为了一名资深划水员。在这个过程中，总结出了一些还算实用的划水经验，有些是自己领悟到的，有些是跟别人交流学到的，在这里跟大家分享一下。</p><h2 id="学会深入思考，总结沉淀"><a href="#学会深入思考，总结沉淀" class="headerlink" title="学会深入思考，总结沉淀"></a>学会深入思考，总结沉淀</h2><p>我想说的第一条就是要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</p><p>先来说深入思考。在程序员这个圈子里，常能听到一些言论：我这个工作一点技术含量都没有，每天就CRUD，再写写if-else，这TM能让我学到什么东西？抛开一部分调侃和戏谑的论调不谈，这可能确实是一部分同学的真实想法，至少曾经的我，就这么认为过。后来随着工作经验的积累，加上和一些高level的同学交流探讨之后，我发现这个想法其实是非常错误的。之所以出现没什么可学的这样的看法，基本上是思维懒惰的结果。任何一件看起来很不起眼的小事，只要进行深入思考，稍微纵向挖深或者横向拓宽一下，都是足以让人沉溺的知识海洋。<br>‌<br>举一个例子。某次有个同学跟我说，这周有个服务OOM了，查了一周发现有个地方defer写的有问题，改了几行代码上线修复了，周报都没法写。可能大家也遇到过这样的场景，还算是有一定的代表性。其实就查bug这件事来说，是一个发现问题，排查问题，解决问题的过程，包含了触发、定位、复现、根因、修复、复盘等诸多步骤，花了一周来做这件事，一定有不断尝试与纠错的过程，这里面其实就有很多思考的空间。比如说定位，如何缩小范围的？走了哪些弯路？用了哪些分析工具？比如说根因，可以研究的点起码有linux的OOM，k8s的OOM，go的内存管理，defer机制，函数闭包的原理等等。如果这些真的都不涉及，仍然花了一周时间做这件事，那复盘应该会有很多思考，提出来几十个WHY没问题吧…<br>‌<br>再来说下总结沉淀。这个我觉得也是大多数程序员比较欠缺的地方，只顾埋头干活，可以把一件事做的很好。但是几乎从来不做抽象总结，以至于工作好几年了，所掌握的知识还是零星的几点，不成体系，不仅容易遗忘，而且造成自己视野比较窄，看问题比较局限。适时地做一些总结沉淀是很重要的，这是一个从术到道的过程，会让自己看问题的角度更广，层次更高。遇到同类型的问题，可以按照总结好的方法论，系统化、层次化地推进和解决。</p><p>还是举一个例子。做后台服务，今天优化了1G内存，明天优化了50%的读写耗时，是不是可以做一下性能优化的总结？比如说在应用层，可以管理服务对接的应用方，梳理他们访问的合理性；在架构层，可以做缓存、预处理、读写分离、异步、并行等等；在代码层，可以做的事情更多了，资源池化、对象复用、无锁化设计、大key拆分、延迟处理、编码压缩、gc调优还有各种语言相关的高性能实践…等下次再遇到需要性能优化的场景，一整套思路立马就能套用过来了，剩下的就是工具和实操的事儿了。</p><p>还有的同学说了，我就每天跟PM撕撕逼，做做需求，也不做性能优化啊。先不讨论是否可以搞性能优化，单就做业务需求来讲，也有可以总结的地方。比如说，如何做系统建设？系统核心能力，系统边界，系统瓶颈，服务分层拆分，服务治理这些问题有思考过吗？每天跟PM讨论需求，那作为技术同学该如何培养产品思维，引导产品走向，如何做到架构先行于业务，这些问题也是可以思考和总结的吧。就想一下，连接手维护别人烂代码这种蛋疼的事情，都能让Martin Fowler整出来一套重构理论，还显得那么高大上，我们确实也没啥必要对自己的工作妄自菲薄…</p><p>所以说学习和成长是一个自驱的过程，如果觉得没什么可学的，大概率并不是真的没什么可学的，而是因为自己太懒了，不仅是行动上太懒了，思维上也太懒了。</p><p>可以多写技术文章，多分享，强迫自己去思考和总结，毕竟如果文章深度不够，大家也不好意思公开分享。</p><h2 id="积极学习，保持技术热情"><a href="#积极学习，保持技术热情" class="headerlink" title="积极学习，保持技术热情"></a>积极学习，保持技术热情</h2><p>最近两年在互联网圈里广泛传播的一种焦虑论叫做35岁程序员现象，大意是说程序员这个行业干到35岁就基本等着被裁员了。不可否认，互联网行业在这一点上确实不如公务员等体制内职业。但是这个问题里35岁程序员并不是绝对生理意义上的35岁，应该是指那些工作十几年和工作两三年没什么太大区别的程序员。后面的工作基本是在吃老本，没有主动学习与充电，35岁和25岁差不多，而且没有了25岁时对学习成长的渴望，反而添了家庭生活的诸多琐事，薪资要求往往也较高，在企业看来这确实是没什么竞争力。</p><p>‌<br>而如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了35岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？但是学习这件事，其实是一个反人类的过程，这就需要我们强迫自己跳出自己的安逸区，主动学习，保持技术热情。在滴滴时有一句话大概是，主动跳出自己的舒适区，感到挣扎与压力的时候，往往是黎明前的黑暗，那才是成长最快的时候。相反如果感觉自己每天都过得很安逸，工作只是在混时长，那可能真的是温水煮青蛙了。</p><p>刚毕业的这段时间，往往空闲时间还比较多，正是努力学习技术的好时候。借助这段时间夯实基础，培养出良好的学习习惯，保持积极的学习态度，应该是受益终身的。至于如何高效率学习，网上有很多大牛写这样的帖子，到了公司后内网也能找到很多这样的分享，我就不多谈了。</p><p>可以加入学习小组和技术社区，公司内和公司外的都可以，关注前沿技术。</p><h2 id="主动承担，及时交流反馈"><a href="#主动承担，及时交流反馈" class="headerlink" title="主动承担，及时交流反馈"></a>主动承担，及时交流反馈</h2><p>‌<br>前两条还是从个人的角度出发来说的，希望大家可以提升个人能力，保持核心竞争力，但从公司角度来讲，公司招聘员工入职，最重要的是让员工创造出业务价值，为公司服务。虽然对于校招生一般都会有一定的培养体系，但实际上公司确实没有帮助我们成长的义务。而在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。我当初刚入职的时候，基本就是leader给分配什么任务就把本职工作做好，然后就干自己的事了，几乎从来不主动去跟别人交流或者主动去思考些能帮助项目发展的点子。自以为把本职工作保质保量完成就行了，后来发现这么做其实是非常不够的，这只是最基本的要求。而有些同学的做法则是leader只需要同步一下最近要做什么方向，下面的一系列事情基本不需要leader操心了 ，这样的同学我是leader我也喜欢啊。入职后经常会听到的一个词叫owner意识，大概就是这个意思吧。</p><p>‌<br>在这个过程中，另外很重要的一点就是及时向上沟通反馈。项目进展不顺利，遇到什么问题，及时跟leader同步，技术方案拿捏不准可以跟leader探讨，一些资源协调不了可以找leader帮忙，不要有太多顾忌，认为这些会太麻烦，leader其实就是干这个事的。。如果项目进展比较顺利，确实也不需要leader介入，那也需要及时把项目的进度，取得的收益及时反馈，自己有什么想法也提出来探讨，问问leader对当前进展的建议，还有哪些地方需要改进，消除信息误差。做这些事一方面是合理利用leader的各种资源，另一方面也可以让leader了解到自己的工作量，对项目整体有所把控，毕竟leader也有leader，也是要汇报的。可能算是大家比较反感的向上管理吧，有内味了，这个其实我也做得不好。但是最基本的一点，不要接了一个任务闷着头干活甚至与世隔绝了，一个月了也没跟leader同步过，想着憋个大招之类的，那基本凉凉。</p><p>‌一定要主动，可以先从强迫自己在各种公开场合发言开始，有问题或想法及时one-one。</p><h2 id="正面分享"><a href="#正面分享" class="headerlink" title="正面分享"></a>正面分享</h2><p>除了以上几点，还有一些小点我觉得也是比较重要的，列在下面： ‌</p><h3 id="第一件事建立信任"><a href="#第一件事建立信任" class="headerlink" title="第一件事建立信任"></a>第一件事建立信任</h3><p>‌<br>无论是校招还是社招，刚入职的第一件事是非常重要的，直接决定了leader和同事对自己的第一印象。入职后要做的第一件事一定要做好，最起码的要顺利完成而且不能出线上事故。这件事的目的就是为了建立信任，让团队觉得自己起码是靠谱的。如果这件事做得比较好，后面一路都会比较顺利。如果这件事就搞杂了，可能有的leader还会给第二次机会，再搞不好，后面就很难了，这一条对于社招来说更为重要。</p><p>而刚入职，公司技术栈不熟练，业务繁杂很难理清什么头绪，压力确实比较大。这时候一方面需要自己投入更多的精力，另一方面要多跟组内的同学交流，不懂就问。最有效率的学习方式，我觉得不是什么看书啊学习视频啊，而是直接去找对应的人聊，让别人讲一遍自己基本就全懂了，这效率比看文档看代码快多了，不仅省去了过滤无用信息的过程，还了解到了业务的演变历史。当然，这需要一定的沟通技巧，毕竟同事们也都很忙。</p><p><strong>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</strong></p><h3 id="超出预期"><a href="#超出预期" class="headerlink" title="超出预期"></a>超出预期</h3><p>超出预期这个词的外延范围很广，比如leader让去做个值周，解答用户群里大家的问题，结果不仅解答了大家的问题，还收集了这些问题进行分类，进而做了一个智能问答机器人解放了值周的人力，这可以算超出预期。比如leader让给运营做一个小工具，结果建设了一系列的工具甚至发展成了一个平台，成为了一个完整的项目，这也算超出预期。超出预期要求我们有把事情做大的能力，也就是想到了leader没想到的地方，并且创造了实际价值，拿到了业务收益。这个能力其实也比较重要，在工作中发现，有的人能把一个小盘子越做越大，而有的人恰好反之，那么那些有创新能力，经常超出预期的同学发展空间显然就更大一点。</p><p><strong>这块其实比较看个人能力，暂时没想到什么太好的捷径，多想一步吧。</strong></p><h3 id="体系化思考，系统化建设"><a href="#体系化思考，系统化建设" class="headerlink" title="体系化思考，系统化建设"></a>体系化思考，系统化建设</h3><p>这句话是晋升时候总结出来的，大意就是做系统建设要有全局视野，不要局限于某一个小点，应该有良好的规划能力和清晰的演进蓝图。比如，今天加了一个监控，明天加一个报警，这些事不应该成为一个个孤岛，而是属于稳定性建设一期其中的一小步。这一期稳定性建设要做的工作是报警配置和监控梳理，包括机器监控、系统监控、业务监控、数据监控等，预期能拿到XXX的收益。这个工作还有后续的roadmap，稳定性建设二期要做容量规划，接入压测，三期要做降级演练，多活容灾，四期要做…给人的感觉就是这个人思考非常全面，办事有体系有规划。</p><p><strong>平时积极总结沉淀，多跟别人交流，形成方法论。</strong></p><h3 id="提升自己的软素质能力"><a href="#提升自己的软素质能力" class="headerlink" title="提升自己的软素质能力"></a>提升自己的软素质能力</h3><p>这里的软素质能力其实想说的就是PPT、沟通、表达、时间管理、设计、文档等方面的能力。说实话，我觉得我当时能晋升就是因为PPT做的好了一点…可能大家平时对这些能力都不怎么关注，以前我也不重视，觉得比较简单，用时候直接上就行了，但事实可能并不像想象得那样简单。比如晋升时候PPT+演讲+答辩这个工作，其实有很多细节的思考在里面，内容如何选取，排版怎么设计，怎样引导听众的情绪，如何回答评委的问题等等。晋升时候我见过很多同学PPT内容编排杂乱无章，演讲过程也不流畅自然，虽然确实做了很多实际工作，但在表达上欠缺了很多，属于会做不会说，如果再遇到不了解实际情况的外部门评委，吃亏是可以预见的。<br>‌<br><strong>公司内网一般都会有一些软素质培训课程，可以找一些场合刻意训练。</strong></p><h2 id="不那么正面？"><a href="#不那么正面？" class="headerlink" title="不那么正面？"></a>不那么正面？</h2><p>以上都是这些分享还都算比较伟光正，但是社会吧也不全是那么美好的。。下面这些内容有负能量倾向，三观特别正的同学以及观感不适者建议跳过。 </p><h3 id="拍马屁是真的香"><a href="#拍马屁是真的香" class="headerlink" title="拍马屁是真的香"></a>拍马屁是真的香</h3><p>拍马屁这东西入职前我是很反感的，我最初想加入互联网公司的原因就是觉得互联网公司的人情世故没那么多，事实证明，我错了…入职前几天，部门群里大leader发了一条消息，后面几十条带着大拇指的消息立马跟上，学习了，点赞，真不错，优秀，那场面，说是红旗招展锣鼓喧天鞭炮齐鸣一点也不过分。除了惊叹大家超强的信息接收能力和处理速度外，更进一步我还发现，连拍马屁都是有队形的，一级部门leader发消息，几个二级部门leader跟上，后面各组长跟上，最后是大家的狂欢，让我一度怀疑拍马屁的速度就决定了职业生涯的发展前景（没错，现在我已经不怀疑了）。</p><p>坦诚地说，我到现在也没习惯在群里拍马屁，但也不反感了，可以说把这个事当成一乐了。倒不是说我没有那个口才和能力（事实上也不需要什么口才，大家都简单直接），在某些场合，为活跃气氛的需要，我也能小嘴儿抹了蜜，甚至能把古诗文彩虹屁给leader安排上。而是我发现我的直属leader也不怎么在群里拍马屁，所以我表面上不公开拍马屁其实属于暗地里事实上迎合了leader的喜好…</p><p>但是拍马屁这个事只要掌握好度，整体来说还是香的，最多是没用，至少不会有什么坏处嘛。大家能力都差不多，每一次在群里拍马屁的机会就是一次露脸的机会，按某个同事的说法，这就叫打造个人技术影响力…</p><p><strong>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</strong></p><h3 id="永不缺席的撕逼甩锅实战"><a href="#永不缺席的撕逼甩锅实战" class="headerlink" title="永不缺席的撕逼甩锅实战"></a>永不缺席的撕逼甩锅实战</h3><p>‌<br>有人的地方，就有江湖。虽然搞技术的大多城府也不深，但撕逼甩锅邀功抢活这些闹心的事儿基本也不会缺席，甚至我还见到过公开群发邮件撕逼的…这部分话题涉及到一些敏感信息就不多说了，而且我们低职级的遇到这些事儿的机会也不会太多。只是给大家提个醒，在工作的时候迟早都会吃到这方面的瓜，到时候留个心眼。</p><p><strong>稍微注意一下，咱不会去欺负别人，但也不能轻易让别人给欺负了。</strong><br>‌</p><h3 id="不要被画饼蒙蔽了双眼"><a href="#不要被画饼蒙蔽了双眼" class="headerlink" title="不要被画饼蒙蔽了双眼"></a>不要被画饼蒙蔽了双眼</h3><p>说实话，我个人是比较反感灌鸡汤、打鸡血、谈梦想、讲奋斗这一类行为的，9102年都快过完了，这一套***治还在大行其道，真不知道是该可笑还是可悲。当然，这些词本身并没有什么问题，但是这些东西应该是自驱的，而不应该成为外界的一种强push。『我必须努力奋斗』这个句式我觉得是正常的，但是『你必须努力奋斗』这种话多少感觉有点诡异，努力奋斗所以让公司的股东们发家致富？尤其在钱没给够的情况下，这些行为无异于耍流氓。我们需要对leader的这些画饼操作保持清醒的认知，理性分析，作出决策。比如感觉钱没给够（或者职级太低，同理）的时候，可能有以下几种情况：</p><ol><li><p>leader并没有注意到你薪资较低这一事实</p></li><li><p>leader知道这个事实，但是不知道你有多强烈的涨薪需求</p></li><li><p>leader知道你有涨薪的需求，但他觉得你能力还不够</p></li><li><p>leader知道你有涨薪的需求，能力也够，但是他不想给你涨</p></li><li><p>leader想给你涨，也向上反馈和争取了，但是没有资源</p></li></ol><p>这时候我们需要做的是向上反馈，跟leader沟通确认。如果是1和2，那么通过沟通可以消除信息误差。如果是3，需要分情况讨论。如果是4和5，已经可以考虑撤退了。对于这些事儿，也没必要抱怨，抱怨解决不了任何问题。我们要做的就是努力提升好个人能力，保持个人竞争力，等一个合适的时机，跳槽就完事了。</p><p><strong>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</strong></p><h3 id="学会包装"><a href="#学会包装" class="headerlink" title="学会包装"></a>学会包装</h3><p>这一条说白了就是，要会吹。忘了从哪儿看到的了，能说、会写、善做是对职场人的三大要求。能说是很重要的，能说才能要来项目，拉来资源，招来人。同样一件事，不同的人能说出来完全不一样的效果。比如我做了个小工具上线了，我就只能说出来基本事实，而让leader描述一下，这就成了，打造了XXX的工具抓手，改进了XXX的完整生态，形成了XXX的业务闭环。老哥，我服了，硬币全给你还不行嘛。据我的观察，每个互联网公司都有这么几个词，抓手、生态、闭环、拉齐、梳理、迭代、owner意识等等等等，我们需要做的就是熟读并背诵全文，啊不，是牢记并熟练使用。</p><p>这是对事情的包装，对人的包装也是一样的，尤其是在晋升和面试这样的应试型场合，特点是流程短一锤子买卖，包装显得尤为重要。晋升和面试这里就不展开说了，这里面的道和术太多了。。下面的场景提炼自面试过程中和某公司面试官的谈话，大家可以感受一下：</p><ul><li><p>我们背后是一个四五百亿美金的市场…</p></li><li><p>我负责过每天千亿级别访问量的系统…</p></li><li><p>工作两年能达到这个程度挺不错的…</p></li><li><p>贵司技术氛围挺好的，业务发展前景也很广阔…</p></li><li><p>啊，彼此彼此…</p></li><li><p>嗯，久仰久仰…</p></li></ul><p>人生如戏，全靠演技。<br>‌<br>可以多看leader的PPT，多听老板的向上汇报和宣讲会。</p><h3 id="选择和努力哪个更重要？"><a href="#选择和努力哪个更重要？" class="headerlink" title="选择和努力哪个更重要？"></a>选择和努力哪个更重要？</h3><p>这还用问么，当然是选择。在完美的选择面前，努力显得一文不值，我有个多年没联系的高中同学今年已经在时代广场敲钟了…但是这样的案例太少了，做出完美选择的随机成本太高，不确定性太大。对于大多数刚毕业的同学，对行业的判断力还不够成熟，对自身能力和创业难度把握得也不够精准，此时拉几个人去创业，显得风险太高。我觉得更为稳妥的一条路是，先加入规模稍大一点的公司，找一个好leader，抱好大腿，提升自己的个人能力。好平台加上大腿，再加上个人努力，这个起飞速度已经可以了。等后面积累了一定人脉和资金，深刻理解了市场和需求，对自己有信心了，可以再去考虑创业的事。</p><p><strong>如果对自己没太大自信的话，那就来头条一起抱团取暖吧，记住找我内推。</strong></p><p>本来还想分享一些生活方面的故事，发现已经这么长了，那就先这样叭。上面写的一些总结和建议我自己做的也不是很好，还需要继续加油，和大家共勉。另外，其中某些观点，由于个人视角的局限性也不保证是普适和正确的，可能再工作几年这些观点也会发生改变，欢迎大家跟我交流~（甩锅成功）<br>‌<br>最后祝大家都能找到心仪的工作，快乐工作，幸福生活，广阔天地，大有作为。</p>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>A Whisper To The World</title>
    <link href="/2018/12/01/A-Whisper-To-The-World/"/>
    <url>/2018/12/01/A-Whisper-To-The-World/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/12/01/5c017a914a980.jpg" alt="Nier"></p><p blockquote class="centerquote"><i> NieR:Automata </i></blockquote><span id="more"></span><p>Everything that lives is designed to end.<br>一切活着的事物，都注定要终结。  </p><p>We are perpetually trapped …<br>我们被永远地囚禁……  </p><p>… in a never-ending spiral of life and death.<br>……于永无止境的生死轮回之中。  </p><p>Is this a curse?<br>这是一种诅咒？  </p><p>Or some kind of punishment?<br>还是某种惩罚？</p><p>I often think about the god who blessed us with this cryptic puzzle …<br>我时常想起那用模糊的谜团祝福我们的神……  </p><p>… and wonder if we’ll ever have the chance to kill him.<br>……并猜想我们是否终有弑神的机会。</p>]]></content>
    
    
    <categories>
      
      <category>摘录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旧日</tag>
      
      <tag>上浮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gmail with Outloook</title>
    <link href="/2018/12/01/Gmail%20with%20Outloook/"/>
    <url>/2018/12/01/Gmail%20with%20Outloook/</url>
    
    <content type="html"><![CDATA[<p>UWP 是微软在 Windows 10 中引入的新概念，所有 UWP 应用均运行在被称为 App Container 的虚拟沙箱环境中，其安全性及纯净度远胜于传统的 EXE 应用。</p><p>但 App Container 机制同时也阻止了UWP 应用访问 localhost （Loopback，回环访问），即使你在系统设置中启用了代理，也无法令 UWP 应用访问本地代理服务器</p><h3 id="Gmail-amp-amp-Outlook"><a href="#Gmail-amp-amp-Outlook" class="headerlink" title="Gmail &amp;&amp; Outlook"></a>Gmail &amp;&amp; Outlook</h3><p>这里的 Outlook 指的是 Win10 自带的邮件 UWP 应用</p><p>我一般会选择用 Outlook 关联我的所有邮箱账号，例如 @smail.nju.edu.cn, @qq.com, @gmail.com</p><p>但是问题就在于，我无法在不具有Loopback 的 Win10邮件中关联 Gmail</p><p><strong>出于颜值和易用的考虑</strong></p><p>我选择</p><p><strong>解决问题而不是解决出现问题的软件</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <a href="https://link.zhihu.com/?target=http://www.telerik.com/fiddler">Fiddle</a> 网络调试工具排除网络隔离</p><p>「WinConfig」&gt; 选择需要 exempt 的项目</p><ul><li><table><thead><tr><th align="center">microsoft.xxxxbbwe</th><th>(No Package Name)</th><th>microsoft.xxxxbbwe</th></tr></thead><tbody><tr><td align="center">电子邮件和帐户</td><td>Microsoft.xxxxyewy</td><td>Microsoft.xxxxyewyyewy</td></tr><tr><td align="center">邮件和日历</td><td>microsoft.xxxxbbwe</td><td>microsoft.xxxxbbwe</td></tr></tbody></table></li><li><p>  「Save Changes」</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Trick</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UWP</tag>
      
      <tag>Win10</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2017/12/12/hello-world/"/>
    <url>/2017/12/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
